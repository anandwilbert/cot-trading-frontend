"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/material-react-table";
exports.ids = ["vendor-chunks/material-react-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/material-react-table/dist/index.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/material-react-table/dist/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MRT_ActionMenuItem: () => (/* binding */ MRT_ActionMenuItem),\n/* harmony export */   MRT_AggregationFns: () => (/* binding */ MRT_AggregationFns),\n/* harmony export */   MRT_BottomToolbar: () => (/* binding */ MRT_BottomToolbar),\n/* harmony export */   MRT_ColumnActionMenu: () => (/* binding */ MRT_ColumnActionMenu),\n/* harmony export */   MRT_ColumnPinningButtons: () => (/* binding */ MRT_ColumnPinningButtons),\n/* harmony export */   MRT_CopyButton: () => (/* binding */ MRT_CopyButton),\n/* harmony export */   MRT_DefaultColumn: () => (/* binding */ MRT_DefaultColumn),\n/* harmony export */   MRT_DefaultDisplayColumn: () => (/* binding */ MRT_DefaultDisplayColumn),\n/* harmony export */   MRT_EditActionButtons: () => (/* binding */ MRT_EditActionButtons),\n/* harmony export */   MRT_EditCellTextField: () => (/* binding */ MRT_EditCellTextField),\n/* harmony export */   MRT_EditRowModal: () => (/* binding */ MRT_EditRowModal),\n/* harmony export */   MRT_ExpandAllButton: () => (/* binding */ MRT_ExpandAllButton),\n/* harmony export */   MRT_ExpandButton: () => (/* binding */ MRT_ExpandButton),\n/* harmony export */   MRT_FilterCheckbox: () => (/* binding */ MRT_FilterCheckbox),\n/* harmony export */   MRT_FilterFns: () => (/* binding */ MRT_FilterFns),\n/* harmony export */   MRT_FilterOptionMenu: () => (/* binding */ MRT_FilterOptionMenu),\n/* harmony export */   MRT_FilterRangeFields: () => (/* binding */ MRT_FilterRangeFields),\n/* harmony export */   MRT_FilterRangeSlider: () => (/* binding */ MRT_FilterRangeSlider),\n/* harmony export */   MRT_FilterTextField: () => (/* binding */ MRT_FilterTextField),\n/* harmony export */   MRT_GlobalFilterTextField: () => (/* binding */ MRT_GlobalFilterTextField),\n/* harmony export */   MRT_GrabHandleButton: () => (/* binding */ MRT_GrabHandleButton),\n/* harmony export */   MRT_LinearProgressBar: () => (/* binding */ MRT_LinearProgressBar),\n/* harmony export */   MRT_RowActionMenu: () => (/* binding */ MRT_RowActionMenu),\n/* harmony export */   MRT_RowPinButton: () => (/* binding */ MRT_RowPinButton),\n/* harmony export */   MRT_SelectCheckbox: () => (/* binding */ MRT_SelectCheckbox),\n/* harmony export */   MRT_ShowHideColumnsButton: () => (/* binding */ MRT_ShowHideColumnsButton),\n/* harmony export */   MRT_ShowHideColumnsMenu: () => (/* binding */ MRT_ShowHideColumnsMenu),\n/* harmony export */   MRT_ShowHideColumnsMenuItems: () => (/* binding */ MRT_ShowHideColumnsMenuItems),\n/* harmony export */   MRT_SortingFns: () => (/* binding */ MRT_SortingFns),\n/* harmony export */   MRT_Table: () => (/* binding */ MRT_Table),\n/* harmony export */   MRT_TableBody: () => (/* binding */ MRT_TableBody),\n/* harmony export */   MRT_TableBodyCell: () => (/* binding */ MRT_TableBodyCell),\n/* harmony export */   MRT_TableBodyCellValue: () => (/* binding */ MRT_TableBodyCellValue),\n/* harmony export */   MRT_TableBodyRow: () => (/* binding */ MRT_TableBodyRow),\n/* harmony export */   MRT_TableBodyRowGrabHandle: () => (/* binding */ MRT_TableBodyRowGrabHandle),\n/* harmony export */   MRT_TableBodyRowPinButton: () => (/* binding */ MRT_TableBodyRowPinButton),\n/* harmony export */   MRT_TableContainer: () => (/* binding */ MRT_TableContainer),\n/* harmony export */   MRT_TableDetailPanel: () => (/* binding */ MRT_TableDetailPanel),\n/* harmony export */   MRT_TableFooter: () => (/* binding */ MRT_TableFooter),\n/* harmony export */   MRT_TableFooterCell: () => (/* binding */ MRT_TableFooterCell),\n/* harmony export */   MRT_TableFooterRow: () => (/* binding */ MRT_TableFooterRow),\n/* harmony export */   MRT_TableHead: () => (/* binding */ MRT_TableHead),\n/* harmony export */   MRT_TableHeadCell: () => (/* binding */ MRT_TableHeadCell),\n/* harmony export */   MRT_TableHeadCellColumnActionsButton: () => (/* binding */ MRT_TableHeadCellColumnActionsButton),\n/* harmony export */   MRT_TableHeadCellFilterContainer: () => (/* binding */ MRT_TableHeadCellFilterContainer),\n/* harmony export */   MRT_TableHeadCellFilterLabel: () => (/* binding */ MRT_TableHeadCellFilterLabel),\n/* harmony export */   MRT_TableHeadCellGrabHandle: () => (/* binding */ MRT_TableHeadCellGrabHandle),\n/* harmony export */   MRT_TableHeadCellResizeHandle: () => (/* binding */ MRT_TableHeadCellResizeHandle),\n/* harmony export */   MRT_TableHeadCellSortLabel: () => (/* binding */ MRT_TableHeadCellSortLabel),\n/* harmony export */   MRT_TableHeadRow: () => (/* binding */ MRT_TableHeadRow),\n/* harmony export */   MRT_TableLoadingOverlay: () => (/* binding */ MRT_TableLoadingOverlay),\n/* harmony export */   MRT_TablePagination: () => (/* binding */ MRT_TablePagination),\n/* harmony export */   MRT_TablePaper: () => (/* binding */ MRT_TablePaper),\n/* harmony export */   MRT_ToggleDensePaddingButton: () => (/* binding */ MRT_ToggleDensePaddingButton),\n/* harmony export */   MRT_ToggleFiltersButton: () => (/* binding */ MRT_ToggleFiltersButton),\n/* harmony export */   MRT_ToggleFullScreenButton: () => (/* binding */ MRT_ToggleFullScreenButton),\n/* harmony export */   MRT_ToggleGlobalFilterButton: () => (/* binding */ MRT_ToggleGlobalFilterButton),\n/* harmony export */   MRT_ToggleRowActionMenuButton: () => (/* binding */ MRT_ToggleRowActionMenuButton),\n/* harmony export */   MRT_ToolbarAlertBanner: () => (/* binding */ MRT_ToolbarAlertBanner),\n/* harmony export */   MRT_ToolbarDropZone: () => (/* binding */ MRT_ToolbarDropZone),\n/* harmony export */   MRT_ToolbarInternalButtons: () => (/* binding */ MRT_ToolbarInternalButtons),\n/* harmony export */   MRT_TopToolbar: () => (/* binding */ MRT_TopToolbar),\n/* harmony export */   MaterialReactTable: () => (/* binding */ MaterialReactTable),\n/* harmony export */   Memo_MRT_TableBody: () => (/* binding */ Memo_MRT_TableBody),\n/* harmony export */   Memo_MRT_TableBodyCell: () => (/* binding */ Memo_MRT_TableBodyCell),\n/* harmony export */   Memo_MRT_TableBodyRow: () => (/* binding */ Memo_MRT_TableBodyRow),\n/* harmony export */   cellKeyboardShortcuts: () => (/* binding */ cellKeyboardShortcuts),\n/* harmony export */   createMRTColumnHelper: () => (/* binding */ createMRTColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   defaultDisplayColumnProps: () => (/* binding */ defaultDisplayColumnProps),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   getAllLeafColumnDefs: () => (/* binding */ getAllLeafColumnDefs),\n/* harmony export */   getCanRankRows: () => (/* binding */ getCanRankRows),\n/* harmony export */   getColumnFilterInfo: () => (/* binding */ getColumnFilterInfo),\n/* harmony export */   getColumnId: () => (/* binding */ getColumnId),\n/* harmony export */   getDefaultColumnFilterFn: () => (/* binding */ getDefaultColumnFilterFn),\n/* harmony export */   getDefaultColumnOrderIds: () => (/* binding */ getDefaultColumnOrderIds),\n/* harmony export */   getIsRankingRows: () => (/* binding */ getIsRankingRows),\n/* harmony export */   getIsRowSelected: () => (/* binding */ getIsRowSelected),\n/* harmony export */   getLeadingDisplayColumnIds: () => (/* binding */ getLeadingDisplayColumnIds),\n/* harmony export */   getMRT_RowSelectionHandler: () => (/* binding */ getMRT_RowSelectionHandler),\n/* harmony export */   getMRT_Rows: () => (/* binding */ getMRT_Rows),\n/* harmony export */   getMRT_SelectAllHandler: () => (/* binding */ getMRT_SelectAllHandler),\n/* harmony export */   getTrailingDisplayColumnIds: () => (/* binding */ getTrailingDisplayColumnIds),\n/* harmony export */   isCellEditable: () => (/* binding */ isCellEditable),\n/* harmony export */   mrtFilterOptions: () => (/* binding */ mrtFilterOptions),\n/* harmony export */   openEditingCell: () => (/* binding */ openEditingCell),\n/* harmony export */   prepareColumns: () => (/* binding */ prepareColumns),\n/* harmony export */   rankGlobalFuzzy: () => (/* binding */ rankGlobalFuzzy),\n/* harmony export */   reorderColumn: () => (/* binding */ reorderColumn),\n/* harmony export */   showRowActionsColumn: () => (/* binding */ showRowActionsColumn),\n/* harmony export */   showRowDragColumn: () => (/* binding */ showRowDragColumn),\n/* harmony export */   showRowExpandColumn: () => (/* binding */ showRowExpandColumn),\n/* harmony export */   showRowNumbersColumn: () => (/* binding */ showRowNumbersColumn),\n/* harmony export */   showRowPinningColumn: () => (/* binding */ showRowPinningColumn),\n/* harmony export */   showRowSelectionColumn: () => (/* binding */ showRowSelectionColumn),\n/* harmony export */   showRowSpacerColumn: () => (/* binding */ showRowSpacerColumn),\n/* harmony export */   useDropdownOptions: () => (/* binding */ useDropdownOptions),\n/* harmony export */   useMRT_ColumnVirtualizer: () => (/* binding */ useMRT_ColumnVirtualizer),\n/* harmony export */   useMRT_Effects: () => (/* binding */ useMRT_Effects),\n/* harmony export */   useMRT_RowVirtualizer: () => (/* binding */ useMRT_RowVirtualizer),\n/* harmony export */   useMRT_Rows: () => (/* binding */ useMRT_Rows),\n/* harmony export */   useMRT_TableInstance: () => (/* binding */ useMRT_TableInstance),\n/* harmony export */   useMRT_TableOptions: () => (/* binding */ useMRT_TableOptions),\n/* harmony export */   useMaterialReactTable: () => (/* binding */ useMaterialReactTable)\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tanstack/react-table */ \"(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\");\n/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tanstack/react-table */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tanstack_match_sorter_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tanstack/match-sorter-utils */ \"(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @mui/material/IconButton */ \"(ssr)/./node_modules/@mui/material/esm/IconButton/IconButton.js\");\n/* harmony import */ var _mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mui/material/Tooltip */ \"(ssr)/./node_modules/@mui/material/esm/Tooltip/Tooltip.js\");\n/* harmony import */ var _mui_material_Box__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mui/material/Box */ \"(ssr)/./node_modules/@mui/material/esm/Box/Box.js\");\n/* harmony import */ var _mui_material_Button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @mui/material/Button */ \"(ssr)/./node_modules/@mui/material/esm/Button/Button.js\");\n/* harmony import */ var _mui_material_CircularProgress__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @mui/material/CircularProgress */ \"(ssr)/./node_modules/@mui/material/esm/CircularProgress/CircularProgress.js\");\n/* harmony import */ var _mui_material_styles__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @mui/material/styles */ \"(ssr)/./node_modules/@mui/system/esm/colorManipulator/colorManipulator.js\");\n/* harmony import */ var _mui_material_styles__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @mui/material/styles */ \"(ssr)/./node_modules/@mui/material/esm/styles/useTheme.js\");\n/* harmony import */ var _mui_material_Menu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @mui/material/Menu */ \"(ssr)/./node_modules/@mui/material/esm/Menu/Menu.js\");\n/* harmony import */ var _mui_material_ListItemIcon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @mui/material/ListItemIcon */ \"(ssr)/./node_modules/@mui/material/esm/ListItemIcon/ListItemIcon.js\");\n/* harmony import */ var _mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @mui/material/MenuItem */ \"(ssr)/./node_modules/@mui/material/esm/MenuItem/MenuItem.js\");\n/* harmony import */ var _mui_material_Stack__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @mui/material/Stack */ \"(ssr)/./node_modules/@mui/material/esm/Stack/Stack.js\");\n/* harmony import */ var _mui_material_Checkbox__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @mui/material/Checkbox */ \"(ssr)/./node_modules/@mui/material/esm/Checkbox/Checkbox.js\");\n/* harmony import */ var _mui_material_Radio__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @mui/material/Radio */ \"(ssr)/./node_modules/@mui/material/esm/Radio/Radio.js\");\n/* harmony import */ var _mui_icons_material_ArrowDownward__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @mui/icons-material/ArrowDownward */ \"(ssr)/./node_modules/@mui/icons-material/esm/ArrowDownward.js\");\n/* harmony import */ var _mui_icons_material_ArrowRight__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @mui/icons-material/ArrowRight */ \"(ssr)/./node_modules/@mui/icons-material/esm/ArrowRight.js\");\n/* harmony import */ var _mui_icons_material_Cancel__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @mui/icons-material/Cancel */ \"(ssr)/./node_modules/@mui/icons-material/esm/Cancel.js\");\n/* harmony import */ var _mui_icons_material_ChevronLeft__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @mui/icons-material/ChevronLeft */ \"(ssr)/./node_modules/@mui/icons-material/esm/ChevronLeft.js\");\n/* harmony import */ var _mui_icons_material_ChevronRight__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @mui/icons-material/ChevronRight */ \"(ssr)/./node_modules/@mui/icons-material/esm/ChevronRight.js\");\n/* harmony import */ var _mui_icons_material_ClearAll__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @mui/icons-material/ClearAll */ \"(ssr)/./node_modules/@mui/icons-material/esm/ClearAll.js\");\n/* harmony import */ var _mui_icons_material_Close__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @mui/icons-material/Close */ \"(ssr)/./node_modules/@mui/icons-material/esm/Close.js\");\n/* harmony import */ var _mui_icons_material_ContentCopy__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @mui/icons-material/ContentCopy */ \"(ssr)/./node_modules/@mui/icons-material/esm/ContentCopy.js\");\n/* harmony import */ var _mui_icons_material_DensityLarge__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @mui/icons-material/DensityLarge */ \"(ssr)/./node_modules/@mui/icons-material/esm/DensityLarge.js\");\n/* harmony import */ var _mui_icons_material_DensityMedium__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @mui/icons-material/DensityMedium */ \"(ssr)/./node_modules/@mui/icons-material/esm/DensityMedium.js\");\n/* harmony import */ var _mui_icons_material_DensitySmall__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @mui/icons-material/DensitySmall */ \"(ssr)/./node_modules/@mui/icons-material/esm/DensitySmall.js\");\n/* harmony import */ var _mui_icons_material_DragHandle__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @mui/icons-material/DragHandle */ \"(ssr)/./node_modules/@mui/icons-material/esm/DragHandle.js\");\n/* harmony import */ var _mui_icons_material_DynamicFeed__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @mui/icons-material/DynamicFeed */ \"(ssr)/./node_modules/@mui/icons-material/esm/DynamicFeed.js\");\n/* harmony import */ var _mui_icons_material_Edit__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @mui/icons-material/Edit */ \"(ssr)/./node_modules/@mui/icons-material/esm/Edit.js\");\n/* harmony import */ var _mui_icons_material_ExpandMore__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @mui/icons-material/ExpandMore */ \"(ssr)/./node_modules/@mui/icons-material/esm/ExpandMore.js\");\n/* harmony import */ var _mui_icons_material_FilterAlt__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @mui/icons-material/FilterAlt */ \"(ssr)/./node_modules/@mui/icons-material/esm/FilterAlt.js\");\n/* harmony import */ var _mui_icons_material_FilterList__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @mui/icons-material/FilterList */ \"(ssr)/./node_modules/@mui/icons-material/esm/FilterList.js\");\n/* harmony import */ var _mui_icons_material_FilterListOff__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @mui/icons-material/FilterListOff */ \"(ssr)/./node_modules/@mui/icons-material/esm/FilterListOff.js\");\n/* harmony import */ var _mui_icons_material_FirstPage__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @mui/icons-material/FirstPage */ \"(ssr)/./node_modules/@mui/icons-material/esm/FirstPage.js\");\n/* harmony import */ var _mui_icons_material_Fullscreen__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! @mui/icons-material/Fullscreen */ \"(ssr)/./node_modules/@mui/icons-material/esm/Fullscreen.js\");\n/* harmony import */ var _mui_icons_material_FullscreenExit__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @mui/icons-material/FullscreenExit */ \"(ssr)/./node_modules/@mui/icons-material/esm/FullscreenExit.js\");\n/* harmony import */ var _mui_icons_material_KeyboardDoubleArrowDown__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! @mui/icons-material/KeyboardDoubleArrowDown */ \"(ssr)/./node_modules/@mui/icons-material/esm/KeyboardDoubleArrowDown.js\");\n/* harmony import */ var _mui_icons_material_LastPage__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! @mui/icons-material/LastPage */ \"(ssr)/./node_modules/@mui/icons-material/esm/LastPage.js\");\n/* harmony import */ var _mui_icons_material_MoreHoriz__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! @mui/icons-material/MoreHoriz */ \"(ssr)/./node_modules/@mui/icons-material/esm/MoreHoriz.js\");\n/* harmony import */ var _mui_icons_material_MoreVert__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! @mui/icons-material/MoreVert */ \"(ssr)/./node_modules/@mui/icons-material/esm/MoreVert.js\");\n/* harmony import */ var _mui_icons_material_PushPin__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! @mui/icons-material/PushPin */ \"(ssr)/./node_modules/@mui/icons-material/esm/PushPin.js\");\n/* harmony import */ var _mui_icons_material_RestartAlt__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! @mui/icons-material/RestartAlt */ \"(ssr)/./node_modules/@mui/icons-material/esm/RestartAlt.js\");\n/* harmony import */ var _mui_icons_material_Save__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! @mui/icons-material/Save */ \"(ssr)/./node_modules/@mui/icons-material/esm/Save.js\");\n/* harmony import */ var _mui_icons_material_Search__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! @mui/icons-material/Search */ \"(ssr)/./node_modules/@mui/icons-material/esm/Search.js\");\n/* harmony import */ var _mui_icons_material_SearchOff__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! @mui/icons-material/SearchOff */ \"(ssr)/./node_modules/@mui/icons-material/esm/SearchOff.js\");\n/* harmony import */ var _mui_icons_material_Sort__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! @mui/icons-material/Sort */ \"(ssr)/./node_modules/@mui/icons-material/esm/Sort.js\");\n/* harmony import */ var _mui_icons_material_SyncAlt__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! @mui/icons-material/SyncAlt */ \"(ssr)/./node_modules/@mui/icons-material/esm/SyncAlt.js\");\n/* harmony import */ var _mui_icons_material_ViewColumn__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! @mui/icons-material/ViewColumn */ \"(ssr)/./node_modules/@mui/icons-material/esm/ViewColumn.js\");\n/* harmony import */ var _mui_icons_material_VisibilityOff__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! @mui/icons-material/VisibilityOff */ \"(ssr)/./node_modules/@mui/icons-material/esm/VisibilityOff.js\");\n/* harmony import */ var _tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! @tanstack/react-virtual */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n/* harmony import */ var _tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! @tanstack/react-virtual */ \"(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\");\n/* harmony import */ var _mui_material_Paper__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! @mui/material/Paper */ \"(ssr)/./node_modules/@mui/material/esm/Paper/Paper.js\");\n/* harmony import */ var _mui_material_TableContainer__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! @mui/material/TableContainer */ \"(ssr)/./node_modules/@mui/material/esm/TableContainer/TableContainer.js\");\n/* harmony import */ var _mui_material_Table__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! @mui/material/Table */ \"(ssr)/./node_modules/@mui/material/esm/Table/Table.js\");\n/* harmony import */ var _mui_material_TableBody__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! @mui/material/TableBody */ \"(ssr)/./node_modules/@mui/material/esm/TableBody/TableBody.js\");\n/* harmony import */ var _mui_material_Typography__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! @mui/material/Typography */ \"(ssr)/./node_modules/@mui/material/esm/Typography/Typography.js\");\n/* harmony import */ var _mui_material_TableRow__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! @mui/material/TableRow */ \"(ssr)/./node_modules/@mui/material/esm/TableRow/TableRow.js\");\n/* harmony import */ var _mui_material_Skeleton__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! @mui/material/Skeleton */ \"(ssr)/./node_modules/@mui/material/esm/Skeleton/Skeleton.js\");\n/* harmony import */ var _mui_material_TableCell__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! @mui/material/TableCell */ \"(ssr)/./node_modules/@mui/material/esm/TableCell/TableCell.js\");\n/* harmony import */ var highlight_words__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! highlight-words */ \"(ssr)/./node_modules/highlight-words/dist/highlight-words.mjs\");\n/* harmony import */ var _mui_material_TextField__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! @mui/material/TextField */ \"(ssr)/./node_modules/@mui/material/esm/TextField/TextField.js\");\n/* harmony import */ var _mui_material_Collapse__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! @mui/material/Collapse */ \"(ssr)/./node_modules/@mui/material/esm/Collapse/Collapse.js\");\n/* harmony import */ var _mui_material_TableFooter__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! @mui/material/TableFooter */ \"(ssr)/./node_modules/@mui/material/esm/TableFooter/TableFooter.js\");\n/* harmony import */ var _mui_material_TableHead__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! @mui/material/TableHead */ \"(ssr)/./node_modules/@mui/material/esm/TableHead/TableHead.js\");\n/* harmony import */ var _mui_material_FormControlLabel__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! @mui/material/FormControlLabel */ \"(ssr)/./node_modules/@mui/material/esm/FormControlLabel/FormControlLabel.js\");\n/* harmony import */ var _mui_material_Autocomplete__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! @mui/material/Autocomplete */ \"(ssr)/./node_modules/@mui/material/esm/Autocomplete/Autocomplete.js\");\n/* harmony import */ var _mui_material_Chip__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! @mui/material/Chip */ \"(ssr)/./node_modules/@mui/material/esm/Chip/Chip.js\");\n/* harmony import */ var _mui_material_InputAdornment__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! @mui/material/InputAdornment */ \"(ssr)/./node_modules/@mui/material/esm/InputAdornment/InputAdornment.js\");\n/* harmony import */ var _mui_material_utils__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! @mui/material/utils */ \"(ssr)/./node_modules/@mui/material/esm/utils/debounce.js\");\n/* harmony import */ var _mui_x_date_pickers_DatePicker__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! @mui/x-date-pickers/DatePicker */ \"(ssr)/./node_modules/@mui/x-date-pickers/esm/DatePicker/DatePicker.js\");\n/* harmony import */ var _mui_x_date_pickers_DateTimePicker__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! @mui/x-date-pickers/DateTimePicker */ \"(ssr)/./node_modules/@mui/x-date-pickers/esm/DateTimePicker/DateTimePicker.js\");\n/* harmony import */ var _mui_x_date_pickers_TimePicker__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! @mui/x-date-pickers/TimePicker */ \"(ssr)/./node_modules/@mui/x-date-pickers/esm/TimePicker/TimePicker.js\");\n/* harmony import */ var _mui_material_FormHelperText__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! @mui/material/FormHelperText */ \"(ssr)/./node_modules/@mui/material/esm/FormHelperText/FormHelperText.js\");\n/* harmony import */ var _mui_material_Slider__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! @mui/material/Slider */ \"(ssr)/./node_modules/@mui/material/esm/Slider/Slider.js\");\n/* harmony import */ var _mui_material_Grow__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! @mui/material/Grow */ \"(ssr)/./node_modules/@mui/material/esm/Grow/Grow.js\");\n/* harmony import */ var _mui_material_Popover__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! @mui/material/Popover */ \"(ssr)/./node_modules/@mui/material/esm/Popover/Popover.js\");\n/* harmony import */ var _mui_material_Divider__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! @mui/material/Divider */ \"(ssr)/./node_modules/@mui/material/esm/Divider/Divider.js\");\n/* harmony import */ var _mui_material_Badge__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! @mui/material/Badge */ \"(ssr)/./node_modules/@mui/material/esm/Badge/Badge.js\");\n/* harmony import */ var _mui_material_TableSortLabel__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! @mui/material/TableSortLabel */ \"(ssr)/./node_modules/@mui/material/esm/TableSortLabel/TableSortLabel.js\");\n/* harmony import */ var _mui_material_Alert__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! @mui/material/Alert */ \"(ssr)/./node_modules/@mui/material/esm/Alert/Alert.js\");\n/* harmony import */ var _mui_material_AlertTitle__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! @mui/material/AlertTitle */ \"(ssr)/./node_modules/@mui/material/esm/AlertTitle/AlertTitle.js\");\n/* harmony import */ var _mui_material_Dialog__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! @mui/material/Dialog */ \"(ssr)/./node_modules/@mui/material/esm/Dialog/Dialog.js\");\n/* harmony import */ var _mui_material_DialogActions__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! @mui/material/DialogActions */ \"(ssr)/./node_modules/@mui/material/esm/DialogActions/DialogActions.js\");\n/* harmony import */ var _mui_material_DialogContent__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! @mui/material/DialogContent */ \"(ssr)/./node_modules/@mui/material/esm/DialogContent/DialogContent.js\");\n/* harmony import */ var _mui_material_DialogTitle__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! @mui/material/DialogTitle */ \"(ssr)/./node_modules/@mui/material/esm/DialogTitle/DialogTitle.js\");\n/* harmony import */ var _mui_material_useMediaQuery__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! @mui/material/useMediaQuery */ \"(ssr)/./node_modules/@mui/material/esm/useMediaQuery/index.js\");\n/* harmony import */ var _mui_material_LinearProgress__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! @mui/material/LinearProgress */ \"(ssr)/./node_modules/@mui/material/esm/LinearProgress/LinearProgress.js\");\n/* harmony import */ var _mui_material_InputLabel__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! @mui/material/InputLabel */ \"(ssr)/./node_modules/@mui/material/esm/InputLabel/InputLabel.js\");\n/* harmony import */ var _mui_material_Pagination__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! @mui/material/Pagination */ \"(ssr)/./node_modules/@mui/material/esm/Pagination/Pagination.js\");\n/* harmony import */ var _mui_material_PaginationItem__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! @mui/material/PaginationItem */ \"(ssr)/./node_modules/@mui/material/esm/PaginationItem/PaginationItem.js\");\n/* harmony import */ var _mui_material_Select__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! @mui/material/Select */ \"(ssr)/./node_modules/@mui/material/esm/Select/Select.js\");\n/* harmony import */ var _mui_material_Fade__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! @mui/material/Fade */ \"(ssr)/./node_modules/@mui/material/esm/Fade/Fade.js\");\n/* harmony import */ var _mui_material_Switch__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! @mui/material/Switch */ \"(ssr)/./node_modules/@mui/material/esm/Switch/Switch.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst getColumnId = (columnDef) => { var _a, _b, _c, _d; return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header; };\nconst getAllLeafColumnDefs = (columns) => {\n    const allLeafColumnDefs = [];\n    const getLeafColumns = (cols) => {\n        cols.forEach((col) => {\n            if (col.columns) {\n                getLeafColumns(col.columns);\n            }\n            else {\n                allLeafColumnDefs.push(col);\n            }\n        });\n    };\n    getLeafColumns(columns);\n    return allLeafColumnDefs;\n};\nconst prepareColumns = ({ columnDefs, tableOptions, }) => {\n    const { aggregationFns = {}, defaultDisplayColumn, filterFns = {}, sortingFns = {}, state: { columnFilterFns = {} } = {}, } = tableOptions;\n    return columnDefs.map((columnDef) => {\n        var _a, _b;\n        //assign columnId\n        if (!columnDef.id)\n            columnDef.id = getColumnId(columnDef);\n        //assign columnDefType\n        if (!columnDef.columnDefType)\n            columnDef.columnDefType = 'data';\n        if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {\n            columnDef.columnDefType = 'group';\n            //recursively prepare columns if this is a group column\n            columnDef.columns = prepareColumns({\n                columnDefs: columnDef.columns,\n                tableOptions,\n            });\n        }\n        else if (columnDef.columnDefType === 'data') {\n            //assign aggregationFns if multiple aggregationFns are provided\n            if (Array.isArray(columnDef.aggregationFn)) {\n                const aggFns = columnDef.aggregationFn;\n                columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => { var _a; return (_a = aggregationFns[fn]) === null || _a === void 0 ? void 0 : _a.call(aggregationFns, columnId, leafRows, childRows); });\n            }\n            //assign filterFns\n            if (Object.keys(filterFns).includes(columnFilterFns[columnDef.id])) {\n                columnDef.filterFn =\n                    (_b = filterFns[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns.fuzzy;\n                columnDef._filterFn =\n                    columnFilterFns[columnDef.id];\n            }\n            //assign sortingFns\n            if (Object.keys(sortingFns).includes(columnDef.sortingFn)) {\n                // @ts-expect-error\n                columnDef.sortingFn = sortingFns[columnDef.sortingFn];\n            }\n        }\n        else if (columnDef.columnDefType === 'display') {\n            columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);\n        }\n        return columnDef;\n    });\n};\nconst reorderColumn = (draggedColumn, targetColumn, columnOrder) => {\n    if (draggedColumn.getCanPin()) {\n        draggedColumn.pin(targetColumn.getIsPinned());\n    }\n    const newColumnOrder = [...columnOrder];\n    newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);\n    return newColumnOrder;\n};\nconst getDefaultColumnFilterFn = (columnDef) => {\n    const { filterVariant } = columnDef;\n    if (filterVariant === 'multi-select')\n        return 'arrIncludesSome';\n    if (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes('range'))\n        return 'betweenInclusive';\n    if (filterVariant === 'select' || filterVariant === 'checkbox')\n        return 'equals';\n    return 'fuzzy';\n};\nconst getColumnFilterInfo = ({ header, table, }) => {\n    var _a;\n    const { options: { columnFilterModeOptions }, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const { filterVariant } = columnDef;\n    const isDateFilter = !!((filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('date')) || (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('time')));\n    const isAutocompleteFilter = filterVariant === 'autocomplete';\n    const isRangeFilter = (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes('range')) ||\n        ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn);\n    const isSelectFilter = filterVariant === 'select';\n    const isMultiSelectFilter = filterVariant === 'multi-select';\n    const isTextboxFilter = ['autocomplete', 'text'].includes(filterVariant) ||\n        (!isSelectFilter && !isMultiSelectFilter);\n    const currentFilterOption = columnDef._filterFn;\n    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;\n    const facetedUniqueValues = column.getFacetedUniqueValues();\n    return {\n        allowedColumnFilterOptions,\n        currentFilterOption,\n        facetedUniqueValues,\n        isAutocompleteFilter,\n        isDateFilter,\n        isMultiSelectFilter,\n        isRangeFilter,\n        isSelectFilter,\n        isTextboxFilter,\n    };\n};\nconst useDropdownOptions = ({ header, table, }) => {\n    const { column } = header;\n    const { columnDef } = column;\n    const { facetedUniqueValues, isAutocompleteFilter, isMultiSelectFilter, isSelectFilter, } = getColumnFilterInfo({ header, table });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return (_a = columnDef.filterSelectOptions) !== null && _a !== void 0 ? _a : ((isSelectFilter || isMultiSelectFilter || isAutocompleteFilter) &&\n            facetedUniqueValues\n            ? Array.from(facetedUniqueValues.keys())\n                .filter((value) => value !== null && value !== undefined)\n                .sort((a, b) => a.localeCompare(b))\n            : undefined);\n    }, [\n        columnDef.filterSelectOptions,\n        facetedUniqueValues,\n        isMultiSelectFilter,\n        isSelectFilter,\n    ]);\n};\n\nconst flexRender = _tanstack_react_table__WEBPACK_IMPORTED_MODULE_3__.flexRender;\nfunction createMRTColumnHelper() {\n    return {\n        accessor: (accessor, column) => {\n            return typeof accessor === 'function'\n                ? Object.assign(Object.assign({}, column), { accessorFn: accessor })\n                : Object.assign(Object.assign({}, column), { accessorKey: accessor });\n        },\n        display: (column) => column,\n        group: (column) => column,\n    };\n}\nconst createRow = (table, originalRow, rowIndex = -1, depth = 0, subRows, parentId) => (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.createRow)(table, 'mrt-row-create', originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns).map((col) => ({\n    [getColumnId(col)]: '',\n}))), rowIndex, depth, subRows, parentId);\n\nconst fuzzy$1 = (rowA, rowB, columnId) => {\n    let dir = 0;\n    if (rowA.columnFiltersMeta[columnId]) {\n        dir = (0,_tanstack_match_sorter_utils__WEBPACK_IMPORTED_MODULE_5__.compareItems)(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);\n    }\n    // Provide a fallback for when the item ranks are equal\n    return dir === 0\n        ? _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.sortingFns.alphanumeric(rowA, rowB, columnId)\n        : dir;\n};\nconst MRT_SortingFns = Object.assign(Object.assign({}, _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.sortingFns), { fuzzy: fuzzy$1 });\nconst rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) -\n    Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));\n\nconst parseFromValuesOrFunc = (fn, arg) => (fn instanceof Function ? fn(arg) : fn);\nconst getValueAndLabel = (option) => {\n    var _a, _b;\n    let label = '';\n    let value = '';\n    if (option) {\n        if (typeof option !== 'object') {\n            label = option;\n            value = option;\n        }\n        else {\n            label = (_a = option.label) !== null && _a !== void 0 ? _a : option.value;\n            value = (_b = option.value) !== null && _b !== void 0 ? _b : label;\n        }\n    }\n    return { label, value };\n};\n\nconst getMRT_Rows = (table, all) => {\n    const { getCenterRows, getPrePaginationRowModel, getRowModel, getState, getTopRows, options: { createDisplayMode, enablePagination, enableRowPinning, manualPagination, positionCreatingRow, rowPinningDisplayMode, }, } = table;\n    const { creatingRow, pagination } = getState();\n    const isRankingRows = getIsRankingRows(table);\n    let rows = [];\n    if (!isRankingRows) {\n        rows =\n            !enableRowPinning || (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))\n                ? all\n                    ? getPrePaginationRowModel().rows\n                    : getRowModel().rows\n                : getCenterRows();\n    }\n    else {\n        // fuzzy ranking adjustments\n        rows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));\n        if (enablePagination && !manualPagination && !all) {\n            const start = pagination.pageIndex * pagination.pageSize;\n            rows = rows.slice(start, start + pagination.pageSize);\n        }\n        if (enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {\n            // \"re-center-ize\" the rows (no top or bottom pinned rows unless sticky)\n            rows = rows.filter((row) => !row.getIsPinned());\n        }\n    }\n    // row pinning adjustments\n    if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {\n        const centerPinnedRowIds = rows\n            .filter((row) => row.getIsPinned())\n            .map((r) => r.id);\n        rows = [\n            ...getTopRows().filter((row) => !centerPinnedRowIds.includes(row.id)),\n            ...rows,\n        ];\n    }\n    // blank inserted creating row adjustments\n    if (positionCreatingRow !== undefined &&\n        creatingRow &&\n        createDisplayMode === 'row') {\n        const creatingRowIndex = !isNaN(+positionCreatingRow)\n            ? +positionCreatingRow\n            : positionCreatingRow === 'top'\n                ? 0\n                : rows.length;\n        rows = [\n            ...rows.slice(0, creatingRowIndex),\n            creatingRow,\n            ...rows.slice(creatingRowIndex),\n        ];\n    }\n    return rows;\n};\nconst getCanRankRows = (table) => {\n    const { getState, options: { enableGlobalFilterRankedResults, manualExpanding, manualFiltering, manualGrouping, manualSorting, }, } = table;\n    const { expanded, globalFilterFn } = getState();\n    return (!manualExpanding &&\n        !manualFiltering &&\n        !manualGrouping &&\n        !manualSorting &&\n        enableGlobalFilterRankedResults &&\n        globalFilterFn === 'fuzzy' &&\n        expanded !== true &&\n        !Object.values(expanded).some(Boolean));\n};\nconst getIsRankingRows = (table) => {\n    const { globalFilter, sorting } = table.getState();\n    return (getCanRankRows(table) &&\n        globalFilter &&\n        !Object.values(sorting).some(Boolean));\n};\nconst getIsRowSelected = ({ row, table, }) => {\n    const { options: { enableRowSelection }, } = table;\n    return (row.getIsSelected() ||\n        (parseFromValuesOrFunc(enableRowSelection, row) &&\n            row.getCanSelectSubRows() &&\n            row.getIsAllSubRowsSelected()));\n};\nconst getMRT_RowSelectionHandler = ({ row, staticRowIndex = 0, table, }) => (event, value) => {\n    var _a;\n    const { getState, options: { enableBatchRowSelection, enableMultiRowSelection, enableRowPinning, manualPagination, rowPinningDisplayMode, }, refs: { lastSelectedRowId: lastSelectedRowId }, } = table;\n    const { pagination: { pageIndex, pageSize }, } = getState();\n    const paginationOffset = manualPagination ? 0 : pageSize * pageIndex;\n    const wasCurrentRowChecked = getIsRowSelected({ row, table });\n    // toggle selection of this row\n    row.toggleSelected(value !== null && value !== void 0 ? value : !wasCurrentRowChecked);\n    const changedRowIds = new Set([row.id]);\n    // if shift key is pressed, select all rows between last selected and this one\n    if (enableBatchRowSelection &&\n        enableMultiRowSelection &&\n        event.nativeEvent.shiftKey &&\n        lastSelectedRowId.current !== null) {\n        const rows = getMRT_Rows(table, true);\n        const lastIndex = rows.findIndex((r) => r.id === lastSelectedRowId.current);\n        if (lastIndex !== -1) {\n            const isLastIndexChecked = getIsRowSelected({\n                row: rows === null || rows === void 0 ? void 0 : rows[lastIndex],\n                table,\n            });\n            const currentIndex = staticRowIndex + paginationOffset;\n            const [start, end] = lastIndex < currentIndex\n                ? [lastIndex, currentIndex]\n                : [currentIndex, lastIndex];\n            // toggle selection of all rows between last selected and this one\n            // but only if the last selected row is not the same as the current one\n            if (wasCurrentRowChecked !== isLastIndexChecked) {\n                for (let i = start; i <= end; i++) {\n                    rows[i].toggleSelected(!wasCurrentRowChecked);\n                    changedRowIds.add(rows[i].id);\n                }\n            }\n        }\n    }\n    // record the last selected row id\n    lastSelectedRowId.current = row.id;\n    // if all sub rows were selected, unselect them\n    if (row.getCanSelectSubRows() && row.getIsAllSubRowsSelected()) {\n        (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.forEach((r) => r.toggleSelected(false));\n    }\n    if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'))) {\n        changedRowIds.forEach((rowId) => {\n            const rowToTogglePin = table.getRow(rowId);\n            rowToTogglePin.pin(!wasCurrentRowChecked //was not previously pinned or selected\n                ? (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('bottom'))\n                    ? 'bottom'\n                    : 'top'\n                : false);\n        });\n    }\n};\nconst getMRT_SelectAllHandler = ({ table }) => (event, value, forceAll) => {\n    const { options: { enableRowPinning, rowPinningDisplayMode, selectAllMode }, refs: { lastSelectedRowId }, } = table;\n    selectAllMode === 'all' || forceAll\n        ? table.toggleAllRowsSelected(value !== null && value !== void 0 ? value : event.target.checked)\n        : table.toggleAllPageRowsSelected(value !== null && value !== void 0 ? value : event.target.checked);\n    if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'))) {\n        table.setRowPinning({ bottom: [], top: [] });\n    }\n    lastSelectedRowId.current = null;\n};\n\nconst isWinCtrlMacMeta = (event) => {\n    return ((event.ctrlKey && navigator.platform.toLowerCase().includes('win')) ||\n        (event.metaKey && navigator.platform.toLowerCase().includes('mac')));\n};\nconst isCellEditable = ({ cell, table, }) => {\n    const { enableEditing } = table.options;\n    const { column: { columnDef }, row, } = cell;\n    return (!cell.getIsPlaceholder() &&\n        parseFromValuesOrFunc(enableEditing, row) &&\n        parseFromValuesOrFunc(columnDef.enableEditing, row) !== false);\n};\nconst openEditingCell = ({ cell, table, }) => {\n    const { options: { editDisplayMode }, refs: { editInputRefs }, } = table;\n    const { column } = cell;\n    if (isCellEditable({ cell, table }) && editDisplayMode === 'cell') {\n        table.setEditingCell(cell);\n        queueMicrotask(() => {\n            var _a, _b;\n            const textField = (_a = editInputRefs.current) === null || _a === void 0 ? void 0 : _a[column.id];\n            if (textField) {\n                textField.focus();\n                (_b = textField.select) === null || _b === void 0 ? void 0 : _b.call(textField);\n            }\n        });\n    }\n};\nconst cellKeyboardShortcuts = ({ cell, cellElements, cellValue, containerElement, event, header, parentElement, table, }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (!table.options.enableKeyboardShortcuts)\n        return;\n    if (event.isPropagationStopped())\n        return;\n    const currentCell = event.currentTarget;\n    if (cellValue && isWinCtrlMacMeta(event) && event.key === 'c') {\n        navigator.clipboard.writeText(cellValue);\n    }\n    else if (['Enter', ' '].includes(event.key)) {\n        if (((_a = cell === null || cell === void 0 ? void 0 : cell.column) === null || _a === void 0 ? void 0 : _a.id) === 'mrt-row-select') {\n            event.preventDefault();\n            getMRT_RowSelectionHandler({\n                row: cell.row,\n                table,\n                //@ts-expect-error\n                staticRowIndex: +event.target.getAttribute('data-index'),\n            })(event);\n        }\n        else if (((_b = header === null || header === void 0 ? void 0 : header.column) === null || _b === void 0 ? void 0 : _b.id) === 'mrt-row-select' &&\n            table.options.enableSelectAll) {\n            event.preventDefault();\n            getMRT_SelectAllHandler({\n                table,\n            })(event);\n        }\n        else if (((_c = cell === null || cell === void 0 ? void 0 : cell.column) === null || _c === void 0 ? void 0 : _c.id) === 'mrt-row-expand' &&\n            (cell.row.getCanExpand() ||\n                ((_e = (_d = table.options).renderDetailPanel) === null || _e === void 0 ? void 0 : _e.call(_d, { row: cell.row, table })))) {\n            event.preventDefault();\n            cell.row.toggleExpanded();\n        }\n        else if (((_f = header === null || header === void 0 ? void 0 : header.column) === null || _f === void 0 ? void 0 : _f.id) === 'mrt-row-expand' &&\n            table.options.enableExpandAll) {\n            event.preventDefault();\n            table.toggleAllRowsExpanded();\n        }\n        else if ((cell === null || cell === void 0 ? void 0 : cell.column.id) === 'mrt-row-pin') {\n            event.preventDefault();\n            cell.row.getIsPinned()\n                ? cell.row.pin(false)\n                : cell.row.pin(((_g = table.options.rowPinningDisplayMode) === null || _g === void 0 ? void 0 : _g.includes('bottom'))\n                    ? 'bottom'\n                    : 'top');\n        }\n        else if (header && isWinCtrlMacMeta(event)) {\n            const actionsButton = currentCell.querySelector(`button[aria-label=\"${table.options.localization.columnActions}\"]`);\n            if (actionsButton) {\n                actionsButton.click();\n            }\n        }\n        else if ((_h = header === null || header === void 0 ? void 0 : header.column) === null || _h === void 0 ? void 0 : _h.getCanSort()) {\n            event.preventDefault();\n            header.column.toggleSorting();\n        }\n    }\n    else if ([\n        'ArrowRight',\n        'ArrowLeft',\n        'ArrowUp',\n        'ArrowDown',\n        'Home',\n        'End',\n        'PageUp',\n        'PageDown',\n    ].includes(event.key)) {\n        event.preventDefault();\n        const currentRow = parentElement || currentCell.closest('tr');\n        const tableElement = containerElement || currentCell.closest('table');\n        const allCells = cellElements ||\n            Array.from((tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelectorAll('th, td')) || []);\n        const currentCellIndex = allCells.indexOf(currentCell);\n        const currentIndex = parseInt(currentCell.getAttribute('data-index') || '0');\n        let nextCell = undefined;\n        //home/end first or last cell in row\n        const findEdgeCell = (rowIndex, edge) => {\n            var _a;\n            const row = rowIndex === 'c'\n                ? currentRow\n                : rowIndex === 'f'\n                    ? tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelector('tr')\n                    : (_a = tableElement === null || tableElement === void 0 ? void 0 : tableElement.lastElementChild) === null || _a === void 0 ? void 0 : _a.lastElementChild;\n            const rowCells = Array.from((row === null || row === void 0 ? void 0 : row.children) || []);\n            const targetCell = edge === 'f' ? rowCells[0] : rowCells[rowCells.length - 1];\n            return targetCell;\n        };\n        //page up/down first or last cell in column\n        const findBottomTopCell = (columnIndex, edge) => {\n            var _a;\n            const row = edge === 't'\n                ? tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelector('tr')\n                : (_a = tableElement === null || tableElement === void 0 ? void 0 : tableElement.lastElementChild) === null || _a === void 0 ? void 0 : _a.lastElementChild;\n            const rowCells = Array.from((row === null || row === void 0 ? void 0 : row.children) || []);\n            const targetCell = rowCells[columnIndex];\n            return targetCell;\n        };\n        const findAdjacentCell = (columnIndex, searchDirection) => {\n            const searchArray = searchDirection === 'f'\n                ? allCells.slice(currentCellIndex + 1)\n                : allCells.slice(0, currentCellIndex).reverse();\n            return searchArray.find((cell) => cell.matches(`[data-index=\"${columnIndex}\"]`));\n        };\n        switch (event.key) {\n            case 'ArrowRight':\n                nextCell = findAdjacentCell(currentIndex + 1, 'f');\n                break;\n            case 'ArrowLeft':\n                nextCell = findAdjacentCell(currentIndex - 1, 'b');\n                break;\n            case 'ArrowUp':\n                nextCell = findAdjacentCell(currentIndex, 'b');\n                break;\n            case 'ArrowDown':\n                nextCell = findAdjacentCell(currentIndex, 'f');\n                break;\n            case 'Home':\n                nextCell = findEdgeCell(isWinCtrlMacMeta(event) ? 'f' : 'c', 'f');\n                break;\n            case 'End':\n                nextCell = findEdgeCell(isWinCtrlMacMeta(event) ? 'l' : 'c', 'l');\n                break;\n            case 'PageUp':\n                nextCell = findBottomTopCell(currentIndex, 't');\n                break;\n            case 'PageDown':\n                nextCell = findBottomTopCell(currentIndex, 'b');\n                break;\n        }\n        if (nextCell) {\n            nextCell.focus();\n        }\n    }\n};\n\nfunction defaultDisplayColumnProps({ header, id, size, tableOptions, }) {\n    const { defaultDisplayColumn, displayColumnDefOptions, localization } = tableOptions;\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumn), { header: header ? localization[header] : '', size }), displayColumnDefOptions === null || displayColumnDefOptions === void 0 ? void 0 : displayColumnDefOptions[id]), { id });\n}\nconst showRowPinningColumn = (tableOptions) => {\n    const { enableRowPinning, rowPinningDisplayMode } = tableOptions;\n    return !!(enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.startsWith('select')));\n};\nconst showRowDragColumn = (tableOptions) => {\n    const { enableRowDragging, enableRowOrdering } = tableOptions;\n    return !!(enableRowDragging || enableRowOrdering);\n};\nconst showRowExpandColumn = (tableOptions) => {\n    const { enableExpanding, enableGrouping, renderDetailPanel, state: { grouping }, } = tableOptions;\n    return !!(enableExpanding ||\n        (enableGrouping && (grouping === null || grouping === void 0 ? void 0 : grouping.length)) ||\n        renderDetailPanel);\n};\nconst showRowActionsColumn = (tableOptions) => {\n    const { createDisplayMode, editDisplayMode, enableEditing, enableRowActions, state: { creatingRow }, } = tableOptions;\n    return !!(enableRowActions ||\n        (creatingRow && createDisplayMode === 'row') ||\n        (enableEditing && ['modal', 'row'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : '')));\n};\nconst showRowSelectionColumn = (tableOptions) => !!tableOptions.enableRowSelection;\nconst showRowNumbersColumn = (tableOptions) => !!tableOptions.enableRowNumbers;\nconst showRowSpacerColumn = (tableOptions) => tableOptions.layoutMode === 'grid-no-grow';\nconst getLeadingDisplayColumnIds = (tableOptions) => [\n    showRowPinningColumn(tableOptions) && 'mrt-row-pin',\n    showRowDragColumn(tableOptions) && 'mrt-row-drag',\n    tableOptions.positionActionsColumn === 'first' &&\n        showRowActionsColumn(tableOptions) &&\n        'mrt-row-actions',\n    tableOptions.positionExpandColumn === 'first' &&\n        showRowExpandColumn(tableOptions) &&\n        'mrt-row-expand',\n    showRowSelectionColumn(tableOptions) && 'mrt-row-select',\n    showRowNumbersColumn(tableOptions) && 'mrt-row-numbers',\n].filter(Boolean);\nconst getTrailingDisplayColumnIds = (tableOptions) => [\n    tableOptions.positionActionsColumn === 'last' &&\n        showRowActionsColumn(tableOptions) &&\n        'mrt-row-actions',\n    tableOptions.positionExpandColumn === 'last' &&\n        showRowExpandColumn(tableOptions) &&\n        'mrt-row-expand',\n    showRowSpacerColumn(tableOptions) && 'mrt-row-spacer',\n].filter(Boolean);\nconst getDefaultColumnOrderIds = (tableOptions, reset = false) => {\n    const { state: { columnOrder: currentColumnOrderIds = [] }, } = tableOptions;\n    const leadingDisplayColIds = getLeadingDisplayColumnIds(tableOptions);\n    const trailingDisplayColIds = getTrailingDisplayColumnIds(tableOptions);\n    const defaultColumnDefIds = getAllLeafColumnDefs(tableOptions.columns).map((columnDef) => getColumnId(columnDef));\n    let allLeafColumnDefIds = reset\n        ? defaultColumnDefIds\n        : Array.from(new Set([...currentColumnOrderIds, ...defaultColumnDefIds]));\n    allLeafColumnDefIds = allLeafColumnDefIds.filter((colId) => !leadingDisplayColIds.includes(colId) &&\n        !trailingDisplayColIds.includes(colId));\n    return [\n        ...leadingDisplayColIds,\n        ...allLeafColumnDefIds,\n        ...trailingDisplayColIds,\n    ];\n};\n\nconst MRT_AggregationFns = Object.assign({}, _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.aggregationFns);\n\nconst fuzzy = (row, columnId, filterValue, addMeta) => {\n    const itemRank = (0,_tanstack_match_sorter_utils__WEBPACK_IMPORTED_MODULE_5__.rankItem)(row.getValue(columnId), filterValue, {\n        threshold: _tanstack_match_sorter_utils__WEBPACK_IMPORTED_MODULE_5__.rankings.MATCHES,\n    });\n    addMeta(itemRank);\n    return itemRank.passed;\n};\nfuzzy.autoRemove = (val) => !val;\nconst contains = (row, id, filterValue) => {\n    var _a;\n    return !!((_a = row\n        .getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase().trim().includes(filterValue.toString().toLowerCase().trim()));\n};\ncontains.autoRemove = (val) => !val;\nconst startsWith = (row, id, filterValue) => {\n    var _a;\n    return !!((_a = row\n        .getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase().trim().startsWith(filterValue.toString().toLowerCase().trim()));\n};\nstartsWith.autoRemove = (val) => !val;\nconst endsWith = (row, id, filterValue) => {\n    var _a;\n    return !!((_a = row\n        .getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase().trim().endsWith(filterValue.toString().toLowerCase().trim()));\n};\nendsWith.autoRemove = (val) => !val;\nconst equals = (row, id, filterValue) => {\n    var _a;\n    return ((_a = row.getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase().trim()) ===\n        filterValue.toString().toLowerCase().trim();\n};\nequals.autoRemove = (val) => !val;\nconst notEquals = (row, id, filterValue) => {\n    var _a;\n    return ((_a = row.getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase().trim()) !==\n        filterValue.toString().toLowerCase().trim();\n};\nnotEquals.autoRemove = (val) => !val;\nconst greaterThan = (row, id, filterValue) => {\n    var _a, _b, _c;\n    return !isNaN(+filterValue) && !isNaN(+row.getValue(id))\n        ? +((_a = row.getValue(id)) !== null && _a !== void 0 ? _a : 0) > +filterValue\n        : ((_c = ((_b = row.getValue(id)) !== null && _b !== void 0 ? _b : '')) === null || _c === void 0 ? void 0 : _c.toString().toLowerCase().trim()) > filterValue.toString().toLowerCase().trim();\n};\ngreaterThan.autoRemove = (val) => !val;\nconst greaterThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || greaterThan(row, id, filterValue);\ngreaterThanOrEqualTo.autoRemove = (val) => !val;\nconst lessThan = (row, id, filterValue) => {\n    var _a, _b, _c;\n    return !isNaN(+filterValue) && !isNaN(+row.getValue(id))\n        ? +((_a = row.getValue(id)) !== null && _a !== void 0 ? _a : 0) < +filterValue\n        : ((_c = ((_b = row.getValue(id)) !== null && _b !== void 0 ? _b : '')) === null || _c === void 0 ? void 0 : _c.toString().toLowerCase().trim()) < filterValue.toString().toLowerCase().trim();\n};\nlessThan.autoRemove = (val) => !val;\nconst lessThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || lessThan(row, id, filterValue);\nlessThanOrEqualTo.autoRemove = (val) => !val;\nconst between = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||\n    greaterThan(row, id, filterValues[0])) &&\n    ((!isNaN(+filterValues[0]) &&\n        !isNaN(+filterValues[1]) &&\n        +filterValues[0] > +filterValues[1]) ||\n        ['', undefined].includes(filterValues[1]) ||\n        lessThan(row, id, filterValues[1]));\nbetween.autoRemove = (val) => !val;\nconst betweenInclusive = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||\n    greaterThanOrEqualTo(row, id, filterValues[0])) &&\n    ((!isNaN(+filterValues[0]) &&\n        !isNaN(+filterValues[1]) &&\n        +filterValues[0] > +filterValues[1]) ||\n        ['', undefined].includes(filterValues[1]) ||\n        lessThanOrEqualTo(row, id, filterValues[1]));\nbetweenInclusive.autoRemove = (val) => !val;\nconst empty = (row, id, _filterValue) => { var _a; return !((_a = row.getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().trim()); };\nempty.autoRemove = (val) => !val;\nconst notEmpty = (row, id, _filterValue) => { var _a; return !!((_a = row.getValue(id)) === null || _a === void 0 ? void 0 : _a.toString().trim()); };\nnotEmpty.autoRemove = (val) => !val;\nconst MRT_FilterFns = Object.assign(Object.assign({}, _tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.filterFns), { between,\n    betweenInclusive,\n    contains,\n    empty,\n    endsWith,\n    equals,\n    fuzzy,\n    greaterThan,\n    greaterThanOrEqualTo,\n    lessThan,\n    lessThanOrEqualTo,\n    notEmpty,\n    notEquals,\n    startsWith });\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst MRT_EditActionButtons = (_a) => {\n    var { row, table, variant = 'icon' } = _a, rest = __rest(_a, [\"row\", \"table\", \"variant\"]);\n    const { getState, options: { icons: { CancelIcon, SaveIcon }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowCancel, onEditingRowSave, }, refs: { editInputRefs }, setCreatingRow, setEditingRow, } = table;\n    const { creatingRow, editingRow, isSaving } = getState();\n    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n    const handleCancel = () => {\n        if (isCreating) {\n            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });\n            setCreatingRow(null);\n        }\n        else if (isEditing) {\n            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });\n            setEditingRow(null);\n        }\n        row._valuesCache = {}; //reset values cache\n    };\n    const handleSubmitRow = () => {\n        var _a, _b;\n        //look for auto-filled input values\n        (_b = Object.values((_a = editInputRefs.current) !== null && _a !== void 0 ? _a : {})\n            .filter((inputRef) => { var _a, _b; return row.id === ((_b = (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a === void 0 ? void 0 : _a.split('_')) === null || _b === void 0 ? void 0 : _b[0]); })) === null || _b === void 0 ? void 0 : _b.forEach((input) => {\n            if (input.value !== undefined &&\n                Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {\n                // @ts-expect-error\n                row._valuesCache[input.name] = input.value;\n            }\n        });\n        if (isCreating)\n            onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({\n                exitCreatingMode: () => setCreatingRow(null),\n                row,\n                table,\n                values: row._valuesCache,\n            });\n        else if (isEditing) {\n            onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({\n                exitEditingMode: () => setEditingRow(null),\n                row,\n                table,\n                values: row === null || row === void 0 ? void 0 : row._valuesCache,\n            });\n        }\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { onClick: (e) => e.stopPropagation(), sx: (theme) => (Object.assign({ display: 'flex', gap: '0.75rem' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: variant === 'icon' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.cancel, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.cancel, onClick: handleCancel, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CancelIcon, {}) }) }), ((isCreating && onCreatingRowSave) ||\n                    (isEditing && onEditingRowSave)) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.save, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.save, color: \"info\", disabled: isSaving, onClick: handleSubmitRow, children: isSaving ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_CircularProgress__WEBPACK_IMPORTED_MODULE_9__[\"default\"], { size: 18 }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SaveIcon, {}) }) }))] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { onClick: handleCancel, sx: { minWidth: '100px' }, children: localization.cancel }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { disabled: isSaving, onClick: handleSubmitRow, sx: { minWidth: '100px' }, variant: \"contained\", children: [isSaving && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_CircularProgress__WEBPACK_IMPORTED_MODULE_9__[\"default\"], { color: \"inherit\", size: 18 }), localization.save] })] })) }));\n};\n\nconst parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, '_');\nconst getMRTTheme = (mrtTheme, muiTheme) => {\n    var _a;\n    const mrtThemeOverrides = parseFromValuesOrFunc(mrtTheme, muiTheme);\n    const baseBackgroundColor = (_a = mrtThemeOverrides === null || mrtThemeOverrides === void 0 ? void 0 : mrtThemeOverrides.baseBackgroundColor) !== null && _a !== void 0 ? _a : (muiTheme.palette.mode === 'dark'\n        ? (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.lighten)(muiTheme.palette.background.default, 0.05)\n        : muiTheme.palette.background.default);\n    return Object.assign({ baseBackgroundColor, cellNavigationOutlineColor: muiTheme.palette.primary.main, draggingBorderColor: muiTheme.palette.primary.main, matchHighlightColor: muiTheme.palette.mode === 'dark'\n            ? (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.darken)(muiTheme.palette.warning.dark, 0.25)\n            : (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.lighten)(muiTheme.palette.warning.light, 0.5), menuBackgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.lighten)(baseBackgroundColor, 0.07), pinnedRowBackgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(muiTheme.palette.primary.main, 0.1), selectedRowBackgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(muiTheme.palette.primary.main, 0.2) }, mrtThemeOverrides);\n};\nconst commonCellBeforeAfterStyles = {\n    content: '\"\"',\n    height: '100%',\n    left: 0,\n    position: 'absolute',\n    top: 0,\n    width: '100%',\n    zIndex: -1,\n};\nconst getCommonPinnedCellStyles = ({ column, table, theme, }) => {\n    const { baseBackgroundColor } = table.options.mrtTheme;\n    const isPinned = column === null || column === void 0 ? void 0 : column.getIsPinned();\n    return {\n        '&[data-pinned=\"true\"]': {\n            '&:before': Object.assign({ backgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)((0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.darken)(baseBackgroundColor, theme.palette.mode === 'dark' ? 0.05 : 0.01), 0.97), boxShadow: column\n                    ? isPinned === 'left' && column.getIsLastColumn(isPinned)\n                        ? `-4px 0 4px -4px ${(0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(theme.palette.grey[700], 0.5)} inset`\n                        : isPinned === 'right' && column.getIsFirstColumn(isPinned)\n                            ? `4px 0 4px -4px ${(0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(theme.palette.grey[700], 0.5)} inset`\n                            : undefined\n                    : undefined }, commonCellBeforeAfterStyles),\n        },\n    };\n};\nconst getCommonMRTCellStyles = ({ column, header, table, tableCellProps, theme, }) => {\n    var _a, _b, _c, _d, _e, _f;\n    const { getState, options: { enableColumnVirtualization, layoutMode }, } = table;\n    const { draggingColumn } = getState();\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const isColumnPinned = columnDef.columnDefType !== 'group' && column.getIsPinned();\n    const widthStyles = {\n        minWidth: `max(calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_a = header === null || header === void 0 ? void 0 : header.id) !== null && _a !== void 0 ? _a : column.id)}-size) * 1px), ${(_b = columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,\n        width: `calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_c = header === null || header === void 0 ? void 0 : header.id) !== null && _c !== void 0 ? _c : column.id)}-size) * 1px)`,\n    };\n    if (layoutMode === 'grid') {\n        widthStyles.flex = `${[0, false].includes(columnDef.grow)\n            ? 0\n            : `var(--${header ? 'header' : 'col'}-${parseCSSVarId((_d = header === null || header === void 0 ? void 0 : header.id) !== null && _d !== void 0 ? _d : column.id)}-size)`} 0 auto`;\n    }\n    else if (layoutMode === 'grid-no-grow') {\n        widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;\n    }\n    const pinnedStyles = isColumnPinned\n        ? Object.assign(Object.assign({}, getCommonPinnedCellStyles({ column, table, theme })), { left: isColumnPinned === 'left'\n                ? `${column.getStart('left')}px`\n                : undefined, opacity: 0.97, position: 'sticky', right: isColumnPinned === 'right'\n                ? `${column.getAfter('right')}px`\n                : undefined }) : {};\n    return Object.assign(Object.assign(Object.assign({ backgroundColor: 'inherit', backgroundImage: 'inherit', display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined, justifyContent: columnDefType === 'group'\n            ? 'center'\n            : (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid'))\n                ? tableCellProps.align\n                : undefined, opacity: ((_e = table.getState().draggingColumn) === null || _e === void 0 ? void 0 : _e.id) === column.id ||\n            ((_f = table.getState().hoveredColumn) === null || _f === void 0 ? void 0 : _f.id) === column.id\n            ? 0.5\n            : 1, position: 'relative', transition: enableColumnVirtualization\n            ? 'none'\n            : `padding 150ms ease-in-out`, zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id\n            ? 2\n            : columnDefType !== 'group' && isColumnPinned\n                ? 1\n                : 0, '&:focus-visible': {\n            outline: `2px solid ${table.options.mrtTheme.cellNavigationOutlineColor}`,\n            outlineOffset: '-2px',\n        } }, pinnedStyles), widthStyles), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme));\n};\nconst getCommonToolbarStyles = ({ table, }) => ({\n    alignItems: 'flex-start',\n    backgroundColor: table.options.mrtTheme.baseBackgroundColor,\n    display: 'grid',\n    flexWrap: 'wrap-reverse',\n    minHeight: '3.5rem',\n    overflow: 'hidden',\n    position: 'relative',\n    transition: 'all 150ms ease-in-out',\n    zIndex: 1,\n});\nconst flipIconStyles = (theme) => theme.direction === 'rtl'\n    ? { style: { transform: 'scaleX(-1)' } }\n    : undefined;\nconst getCommonTooltipProps = (placement) => ({\n    disableInteractive: true,\n    enterDelay: 1000,\n    enterNextDelay: 1000,\n    placement,\n});\n\nconst MRT_ActionMenuItem = (_a) => {\n    var { icon, label, onOpenSubMenu, table } = _a, rest = __rest(_a, [\"icon\", \"label\", \"onOpenSubMenu\", \"table\"]);\n    const { options: { icons: { ArrowRightIcon }, }, } = table;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__[\"default\"], Object.assign({ sx: {\n            alignItems: 'center',\n            justifyContent: 'space-between',\n            minWidth: '120px',\n            my: 0,\n            py: '6px',\n        }, tabIndex: 0 }, rest, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                    alignItems: 'center',\n                    display: 'flex',\n                }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_ListItemIcon__WEBPACK_IMPORTED_MODULE_13__[\"default\"], { children: icon }), label] }), onOpenSubMenu && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { onClick: onOpenSubMenu, onMouseEnter: onOpenSubMenu, size: \"small\", sx: { p: 0 }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ArrowRightIcon, {}) }))] })));\n};\n\nconst MRT_RowActionMenu = (_a) => {\n    var { anchorEl, handleEdit, row, setAnchorEl, staticRowIndex, table } = _a, rest = __rest(_a, [\"anchorEl\", \"handleEdit\", \"row\", \"setAnchorEl\", \"staticRowIndex\", \"table\"]);\n    const { getState, options: { editDisplayMode, enableEditing, icons: { EditIcon }, localization, mrtTheme: { menuBackgroundColor }, renderRowActionMenuItems, }, } = table;\n    const { density } = getState();\n    const menuItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const items = [];\n        const editItem = parseFromValuesOrFunc(enableEditing, row) &&\n            ['modal', 'row'].includes(editDisplayMode) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditIcon, {}), label: localization.edit, onClick: handleEdit, table: table }, 'edit'));\n        if (editItem)\n            items.push(editItem);\n        const rowActionMenuItems = renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({\n            closeMenu: () => setAnchorEl(null),\n            row,\n            staticRowIndex,\n            table,\n        });\n        if (rowActionMenuItems === null || rowActionMenuItems === void 0 ? void 0 : rowActionMenuItems.length)\n            items.push(...rowActionMenuItems);\n        return items;\n    }, [renderRowActionMenuItems, row, staticRowIndex, table]);\n    if (!menuItems.length)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Menu__WEBPACK_IMPORTED_MODULE_14__[\"default\"], Object.assign({ MenuListProps: {\n            dense: density === 'compact',\n            sx: {\n                backgroundColor: menuBackgroundColor,\n            },\n        }, anchorEl: anchorEl, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: menuItems })));\n};\n\nconst commonIconButtonStyles = {\n    '&:hover': {\n        opacity: 1,\n    },\n    height: '2rem',\n    ml: '10px',\n    opacity: 0.5,\n    transition: 'opacity 150ms',\n    width: '2rem',\n};\nconst MRT_ToggleRowActionMenuButton = (_a) => {\n    var _b;\n    var { cell, row, staticRowIndex, table } = _a, rest = __rest(_a, [\"cell\", \"row\", \"staticRowIndex\", \"table\"]);\n    const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { EditIcon, MoreHorizIcon }, localization, renderRowActionMenuItems, renderRowActions, }, setEditingRow, } = table;\n    const { creatingRow, editingRow } = getState();\n    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n    const showEditActionButtons = (isCreating && createDisplayMode === 'row') ||\n        (isEditing && editDisplayMode === 'row');\n    const [anchorEl, setAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleOpenRowActionMenu = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        setAnchorEl(event.currentTarget);\n    };\n    const handleStartEditMode = (event) => {\n        event.stopPropagation();\n        setEditingRow(Object.assign({}, row));\n        setAnchorEl(null);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: renderRowActions && !showEditActionButtons ? (renderRowActions({ cell, row, staticRowIndex, table })) : showEditActionButtons ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_EditActionButtons, { row: row, table: table })) : !renderRowActionMenuItems &&\n            parseFromValuesOrFunc(enableEditing, row) &&\n            ['modal', 'row'].includes(editDisplayMode) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { placement: \"right\", title: localization.edit, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.edit, onClick: handleStartEditMode, sx: commonIconButtonStyles }, rest, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditIcon, {}) })) })) : ((_b = renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({\n            row,\n            staticRowIndex,\n            table,\n        })) === null || _b === void 0 ? void 0 : _b.length) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps(), { title: localization.rowActions, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.rowActions, onClick: handleOpenRowActionMenu, size: \"small\", sx: commonIconButtonStyles }, rest, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MoreHorizIcon, {}) })) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_RowActionMenu, { anchorEl: anchorEl, handleEdit: handleStartEditMode, row: row, setAnchorEl: setAnchorEl, staticRowIndex: staticRowIndex, table: table })] })) : null }));\n};\n\nconst getMRT_RowActionsColumnDef = (tableOptions) => {\n    return Object.assign({ Cell: ({ cell, row, staticRowIndex, table }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToggleRowActionMenuButton, { cell: cell, row: row, staticRowIndex: staticRowIndex, table: table })) }, defaultDisplayColumnProps({\n        header: 'actions',\n        id: 'mrt-row-actions',\n        size: 70,\n        tableOptions,\n    }));\n};\n\nconst MRT_GrabHandleButton = (_a) => {\n    var _b, _c;\n    var { location, table } = _a, rest = __rest(_a, [\"location\", \"table\"]);\n    const { options: { icons: { DragHandleIcon }, localization, }, } = table;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps('top'), { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.move, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": (_c = rest.title) !== null && _c !== void 0 ? _c : localization.move, disableRipple: true, draggable: \"true\", size: \"small\" }, rest, { onClick: (e) => {\n                var _a;\n                e.stopPropagation();\n                (_a = rest === null || rest === void 0 ? void 0 : rest.onClick) === null || _a === void 0 ? void 0 : _a.call(rest, e);\n            }, sx: (theme) => (Object.assign({ '&:active': {\n                    cursor: 'grabbing',\n                }, '&:hover': {\n                    backgroundColor: 'transparent',\n                    opacity: 1,\n                }, cursor: 'grab', m: '0 -0.1rem', opacity: location === 'row' ? 1 : 0.5, p: '2px', transition: 'all 150ms ease-in-out' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), title: undefined, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DragHandleIcon, {}) })) })));\n};\n\nconst MRT_TableBodyRowGrabHandle = (_a) => {\n    var { row, rowRef, table } = _a, rest = __rest(_a, [\"row\", \"rowRef\", \"table\"]);\n    const { options: { muiRowDragHandleProps }, } = table;\n    const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiRowDragHandleProps, {\n        row,\n        table,\n    })), rest);\n    const handleDragStart = (event) => {\n        var _a;\n        (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n        try {\n            event.dataTransfer.setDragImage(rowRef.current, 0, 0);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        table.setDraggingRow(row);\n    };\n    const handleDragEnd = (event) => {\n        var _a;\n        (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n        table.setDraggingRow(null);\n        table.setHoveredRow(null);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, { location: \"row\", onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })));\n};\n\nconst getMRT_RowDragColumnDef = (tableOptions) => {\n    return Object.assign({ Cell: ({ row, rowRef, table }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyRowGrabHandle, { row: row, rowRef: rowRef, table: table })), grow: false }, defaultDisplayColumnProps({\n        header: 'move',\n        id: 'mrt-row-drag',\n        size: 60,\n        tableOptions,\n    }));\n};\n\nconst MRT_ExpandAllButton = (_a) => {\n    var _b, _c;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getCanSomeRowsExpand, getIsAllRowsExpanded, getIsSomeRowsExpanded, getState, options: { icons: { KeyboardDoubleArrowDownIcon }, localization, muiExpandAllButtonProps, renderDetailPanel, }, toggleAllRowsExpanded, } = table;\n    const { density, isLoading } = getState();\n    const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiExpandAllButtonProps, {\n        table,\n    })), rest);\n    const isAllRowsExpanded = getIsAllRowsExpanded();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps(), { title: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b !== void 0 ? _b : (isAllRowsExpanded ? localization.collapseAll : localization.expandAll), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.expandAll, disabled: isLoading || (!renderDetailPanel && !getCanSomeRowsExpand()), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded) }, iconButtonProps, { sx: (theme) => (Object.assign({ height: density === 'compact' ? '1.75rem' : '2.25rem', mt: density !== 'compact' ? '-0.25rem' : undefined, width: density === 'compact' ? '1.75rem' : '2.25rem' }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme))), title: undefined, children: (_c = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c !== void 0 ? _c : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(KeyboardDoubleArrowDownIcon, { style: {\n                        transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,\n                        transition: 'transform 150ms',\n                    } })) })) }) })));\n};\n\nconst MRT_ExpandButton = ({ row, staticRowIndex, table, }) => {\n    var _a, _b;\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    const { getState, options: { icons: { ExpandMoreIcon }, localization, muiExpandButtonProps, positionExpandColumn, renderDetailPanel, }, } = table;\n    const { density } = getState();\n    const iconButtonProps = parseFromValuesOrFunc(muiExpandButtonProps, {\n        row,\n        staticRowIndex,\n        table,\n    });\n    const canExpand = row.getCanExpand();\n    const isExpanded = row.getIsExpanded();\n    const handleToggleExpand = (event) => {\n        var _a;\n        event.stopPropagation();\n        row.toggleExpanded();\n        (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n    };\n    const detailPanel = !!(renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({ disableHoverListener: !canExpand && !detailPanel }, getCommonTooltipProps(), { title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : (isExpanded ? localization.collapse : localization.expand), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.expand, disabled: !canExpand && !detailPanel }, iconButtonProps, { onClick: handleToggleExpand, sx: (theme) => (Object.assign({ height: density === 'compact' ? '1.75rem' : '2.25rem', opacity: !canExpand && !detailPanel ? 0.3 : 1, [theme.direction === 'rtl' || positionExpandColumn === 'last'\n                        ? 'mr'\n                        : 'ml']: `${row.depth * 16}px`, width: density === 'compact' ? '1.75rem' : '2.25rem' }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme))), title: undefined, children: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _b !== void 0 ? _b : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ExpandMoreIcon, { style: {\n                        transform: `rotate(${!canExpand && !renderDetailPanel\n                            ? positionExpandColumn === 'last' ||\n                                theme.direction === 'rtl'\n                                ? 90\n                                : -90\n                            : isExpanded\n                                ? -180\n                                : 0}deg)`,\n                        transition: 'transform 150ms',\n                    } })) })) }) })));\n};\n\nconst getMRT_RowExpandColumnDef = (tableOptions) => {\n    var _a;\n    const { defaultColumn, enableExpandAll, groupedColumnMode, positionExpandColumn, renderDetailPanel, state: { grouping }, } = tableOptions;\n    const alignProps = positionExpandColumn === 'last'\n        ? {\n            align: 'right',\n        }\n        : undefined;\n    return Object.assign({ Cell: ({ cell, column, row, staticRowIndex, table }) => {\n            var _a, _b, _c;\n            const expandButtonProps = { row, staticRowIndex, table };\n            const subRowsLength = (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.length;\n            if (groupedColumnMode === 'remove' && row.groupingColumnId) {\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Stack__WEBPACK_IMPORTED_MODULE_16__[\"default\"], { alignItems: \"center\", flexDirection: \"row\", gap: \"0.25rem\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps('right'), { title: table.getColumn(row.groupingColumnId).columnDef.header, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: row.groupingValue }) })), !!subRowsLength && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { children: [\"(\", subRowsLength, \")\"] })] }));\n            }\n            else {\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (_c = (_b = column.columnDef).GroupedCell) === null || _c === void 0 ? void 0 : _c.call(_b, { cell, column, row, table })] }));\n            }\n        }, Header: enableExpandAll\n            ? ({ table }) => {\n                var _a;\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ExpandAllButton, { table: table }), groupedColumnMode === 'remove' &&\n                            ((_a = grouping === null || grouping === void 0 ? void 0 : grouping.map((groupedColumnId) => table.getColumn(groupedColumnId).columnDef.header)) === null || _a === void 0 ? void 0 : _a.join(', '))] }));\n            }\n            : undefined, muiTableBodyCellProps: alignProps, muiTableHeadCellProps: alignProps }, defaultDisplayColumnProps({\n        header: 'expand',\n        id: 'mrt-row-expand',\n        size: groupedColumnMode === 'remove'\n            ? ((_a = defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.size) !== null && _a !== void 0 ? _a : 180)\n            : renderDetailPanel\n                ? enableExpandAll\n                    ? 60\n                    : 70\n                : 100,\n        tableOptions,\n    }));\n};\n\nconst getMRT_RowNumbersColumnDef = (tableOptions) => {\n    const { localization, rowNumberDisplayMode } = tableOptions;\n    const { pagination: { pageIndex, pageSize }, } = tableOptions.state;\n    return Object.assign({ Cell: ({ row, staticRowIndex }) => {\n            var _a;\n            return ((_a = (rowNumberDisplayMode === 'static'\n                ? (staticRowIndex || 0) + (pageSize || 0) * (pageIndex || 0)\n                : row.index)) !== null && _a !== void 0 ? _a : 0) + 1;\n        }, Header: () => localization.rowNumber, grow: false }, defaultDisplayColumnProps({\n        header: 'rowNumbers',\n        id: 'mrt-row-numbers',\n        size: 50,\n        tableOptions,\n    }));\n};\n\nconst MRT_RowPinButton = (_a) => {\n    var { pinningPosition, row, table } = _a, rest = __rest(_a, [\"pinningPosition\", \"row\", \"table\"]);\n    const { options: { icons: { CloseIcon, PushPinIcon }, localization, rowPinningDisplayMode, }, } = table;\n    const isPinned = row.getIsPinned();\n    const [tooltipOpened, setTooltipOpened] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleTogglePin = (event) => {\n        setTooltipOpened(false);\n        event.stopPropagation();\n        row.pin(isPinned ? false : pinningPosition);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps(), { open: tooltipOpened, title: isPinned ? localization.unpin : localization.pin, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.pin, onBlur: () => setTooltipOpened(false), onClick: handleTogglePin, onFocus: () => setTooltipOpened(true), onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: \"small\" }, rest, { sx: (theme) => (Object.assign({ height: '24px', width: '24px' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: isPinned ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CloseIcon, {})) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, { fontSize: \"small\", style: {\n                    transform: `rotate(${rowPinningDisplayMode === 'sticky'\n                        ? 135\n                        : pinningPosition === 'top'\n                            ? 180\n                            : 0}deg)`,\n                } })) })) })));\n};\n\nconst MRT_TableBodyRowPinButton = (_a) => {\n    var { row, table } = _a, rest = __rest(_a, [\"row\", \"table\"]);\n    const { getState, options: { enableRowPinning, rowPinningDisplayMode }, } = table;\n    const { density } = getState();\n    const canPin = parseFromValuesOrFunc(enableRowPinning, row);\n    if (!canPin)\n        return null;\n    const rowPinButtonProps = Object.assign({ row,\n        table }, rest);\n    if (rowPinningDisplayMode === 'top-and-bottom' && !row.getIsPinned()) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                display: 'flex',\n                flexDirection: density === 'compact' ? 'row' : 'column',\n            }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_RowPinButton, Object.assign({ pinningPosition: \"top\" }, rowPinButtonProps)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_RowPinButton, Object.assign({ pinningPosition: \"bottom\" }, rowPinButtonProps))] }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_RowPinButton, Object.assign({ pinningPosition: rowPinningDisplayMode === 'bottom' ? 'bottom' : 'top' }, rowPinButtonProps)));\n};\n\nconst getMRT_RowPinningColumnDef = (tableOptions) => {\n    return Object.assign({ Cell: ({ row, table }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyRowPinButton, { row: row, table: table })), grow: false }, defaultDisplayColumnProps({\n        header: 'pin',\n        id: 'mrt-row-pin',\n        size: 60,\n        tableOptions,\n    }));\n};\n\nconst MRT_SelectCheckbox = (_a) => {\n    var _b;\n    var { row, staticRowIndex, table } = _a, rest = __rest(_a, [\"row\", \"staticRowIndex\", \"table\"]);\n    const { getState, options: { enableMultiRowSelection, localization, muiSelectAllCheckboxProps, muiSelectCheckboxProps, selectAllMode, }, } = table;\n    const { density, isLoading } = getState();\n    const selectAll = !row;\n    const allRowsSelected = selectAll\n        ? selectAllMode === 'page'\n            ? table.getIsAllPageRowsSelected()\n            : table.getIsAllRowsSelected()\n        : undefined;\n    const isChecked = selectAll\n        ? allRowsSelected\n        : getIsRowSelected({ row, table });\n    const checkboxProps = Object.assign(Object.assign({}, (selectAll\n        ? parseFromValuesOrFunc(muiSelectAllCheckboxProps, { table })\n        : parseFromValuesOrFunc(muiSelectCheckboxProps, {\n            row,\n            staticRowIndex,\n            table,\n        }))), rest);\n    const onSelectionChange = row\n        ? getMRT_RowSelectionHandler({\n            row,\n            staticRowIndex,\n            table,\n        })\n        : undefined;\n    const onSelectAllChange = getMRT_SelectAllHandler({ table });\n    const commonProps = Object.assign(Object.assign({ 'aria-label': selectAll\n            ? localization.toggleSelectAll\n            : localization.toggleSelectRow, checked: isChecked, disabled: isLoading || (row && !row.getCanSelect()) || (row === null || row === void 0 ? void 0 : row.id) === 'mrt-row-create', inputProps: {\n            'aria-label': selectAll\n                ? localization.toggleSelectAll\n                : localization.toggleSelectRow,\n        }, onChange: (event) => {\n            event.stopPropagation();\n            selectAll ? onSelectAllChange(event) : onSelectionChange(event);\n        }, size: (density === 'compact' ? 'small' : 'medium') }, checkboxProps), { onClick: (e) => {\n            var _a;\n            e.stopPropagation();\n            (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n        }, sx: (theme) => (Object.assign({ height: density === 'compact' ? '1.75rem' : '2.5rem', m: density !== 'compact' ? '-0.4rem' : undefined, width: density === 'compact' ? '1.75rem' : '2.5rem', zIndex: 0 }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme))), title: undefined });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps(), { title: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : (selectAll\n            ? localization.toggleSelectAll\n            : localization.toggleSelectRow), children: enableMultiRowSelection === false ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Radio__WEBPACK_IMPORTED_MODULE_17__[\"default\"], Object.assign({}, commonProps))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Checkbox__WEBPACK_IMPORTED_MODULE_18__[\"default\"], Object.assign({ indeterminate: !isChecked && selectAll\n                ? table.getIsSomeRowsSelected()\n                : (row === null || row === void 0 ? void 0 : row.getIsSomeSelected()) && row.getCanSelectSubRows() }, commonProps))) })));\n};\n\nconst getMRT_RowSelectColumnDef = (tableOptions) => {\n    const { enableMultiRowSelection, enableSelectAll } = tableOptions;\n    return Object.assign({ Cell: ({ row, staticRowIndex, table }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_SelectCheckbox, { row: row, staticRowIndex: staticRowIndex, table: table })), Header: enableSelectAll && enableMultiRowSelection\n            ? ({ table }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_SelectCheckbox, { table: table })\n            : undefined, grow: false }, defaultDisplayColumnProps({\n        header: 'select',\n        id: 'mrt-row-select',\n        size: enableSelectAll ? 60 : 70,\n        tableOptions,\n    }));\n};\n\nconst MRT_Default_Icons = {\n    ArrowDownwardIcon: _mui_icons_material_ArrowDownward__WEBPACK_IMPORTED_MODULE_19__[\"default\"],\n    ArrowRightIcon: _mui_icons_material_ArrowRight__WEBPACK_IMPORTED_MODULE_20__[\"default\"],\n    CancelIcon: _mui_icons_material_Cancel__WEBPACK_IMPORTED_MODULE_21__[\"default\"],\n    ChevronLeftIcon: _mui_icons_material_ChevronLeft__WEBPACK_IMPORTED_MODULE_22__[\"default\"],\n    ChevronRightIcon: _mui_icons_material_ChevronRight__WEBPACK_IMPORTED_MODULE_23__[\"default\"],\n    ClearAllIcon: _mui_icons_material_ClearAll__WEBPACK_IMPORTED_MODULE_24__[\"default\"],\n    CloseIcon: _mui_icons_material_Close__WEBPACK_IMPORTED_MODULE_25__[\"default\"],\n    ContentCopy: _mui_icons_material_ContentCopy__WEBPACK_IMPORTED_MODULE_26__[\"default\"],\n    DensityLargeIcon: _mui_icons_material_DensityLarge__WEBPACK_IMPORTED_MODULE_27__[\"default\"],\n    DensityMediumIcon: _mui_icons_material_DensityMedium__WEBPACK_IMPORTED_MODULE_28__[\"default\"],\n    DensitySmallIcon: _mui_icons_material_DensitySmall__WEBPACK_IMPORTED_MODULE_29__[\"default\"],\n    DragHandleIcon: _mui_icons_material_DragHandle__WEBPACK_IMPORTED_MODULE_30__[\"default\"],\n    DynamicFeedIcon: _mui_icons_material_DynamicFeed__WEBPACK_IMPORTED_MODULE_31__[\"default\"],\n    EditIcon: _mui_icons_material_Edit__WEBPACK_IMPORTED_MODULE_32__[\"default\"],\n    ExpandMoreIcon: _mui_icons_material_ExpandMore__WEBPACK_IMPORTED_MODULE_33__[\"default\"],\n    FilterAltIcon: _mui_icons_material_FilterAlt__WEBPACK_IMPORTED_MODULE_34__[\"default\"],\n    FilterListIcon: _mui_icons_material_FilterList__WEBPACK_IMPORTED_MODULE_35__[\"default\"],\n    FilterListOffIcon: _mui_icons_material_FilterListOff__WEBPACK_IMPORTED_MODULE_36__[\"default\"],\n    FirstPageIcon: _mui_icons_material_FirstPage__WEBPACK_IMPORTED_MODULE_37__[\"default\"],\n    FullscreenExitIcon: _mui_icons_material_FullscreenExit__WEBPACK_IMPORTED_MODULE_38__[\"default\"],\n    FullscreenIcon: _mui_icons_material_Fullscreen__WEBPACK_IMPORTED_MODULE_39__[\"default\"],\n    KeyboardDoubleArrowDownIcon: _mui_icons_material_KeyboardDoubleArrowDown__WEBPACK_IMPORTED_MODULE_40__[\"default\"],\n    LastPageIcon: _mui_icons_material_LastPage__WEBPACK_IMPORTED_MODULE_41__[\"default\"],\n    MoreHorizIcon: _mui_icons_material_MoreHoriz__WEBPACK_IMPORTED_MODULE_42__[\"default\"],\n    MoreVertIcon: _mui_icons_material_MoreVert__WEBPACK_IMPORTED_MODULE_43__[\"default\"],\n    PushPinIcon: _mui_icons_material_PushPin__WEBPACK_IMPORTED_MODULE_44__[\"default\"],\n    RestartAltIcon: _mui_icons_material_RestartAlt__WEBPACK_IMPORTED_MODULE_45__[\"default\"],\n    SaveIcon: _mui_icons_material_Save__WEBPACK_IMPORTED_MODULE_46__[\"default\"],\n    SearchIcon: _mui_icons_material_Search__WEBPACK_IMPORTED_MODULE_47__[\"default\"],\n    SearchOffIcon: _mui_icons_material_SearchOff__WEBPACK_IMPORTED_MODULE_48__[\"default\"],\n    SortIcon: _mui_icons_material_Sort__WEBPACK_IMPORTED_MODULE_49__[\"default\"],\n    SyncAltIcon: _mui_icons_material_SyncAlt__WEBPACK_IMPORTED_MODULE_50__[\"default\"],\n    ViewColumnIcon: _mui_icons_material_ViewColumn__WEBPACK_IMPORTED_MODULE_51__[\"default\"],\n    VisibilityOffIcon: _mui_icons_material_VisibilityOff__WEBPACK_IMPORTED_MODULE_52__[\"default\"],\n};\n\nconst MRT_Localization_EN = {\n    language: 'en',\n    actions: 'Actions',\n    and: 'and',\n    cancel: 'Cancel',\n    changeFilterMode: 'Change filter mode',\n    changeSearchMode: 'Change search mode',\n    clearFilter: 'Clear filter',\n    clearSearch: 'Clear search',\n    clearSelection: 'Clear selection',\n    clearSort: 'Clear sort',\n    clickToCopy: 'Click to copy',\n    copy: 'Copy',\n    collapse: 'Collapse',\n    collapseAll: 'Collapse all',\n    columnActions: 'Column Actions',\n    copiedToClipboard: 'Copied to clipboard',\n    dropToGroupBy: 'Drop to group by {column}',\n    edit: 'Edit',\n    expand: 'Expand',\n    expandAll: 'Expand all',\n    filterArrIncludes: 'Includes',\n    filterArrIncludesAll: 'Includes all',\n    filterArrIncludesSome: 'Includes',\n    filterBetween: 'Between',\n    filterBetweenInclusive: 'Between Inclusive',\n    filterByColumn: 'Filter by {column}',\n    filterContains: 'Contains',\n    filterEmpty: 'Empty',\n    filterEndsWith: 'Ends With',\n    filterEquals: 'Equals',\n    filterEqualsString: 'Equals',\n    filterFuzzy: 'Fuzzy',\n    filterGreaterThan: 'Greater Than',\n    filterGreaterThanOrEqualTo: 'Greater Than Or Equal To',\n    filterInNumberRange: 'Between',\n    filterIncludesString: 'Contains',\n    filterIncludesStringSensitive: 'Contains',\n    filterLessThan: 'Less Than',\n    filterLessThanOrEqualTo: 'Less Than Or Equal To',\n    filterMode: 'Filter Mode: {filterType}',\n    filterNotEmpty: 'Not Empty',\n    filterNotEquals: 'Not Equals',\n    filterStartsWith: 'Starts With',\n    filterWeakEquals: 'Equals',\n    filteringByColumn: 'Filtering by {column} - {filterType} {filterValue}',\n    goToFirstPage: 'Go to first page',\n    goToLastPage: 'Go to last page',\n    goToNextPage: 'Go to next page',\n    goToPreviousPage: 'Go to previous page',\n    grab: 'Grab',\n    groupByColumn: 'Group by {column}',\n    groupedBy: 'Grouped by ',\n    hideAll: 'Hide all',\n    hideColumn: 'Hide {column} column',\n    max: 'Max',\n    min: 'Min',\n    move: 'Move',\n    noRecordsToDisplay: 'No records to display',\n    noResultsFound: 'No results found',\n    of: 'of',\n    or: 'or',\n    pin: 'Pin',\n    pinToLeft: 'Pin to left',\n    pinToRight: 'Pin to right',\n    resetColumnSize: 'Reset column size',\n    resetOrder: 'Reset order',\n    rowActions: 'Row Actions',\n    rowNumber: '#',\n    rowNumbers: 'Row Numbers',\n    rowsPerPage: 'Rows per page',\n    save: 'Save',\n    search: 'Search',\n    selectedCountOfRowCountRowsSelected: '{selectedCount} of {rowCount} row(s) selected',\n    select: 'Select',\n    showAll: 'Show all',\n    showAllColumns: 'Show all columns',\n    showHideColumns: 'Show/Hide columns',\n    showHideFilters: 'Show/Hide filters',\n    showHideSearch: 'Show/Hide search',\n    sortByColumnAsc: 'Sort by {column} ascending',\n    sortByColumnDesc: 'Sort by {column} descending',\n    sortedByColumnAsc: 'Sorted by {column} ascending',\n    sortedByColumnDesc: 'Sorted by {column} descending',\n    thenBy: ', then by ',\n    toggleDensity: 'Toggle density',\n    toggleFullScreen: 'Toggle full screen',\n    toggleSelectAll: 'Toggle select all',\n    toggleSelectRow: 'Toggle select row',\n    toggleVisibility: 'Toggle visibility',\n    ungroupByColumn: 'Ungroup by {column}',\n    unpin: 'Unpin',\n    unpinAll: 'Unpin all',\n};\n\nconst MRT_DefaultColumn = {\n    filterVariant: 'text',\n    maxSize: 1000,\n    minSize: 40,\n    size: 180,\n};\nconst MRT_DefaultDisplayColumn = {\n    columnDefType: 'display',\n    enableClickToCopy: false,\n    enableColumnActions: false,\n    enableColumnDragging: false,\n    enableColumnFilter: false,\n    enableColumnOrdering: false,\n    enableEditing: false,\n    enableGlobalFilter: false,\n    enableGrouping: false,\n    enableHiding: false,\n    enableResizing: false,\n    enableSorting: false,\n};\nconst useMRT_TableOptions = (_a) => {\n    var _b;\n    var { aggregationFns, autoResetExpanded = false, columnFilterDisplayMode = 'subheader', columnResizeDirection, columnResizeMode = 'onChange', createDisplayMode = 'modal', defaultColumn, defaultDisplayColumn, editDisplayMode = 'modal', enableBatchRowSelection = true, enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnPinning = false, enableColumnResizing = false, enableColumnVirtualization, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFacetedValues = false, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableKeyboardShortcuts = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enableRowPinning = false, enableRowSelection = false, enableRowVirtualization, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns, icons, id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), layoutMode, localization, manualFiltering, manualGrouping, manualPagination, manualSorting, mrtTheme, paginationDisplayMode = 'default', positionActionsColumn = 'first', positionCreatingRow = 'top', positionExpandColumn = 'first', positionGlobalFilter = 'right', positionPagination = 'bottom', positionToolbarAlertBanner = 'top', positionToolbarDropZone = 'top', rowNumberDisplayMode = 'static', rowPinningDisplayMode = 'sticky', selectAllMode = 'page', sortingFns } = _a, rest = __rest(_a, [\"aggregationFns\", \"autoResetExpanded\", \"columnFilterDisplayMode\", \"columnResizeDirection\", \"columnResizeMode\", \"createDisplayMode\", \"defaultColumn\", \"defaultDisplayColumn\", \"editDisplayMode\", \"enableBatchRowSelection\", \"enableBottomToolbar\", \"enableColumnActions\", \"enableColumnFilters\", \"enableColumnOrdering\", \"enableColumnPinning\", \"enableColumnResizing\", \"enableColumnVirtualization\", \"enableDensityToggle\", \"enableExpandAll\", \"enableExpanding\", \"enableFacetedValues\", \"enableFilterMatchHighlighting\", \"enableFilters\", \"enableFullScreenToggle\", \"enableGlobalFilter\", \"enableGlobalFilterRankedResults\", \"enableGrouping\", \"enableHiding\", \"enableKeyboardShortcuts\", \"enableMultiRowSelection\", \"enableMultiSort\", \"enablePagination\", \"enableRowPinning\", \"enableRowSelection\", \"enableRowVirtualization\", \"enableSelectAll\", \"enableSorting\", \"enableStickyHeader\", \"enableTableFooter\", \"enableTableHead\", \"enableToolbarInternalActions\", \"enableTopToolbar\", \"filterFns\", \"icons\", \"id\", \"layoutMode\", \"localization\", \"manualFiltering\", \"manualGrouping\", \"manualPagination\", \"manualSorting\", \"mrtTheme\", \"paginationDisplayMode\", \"positionActionsColumn\", \"positionCreatingRow\", \"positionExpandColumn\", \"positionGlobalFilter\", \"positionPagination\", \"positionToolbarAlertBanner\", \"positionToolbarDropZone\", \"rowNumberDisplayMode\", \"rowPinningDisplayMode\", \"selectAllMode\", \"sortingFns\"]);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    icons = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_Default_Icons), icons)), [icons]);\n    localization = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_Localization_EN), localization)), [localization]);\n    mrtTheme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => getMRTTheme(mrtTheme, theme), [mrtTheme, theme]);\n    aggregationFns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns)), []);\n    filterFns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_FilterFns), filterFns)), []);\n    sortingFns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_SortingFns), sortingFns)), []);\n    defaultColumn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn)), [defaultColumn]);\n    defaultDisplayColumn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn)), [defaultDisplayColumn]);\n    //cannot be changed after initialization\n    [enableColumnVirtualization, enableRowVirtualization] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [enableColumnVirtualization, enableRowVirtualization], []);\n    if (!columnResizeDirection) {\n        columnResizeDirection = theme.direction || 'ltr';\n    }\n    layoutMode =\n        layoutMode || (enableColumnResizing ? 'grid-no-grow' : 'semantic');\n    if (layoutMode === 'semantic' &&\n        (enableRowVirtualization || enableColumnVirtualization)) {\n        layoutMode = 'grid';\n    }\n    if (enableRowVirtualization) {\n        enableStickyHeader = true;\n    }\n    if (enablePagination === false && manualPagination === undefined) {\n        manualPagination = true;\n    }\n    if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {\n        manualFiltering = true;\n        manualGrouping = true;\n        manualPagination = true;\n        manualSorting = true;\n    }\n    return Object.assign({ aggregationFns,\n        autoResetExpanded,\n        columnFilterDisplayMode,\n        columnResizeDirection,\n        columnResizeMode,\n        createDisplayMode,\n        defaultColumn,\n        defaultDisplayColumn,\n        editDisplayMode,\n        enableBatchRowSelection,\n        enableBottomToolbar,\n        enableColumnActions,\n        enableColumnFilters,\n        enableColumnOrdering,\n        enableColumnPinning,\n        enableColumnResizing,\n        enableColumnVirtualization,\n        enableDensityToggle,\n        enableExpandAll,\n        enableExpanding,\n        enableFacetedValues,\n        enableFilterMatchHighlighting,\n        enableFilters,\n        enableFullScreenToggle,\n        enableGlobalFilter,\n        enableGlobalFilterRankedResults,\n        enableGrouping,\n        enableHiding,\n        enableKeyboardShortcuts,\n        enableMultiRowSelection,\n        enableMultiSort,\n        enablePagination,\n        enableRowPinning,\n        enableRowSelection,\n        enableRowVirtualization,\n        enableSelectAll,\n        enableSorting,\n        enableStickyHeader,\n        enableTableFooter,\n        enableTableHead,\n        enableToolbarInternalActions,\n        enableTopToolbar,\n        filterFns, getCoreRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getCoreRowModel)(), getExpandedRowModel: enableExpanding || enableGrouping ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getExpandedRowModel)() : undefined, getFacetedMinMaxValues: enableFacetedValues\n            ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getFacetedMinMaxValues)()\n            : undefined, getFacetedRowModel: enableFacetedValues ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getFacetedRowModel)() : undefined, getFacetedUniqueValues: enableFacetedValues\n            ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getFacetedUniqueValues)()\n            : undefined, getFilteredRowModel: (enableColumnFilters || enableGlobalFilter || enableFilters) &&\n            !manualFiltering\n            ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getFilteredRowModel)()\n            : undefined, getGroupedRowModel: enableGrouping && !manualGrouping ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getGroupedRowModel)() : undefined, getPaginationRowModel: enablePagination && !manualPagination\n            ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getPaginationRowModel)()\n            : undefined, getSortedRowModel: enableSorting && !manualSorting ? (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_4__.getSortedRowModel)() : undefined, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows, icons,\n        id,\n        layoutMode,\n        localization,\n        manualFiltering,\n        manualGrouping,\n        manualPagination,\n        manualSorting,\n        mrtTheme,\n        paginationDisplayMode,\n        positionActionsColumn,\n        positionCreatingRow,\n        positionExpandColumn,\n        positionGlobalFilter,\n        positionPagination,\n        positionToolbarAlertBanner,\n        positionToolbarDropZone,\n        rowNumberDisplayMode,\n        rowPinningDisplayMode,\n        selectAllMode,\n        sortingFns }, rest);\n};\n\nconst blankColProps = {\n    children: null,\n    sx: {\n        minWidth: 0,\n        p: 0,\n        width: 0,\n    },\n};\nconst getMRT_RowSpacerColumnDef = (tableOptions) => {\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumnProps({\n        id: 'mrt-row-spacer',\n        size: 0,\n        tableOptions,\n    })), { grow: true }), MRT_DefaultDisplayColumn), { muiTableBodyCellProps: blankColProps, muiTableFooterCellProps: blankColProps, muiTableHeadCellProps: blankColProps });\n};\n\nconst useMRT_Effects = (table) => {\n    const { getIsSomeRowsPinned, getPrePaginationRowModel, getState, options: { enablePagination, enableRowPinning, rowCount }, } = table;\n    const { columnOrder, density, globalFilter, isFullScreen, isLoading, pagination, showSkeletons, sorting, } = getState();\n    const totalColumnCount = table.options.columns.length;\n    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;\n    const rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(() => ({}), {})[1];\n    const initialBodyHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const previousTop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (typeof window !== 'undefined') {\n            initialBodyHeight.current = document.body.style.height;\n        }\n    }, []);\n    //hide scrollbars when table is in full screen mode, preserve body scroll position after full screen exit\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (typeof window !== 'undefined') {\n            if (isFullScreen) {\n                previousTop.current = document.body.getBoundingClientRect().top; //save scroll position\n                document.body.style.height = '100dvh'; //hide page scrollbars when table is in full screen mode\n            }\n            else {\n                document.body.style.height = initialBodyHeight.current;\n                if (!previousTop.current)\n                    return;\n                //restore scroll position\n                window.scrollTo({\n                    behavior: 'instant',\n                    top: -1 * previousTop.current,\n                });\n            }\n        }\n    }, [isFullScreen]);\n    //recalculate column order when columns change or features are toggled on/off\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (totalColumnCount !== columnOrder.length) {\n            table.setColumnOrder(getDefaultColumnOrderIds(table.options));\n        }\n    }, [totalColumnCount]);\n    //if page index is out of bounds, set it to the last page\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!enablePagination || isLoading || showSkeletons)\n            return;\n        const { pageIndex, pageSize } = pagination;\n        const totalPages = totalRowCount > 0 ? Math.ceil(totalRowCount / pageSize) : 1;\n        const isOutOfBounds = pageIndex < 0 || pageIndex >= totalPages;\n        if (isOutOfBounds) {\n            table.setPageIndex(totalPages - 1);\n        }\n    }, [totalRowCount, enablePagination, isLoading, showSkeletons]);\n    //turn off sort when global filter is looking for ranked results\n    const appliedSort = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(sorting);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (sorting.length) {\n            appliedSort.current = sorting;\n        }\n    }, [sorting]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!getCanRankRows(table))\n            return;\n        if (globalFilter) {\n            table.setSorting([]);\n        }\n        else {\n            table.setSorting(() => appliedSort.current || []);\n        }\n    }, [globalFilter]);\n    //fix pinned row top style when density changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (enableRowPinning && getIsSomeRowsPinned()) {\n            setTimeout(() => {\n                rerender();\n            }, 150);\n        }\n    }, [density]);\n};\n\n/**\n * The MRT hook that wraps the TanStack useReactTable hook and adds additional functionality\n * @param definedTableOptions - table options with proper defaults set\n * @returns the MRT table instance\n */\nconst useMRT_TableInstance = (definedTableOptions) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;\n    const lastSelectedRowId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const actionCellRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const bottomToolbarRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const editInputRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const filterInputRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const searchInputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tableContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tableHeadCellRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const tablePaperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const topToolbarRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tableHeadRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tableFooterRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    //transform initial state with proper column order\n    const initialState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a, _b, _c;\n        const initState = (_a = definedTableOptions.initialState) !== null && _a !== void 0 ? _a : {};\n        initState.columnOrder =\n            (_b = initState.columnOrder) !== null && _b !== void 0 ? _b : getDefaultColumnOrderIds(Object.assign(Object.assign({}, definedTableOptions), { state: Object.assign(Object.assign({}, definedTableOptions.initialState), definedTableOptions.state) }));\n        initState.globalFilterFn = (_c = definedTableOptions.globalFilterFn) !== null && _c !== void 0 ? _c : 'fuzzy';\n        return initState;\n    }, []);\n    definedTableOptions.initialState = initialState;\n    const [actionCell, setActionCell] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_a = initialState.actionCell) !== null && _a !== void 0 ? _a : null);\n    const [creatingRow, _setCreatingRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_b = initialState.creatingRow) !== null && _b !== void 0 ? _b : null);\n    const [columnFilterFns, setColumnFilterFns] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => Object.assign({}, ...getAllLeafColumnDefs(definedTableOptions.columns).map((col) => {\n        var _a, _b, _c, _d;\n        return ({\n            [getColumnId(col)]: col.filterFn instanceof Function\n                ? ((_a = col.filterFn.name) !== null && _a !== void 0 ? _a : 'custom')\n                : ((_d = (_b = col.filterFn) !== null && _b !== void 0 ? _b : (_c = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c === void 0 ? void 0 : _c[getColumnId(col)]) !== null && _d !== void 0 ? _d : getDefaultColumnFilterFn(col)),\n        });\n    })));\n    const [columnOrder, onColumnOrderChange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_c = initialState.columnOrder) !== null && _c !== void 0 ? _c : []);\n    const [columnSizingInfo, onColumnSizingInfoChange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_d = initialState.columnSizingInfo) !== null && _d !== void 0 ? _d : {});\n    const [density, setDensity] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_e = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _e !== void 0 ? _e : 'comfortable');\n    const [draggingColumn, setDraggingColumn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_f = initialState.draggingColumn) !== null && _f !== void 0 ? _f : null);\n    const [draggingRow, setDraggingRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_g = initialState.draggingRow) !== null && _g !== void 0 ? _g : null);\n    const [editingCell, setEditingCell] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_h = initialState.editingCell) !== null && _h !== void 0 ? _h : null);\n    const [editingRow, setEditingRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_j = initialState.editingRow) !== null && _j !== void 0 ? _j : null);\n    const [globalFilterFn, setGlobalFilterFn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_k = initialState.globalFilterFn) !== null && _k !== void 0 ? _k : 'fuzzy');\n    const [grouping, onGroupingChange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_l = initialState.grouping) !== null && _l !== void 0 ? _l : []);\n    const [hoveredColumn, setHoveredColumn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_m = initialState.hoveredColumn) !== null && _m !== void 0 ? _m : null);\n    const [hoveredRow, setHoveredRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_o = initialState.hoveredRow) !== null && _o !== void 0 ? _o : null);\n    const [isFullScreen, setIsFullScreen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_p = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _p !== void 0 ? _p : false);\n    const [pagination, onPaginationChange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_q = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) !== null && _q !== void 0 ? _q : { pageIndex: 0, pageSize: 10 });\n    const [showAlertBanner, setShowAlertBanner] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showAlertBanner) !== null && _r !== void 0 ? _r : false);\n    const [showColumnFilters, setShowColumnFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _s !== void 0 ? _s : false);\n    const [showGlobalFilter, setShowGlobalFilter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_t = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _t !== void 0 ? _t : false);\n    const [showToolbarDropZone, setShowToolbarDropZone] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((_u = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _u !== void 0 ? _u : false);\n    definedTableOptions.state = Object.assign({ actionCell,\n        columnFilterFns,\n        columnOrder,\n        columnSizingInfo,\n        creatingRow,\n        density,\n        draggingColumn,\n        draggingRow,\n        editingCell,\n        editingRow,\n        globalFilterFn,\n        grouping,\n        hoveredColumn,\n        hoveredRow,\n        isFullScreen,\n        pagination,\n        showAlertBanner,\n        showColumnFilters,\n        showGlobalFilter,\n        showToolbarDropZone }, definedTableOptions.state);\n    //The table options now include all state needed to help determine column visibility and order logic\n    const statefulTableOptions = definedTableOptions;\n    //don't recompute columnDefs while resizing column or dragging column/row\n    const columnDefsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    statefulTableOptions.columns =\n        statefulTableOptions.state.columnSizingInfo.isResizingColumn ||\n            statefulTableOptions.state.draggingColumn ||\n            statefulTableOptions.state.draggingRow\n            ? columnDefsRef.current\n            : prepareColumns({\n                columnDefs: [\n                    ...[\n                        showRowPinningColumn(statefulTableOptions) &&\n                            getMRT_RowPinningColumnDef(statefulTableOptions),\n                        showRowDragColumn(statefulTableOptions) &&\n                            getMRT_RowDragColumnDef(statefulTableOptions),\n                        showRowActionsColumn(statefulTableOptions) &&\n                            getMRT_RowActionsColumnDef(statefulTableOptions),\n                        showRowExpandColumn(statefulTableOptions) &&\n                            getMRT_RowExpandColumnDef(statefulTableOptions),\n                        showRowSelectionColumn(statefulTableOptions) &&\n                            getMRT_RowSelectColumnDef(statefulTableOptions),\n                        showRowNumbersColumn(statefulTableOptions) &&\n                            getMRT_RowNumbersColumnDef(statefulTableOptions),\n                    ].filter(Boolean),\n                    ...statefulTableOptions.columns,\n                    ...[\n                        showRowSpacerColumn(statefulTableOptions) &&\n                            getMRT_RowSpacerColumnDef(statefulTableOptions),\n                    ].filter(Boolean),\n                ],\n                tableOptions: statefulTableOptions,\n            });\n    columnDefsRef.current = statefulTableOptions.columns;\n    //if loading, generate blank rows to show skeleton loaders\n    statefulTableOptions.data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (statefulTableOptions.state.isLoading ||\n        statefulTableOptions.state.showSkeletons) &&\n        !statefulTableOptions.data.length\n        ? [\n            ...Array(Math.min(statefulTableOptions.state.pagination.pageSize, 20)).fill(null),\n        ].map(() => Object.assign({}, ...getAllLeafColumnDefs(statefulTableOptions.columns).map((col) => ({\n            [getColumnId(col)]: null,\n        }))))\n        : statefulTableOptions.data, [\n        statefulTableOptions.data,\n        statefulTableOptions.state.isLoading,\n        statefulTableOptions.state.showSkeletons,\n    ]);\n    //@ts-expect-error\n    const table = (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_3__.useReactTable)(Object.assign(Object.assign({ onColumnOrderChange,\n        onColumnSizingInfoChange,\n        onGroupingChange,\n        onPaginationChange }, statefulTableOptions), { globalFilterFn: (_v = statefulTableOptions.filterFns) === null || _v === void 0 ? void 0 : _v[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : 'fuzzy'] }));\n    table.refs = {\n        actionCellRef,\n        bottomToolbarRef,\n        editInputRefs,\n        filterInputRefs,\n        lastSelectedRowId,\n        searchInputRef,\n        tableContainerRef,\n        tableFooterRef,\n        tableHeadCellRefs,\n        tableHeadRef,\n        tablePaperRef,\n        topToolbarRef,\n    };\n    table.setActionCell =\n        (_w = statefulTableOptions.onActionCellChange) !== null && _w !== void 0 ? _w : setActionCell;\n    table.setCreatingRow = (row) => {\n        var _a, _b;\n        let _row = row;\n        if (row === true) {\n            _row = createRow(table);\n        }\n        (_b = (_a = statefulTableOptions === null || statefulTableOptions === void 0 ? void 0 : statefulTableOptions.onCreatingRowChange) === null || _a === void 0 ? void 0 : _a.call(statefulTableOptions, _row)) !== null && _b !== void 0 ? _b : _setCreatingRow(_row);\n    };\n    table.setColumnFilterFns =\n        (_x = statefulTableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;\n    table.setDensity = (_y = statefulTableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;\n    table.setDraggingColumn =\n        (_z = statefulTableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;\n    table.setDraggingRow =\n        (_0 = statefulTableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;\n    table.setEditingCell =\n        (_1 = statefulTableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;\n    table.setEditingRow =\n        (_2 = statefulTableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;\n    table.setGlobalFilterFn =\n        (_3 = statefulTableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;\n    table.setHoveredColumn =\n        (_4 = statefulTableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;\n    table.setHoveredRow =\n        (_5 = statefulTableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;\n    table.setIsFullScreen =\n        (_6 = statefulTableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;\n    table.setShowAlertBanner =\n        (_7 = statefulTableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;\n    table.setShowColumnFilters =\n        (_8 = statefulTableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;\n    table.setShowGlobalFilter =\n        (_9 = statefulTableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;\n    table.setShowToolbarDropZone =\n        (_10 = statefulTableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;\n    useMRT_Effects(table);\n    return table;\n};\n\nconst useMaterialReactTable = (tableOptions) => useMRT_TableInstance(useMRT_TableOptions(tableOptions));\n\n/**\n * When scroll, the `draggingRow` or `draggingColumn` can be removed from document because of virtualization,\n * then, the `dragEnd` event on `MRT_TableBodyRowGrabHandle` or `MRT_TableHeadCellGrabHandle` will not fire.\n * We should keep the `draggingRow` or `draggingColumn` in `getVirtualItems()` to avoid this thing.\n */\nconst extraIndexRangeExtractor = (range, draggingIndex) => {\n    const newIndexes = (0,_tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_53__.defaultRangeExtractor)(range);\n    if (draggingIndex === undefined)\n        return newIndexes;\n    if (draggingIndex >= 0 &&\n        draggingIndex < Math.max(range.startIndex - range.overscan, 0)) {\n        newIndexes.unshift(draggingIndex);\n    }\n    if (draggingIndex >= 0 && draggingIndex > range.endIndex + range.overscan) {\n        newIndexes.push(draggingIndex);\n    }\n    return newIndexes;\n};\n\nconst useMRT_ColumnVirtualizer = (table) => {\n    var _a, _b, _c, _d;\n    const { getState, options: { columnVirtualizerInstanceRef, columnVirtualizerOptions, enableColumnPinning, enableColumnVirtualization, }, refs: { tableContainerRef }, } = table;\n    const { columnPinning, columnVisibility, draggingColumn } = getState();\n    if (!enableColumnVirtualization)\n        return undefined;\n    const columnVirtualizerProps = parseFromValuesOrFunc(columnVirtualizerOptions, {\n        table,\n    });\n    const visibleColumns = table.getVisibleLeafColumns();\n    const [leftPinnedIndexes, rightPinnedIndexes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => enableColumnPinning\n        ? [\n            table.getLeftVisibleLeafColumns().map((c) => c.getPinnedIndex()),\n            table\n                .getRightVisibleLeafColumns()\n                .map((column) => visibleColumns.length - column.getPinnedIndex() - 1)\n                .sort((a, b) => a - b),\n        ]\n        : [[], []], [columnPinning, columnVisibility, enableColumnPinning]);\n    const numPinnedLeft = leftPinnedIndexes.length;\n    const numPinnedRight = rightPinnedIndexes.length;\n    const draggingColumnIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)\n        ? visibleColumns.findIndex((c) => c.id === (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id))\n        : undefined, [draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id]);\n    const columnVirtualizer = (0,_tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_54__.useVirtualizer)(Object.assign({ count: visibleColumns.length, estimateSize: (index) => visibleColumns[index].getSize(), getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((range) => {\n            const newIndexes = extraIndexRangeExtractor(range, draggingColumnIndex);\n            if (!numPinnedLeft && !numPinnedRight) {\n                return newIndexes;\n            }\n            return [\n                ...new Set([\n                    ...leftPinnedIndexes,\n                    ...newIndexes,\n                    ...rightPinnedIndexes,\n                ]),\n            ];\n        }, [leftPinnedIndexes, rightPinnedIndexes, draggingColumnIndex]) }, columnVirtualizerProps));\n    const virtualColumns = columnVirtualizer.getVirtualItems();\n    columnVirtualizer.virtualColumns = virtualColumns;\n    const numColumns = virtualColumns.length;\n    if (numColumns) {\n        const totalSize = columnVirtualizer.getTotalSize();\n        const leftNonPinnedStart = ((_a = virtualColumns[numPinnedLeft]) === null || _a === void 0 ? void 0 : _a.start) || 0;\n        const leftNonPinnedEnd = ((_b = virtualColumns[leftPinnedIndexes.length - 1]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n        const rightNonPinnedStart = ((_c = virtualColumns[numColumns - numPinnedRight]) === null || _c === void 0 ? void 0 : _c.start) || 0;\n        const rightNonPinnedEnd = ((_d = virtualColumns[numColumns - numPinnedRight - 1]) === null || _d === void 0 ? void 0 : _d.end) || 0;\n        columnVirtualizer.virtualPaddingLeft =\n            leftNonPinnedStart - leftNonPinnedEnd;\n        columnVirtualizer.virtualPaddingRight =\n            totalSize -\n                rightNonPinnedEnd -\n                (numPinnedRight ? totalSize - rightNonPinnedStart : 0);\n    }\n    if (columnVirtualizerInstanceRef) {\n        //@ts-expect-error\n        columnVirtualizerInstanceRef.current = columnVirtualizer;\n    }\n    return columnVirtualizer;\n};\n\nconst useMRT_RowVirtualizer = (table, rows) => {\n    const { getRowModel, getState, options: { enableRowVirtualization, renderDetailPanel, rowVirtualizerInstanceRef, rowVirtualizerOptions, }, refs: { tableContainerRef }, } = table;\n    const { density, draggingRow, expanded } = getState();\n    if (!enableRowVirtualization)\n        return undefined;\n    const rowVirtualizerProps = parseFromValuesOrFunc(rowVirtualizerOptions, {\n        table,\n    });\n    const realRows = rows !== null && rows !== void 0 ? rows : getRowModel().rows;\n    /**\n     * when filtering, should find the correct index in filtered rows\n     */\n    const draggingRowIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id)\n        ? realRows.findIndex((r) => r.id === (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id))\n        : undefined, [realRows, draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id]);\n    const rowCount = realRows.length;\n    const normalRowHeight = density === 'compact' ? 37 : density === 'comfortable' ? 58 : 73;\n    const rowVirtualizer = (0,_tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_54__.useVirtualizer)(Object.assign({ count: renderDetailPanel ? rowCount * 2 : rowCount, estimateSize: (index) => renderDetailPanel && index % 2 === 1\n            ? expanded === true\n                ? 100\n                : 0\n            : normalRowHeight, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== 'undefined' &&\n            navigator.userAgent.indexOf('Firefox') === -1\n            ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height\n            : undefined, overscan: 4, rangeExtractor: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((range) => {\n            return extraIndexRangeExtractor(range, draggingRowIndex);\n        }, [draggingRowIndex]) }, rowVirtualizerProps));\n    rowVirtualizer.virtualRows = rowVirtualizer.getVirtualItems();\n    if (rowVirtualizerInstanceRef) {\n        //@ts-expect-error\n        rowVirtualizerInstanceRef.current = rowVirtualizer;\n    }\n    return rowVirtualizer;\n};\n\nconst useMRT_Rows = (table) => {\n    const { getRowModel, getState, options: { data, enableGlobalFilterRankedResults, positionCreatingRow }, } = table;\n    const { creatingRow, expanded, globalFilter, pagination, rowPinning, sorting, } = getState();\n    const rows = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => getMRT_Rows(table), [\n        creatingRow,\n        data,\n        enableGlobalFilterRankedResults,\n        expanded,\n        getRowModel().rows,\n        globalFilter,\n        pagination.pageIndex,\n        pagination.pageSize,\n        positionCreatingRow,\n        rowPinning,\n        sorting,\n    ]);\n    return rows;\n};\n\nconst allowedTypes = ['string', 'number'];\nconst MRT_TableBodyCellValue = ({ cell, rowRef, staticColumnIndex, staticRowIndex, table, }) => {\n    var _a, _b, _c;\n    const { getState, options: { enableFilterMatchHighlighting, mrtTheme: { matchHighlightColor }, }, } = table;\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const { globalFilter, globalFilterFn } = getState();\n    const filterValue = column.getFilterValue();\n    let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell\n        ? columnDef.AggregatedCell({\n            cell,\n            column,\n            row,\n            table,\n            staticColumnIndex,\n            staticRowIndex,\n        })\n        : row.getIsGrouped() && !cell.getIsGrouped()\n            ? null\n            : cell.getIsGrouped() && columnDef.GroupedCell\n                ? columnDef.GroupedCell({\n                    cell,\n                    column,\n                    row,\n                    table,\n                    staticColumnIndex,\n                    staticRowIndex,\n                })\n                : undefined;\n    const isGroupedValue = renderedCellValue !== undefined;\n    if (!isGroupedValue) {\n        renderedCellValue = cell.renderValue();\n    }\n    if (enableFilterMatchHighlighting &&\n        columnDef.enableFilterMatchHighlighting !== false &&\n        String(renderedCellValue) &&\n        allowedTypes.includes(typeof renderedCellValue) &&\n        ((filterValue &&\n            allowedTypes.includes(typeof filterValue) &&\n            ['autocomplete', 'text'].includes(columnDef.filterVariant)) ||\n            (globalFilter &&\n                allowedTypes.includes(typeof globalFilter) &&\n                column.getCanGlobalFilter()))) {\n        const chunks = highlight_words__WEBPACK_IMPORTED_MODULE_2__[\"default\"] === null || highlight_words__WEBPACK_IMPORTED_MODULE_2__[\"default\"] === void 0 ? void 0 : (0,highlight_words__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            matchExactly: (filterValue ? columnDef._filterFn : globalFilterFn) !== 'fuzzy',\n            query: ((_a = filterValue !== null && filterValue !== void 0 ? filterValue : globalFilter) !== null && _a !== void 0 ? _a : '').toString(),\n            text: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString(),\n        });\n        if ((chunks === null || chunks === void 0 ? void 0 : chunks.length) > 1 || ((_b = chunks === null || chunks === void 0 ? void 0 : chunks[0]) === null || _b === void 0 ? void 0 : _b.match)) {\n            renderedCellValue = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { \"aria-label\": renderedCellValue, role: \"note\", children: (_c = chunks === null || chunks === void 0 ? void 0 : chunks.map(({ key, match, text }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { \"aria-hidden\": \"true\", component: \"span\", sx: match\n                        ? {\n                            backgroundColor: matchHighlightColor,\n                            borderRadius: '2px',\n                            color: (theme) => theme.palette.mode === 'dark'\n                                ? theme.palette.common.white\n                                : theme.palette.common.black,\n                            padding: '2px 1px',\n                        }\n                        : undefined, children: text }, key)))) !== null && _c !== void 0 ? _c : renderedCellValue }));\n        }\n    }\n    if (columnDef.Cell && !isGroupedValue) {\n        renderedCellValue = columnDef.Cell({\n            cell,\n            column,\n            renderedCellValue,\n            row,\n            rowRef,\n            staticColumnIndex,\n            staticRowIndex,\n            table,\n        });\n    }\n    return renderedCellValue;\n};\n\nconst MRT_CopyButton = (_a) => {\n    var _b;\n    var { cell, table } = _a, rest = __rest(_a, [\"cell\", \"table\"]);\n    const { options: { localization, muiCopyButtonProps }, } = table;\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const [copied, setCopied] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleCopy = (event, text) => {\n        event.stopPropagation();\n        navigator.clipboard.writeText(text);\n        setCopied(true);\n        setTimeout(() => setCopied(false), 4000);\n    };\n    const buttonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCopyButtonProps, {\n        cell,\n        column,\n        row,\n        table,\n    })), parseFromValuesOrFunc(columnDef.muiCopyButtonProps, {\n        cell,\n        column,\n        row,\n        table,\n    })), rest);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps('top'), { title: (_b = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _b !== void 0 ? _b : (copied ? localization.copiedToClipboard : localization.clickToCopy), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], Object.assign({ onClick: (e) => handleCopy(e, cell.getValue()), size: \"small\", type: \"button\", variant: \"text\" }, buttonProps, { sx: (theme) => (Object.assign({ backgroundColor: 'transparent', border: 'none', color: 'inherit', cursor: 'copy', fontFamily: 'inherit', fontSize: 'inherit', letterSpacing: 'inherit', m: '-0.25rem', minWidth: 'unset', py: 0, textAlign: 'inherit', textTransform: 'inherit' }, parseFromValuesOrFunc(buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx, theme))), title: undefined })) })));\n};\n\nconst MRT_EditCellTextField = (_a) => {\n    var _b, _c;\n    var { cell, table } = _a, rest = __rest(_a, [\"cell\", \"table\"]);\n    const { getState, options: { createDisplayMode, editDisplayMode, muiEditTextFieldProps }, refs: { editInputRefs }, setCreatingRow, setEditingCell, setEditingRow, } = table;\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const { creatingRow, editingRow } = getState();\n    const { editSelectOptions, editVariant } = columnDef;\n    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => cell.getValue());\n    const [completesComposition, setCompletesComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditTextFieldProps, {\n        cell,\n        column,\n        row,\n        table,\n    })), parseFromValuesOrFunc(columnDef.muiEditTextFieldProps, {\n        cell,\n        column,\n        row,\n        table,\n    })), rest);\n    const selectOptions = parseFromValuesOrFunc(editSelectOptions, {\n        cell,\n        column,\n        row,\n        table,\n    });\n    const isSelectEdit = editVariant === 'select' || (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.select);\n    const saveInputValueToRowCache = (newValue) => {\n        //@ts-expect-error\n        row._valuesCache[column.id] = newValue;\n        if (isCreating) {\n            setCreatingRow(row);\n        }\n        else if (isEditing) {\n            setEditingRow(row);\n        }\n    };\n    const handleChange = (event) => {\n        var _a;\n        (_a = textFieldProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n        setValue(event.target.value);\n        if (isSelectEdit) {\n            saveInputValueToRowCache(event.target.value);\n        }\n    };\n    const handleBlur = (event) => {\n        var _a;\n        (_a = textFieldProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n        saveInputValueToRowCache(value);\n        setEditingCell(null);\n    };\n    const handleEnterKeyDown = (event) => {\n        var _a, _b, _c;\n        (_a = textFieldProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n        if (event.key === 'Enter' && !event.shiftKey && completesComposition) {\n            (_c = (_b = editInputRefs.current) === null || _b === void 0 ? void 0 : _b[column.id]) === null || _c === void 0 ? void 0 : _c.blur();\n        }\n    };\n    if (columnDef.Edit) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: (_b = columnDef.Edit) === null || _b === void 0 ? void 0 : _b.call(columnDef, { cell, column, row, table }) });\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TextField__WEBPACK_IMPORTED_MODULE_55__[\"default\"], Object.assign({ disabled: parseFromValuesOrFunc(columnDef.enableEditing, row) === false, fullWidth: true, inputRef: (inputRef) => {\n            if (inputRef) {\n                editInputRefs.current[column.id] = isSelectEdit\n                    ? inputRef.node\n                    : inputRef;\n                if (textFieldProps.inputRef) {\n                    textFieldProps.inputRef = inputRef;\n                }\n            }\n        }, label: ['custom', 'modal'].includes((isCreating ? createDisplayMode : editDisplayMode))\n            ? columnDef.header\n            : undefined, margin: \"none\", name: column.id, placeholder: !['custom', 'modal'].includes((isCreating ? createDisplayMode : editDisplayMode))\n            ? columnDef.header\n            : undefined, select: isSelectEdit, size: \"small\", value: value !== null && value !== void 0 ? value : '', variant: \"standard\" }, textFieldProps, { InputProps: Object.assign(Object.assign(Object.assign({}, (textFieldProps.variant !== 'outlined'\n            ? { disableUnderline: editDisplayMode === 'table' }\n            : {})), textFieldProps.InputProps), { sx: (theme) => {\n                var _a;\n                return (Object.assign({ mb: 0 }, parseFromValuesOrFunc((_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a === void 0 ? void 0 : _a.sx, theme)));\n            } }), SelectProps: Object.assign({ MenuProps: { disableScrollLock: true } }, textFieldProps.SelectProps), inputProps: Object.assign({ autoComplete: 'off' }, textFieldProps.inputProps), onBlur: handleBlur, onChange: handleChange, onClick: (e) => {\n            var _a;\n            e.stopPropagation();\n            (_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, e);\n        }, onKeyDown: handleEnterKeyDown, onCompositionStart: () => setCompletesComposition(false), onCompositionEnd: () => setCompletesComposition(true), children: (_c = textFieldProps.children) !== null && _c !== void 0 ? _c : selectOptions === null || selectOptions === void 0 ? void 0 : selectOptions.map((option) => {\n            const { label, value } = getValueAndLabel(option);\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__[\"default\"], { sx: {\n                    alignItems: 'center',\n                    display: 'flex',\n                    gap: '0.5rem',\n                    m: 0,\n                }, value: value, children: label }, value));\n        }) })));\n};\n\nconst MRT_TableBodyCell = (_a) => {\n    var _b, _c, _d, _e, _f;\n    var { cell, numRows, rowRef, staticColumnIndex, staticRowIndex, table } = _a, rest = __rest(_a, [\"cell\", \"numRows\", \"rowRef\", \"staticColumnIndex\", \"staticRowIndex\", \"table\"]);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    const { getState, options: { columnResizeDirection, columnResizeMode, createDisplayMode, editDisplayMode, enableCellActions, enableClickToCopy, enableColumnOrdering, enableColumnPinning, enableGrouping, enableKeyboardShortcuts, layoutMode, mrtTheme: { draggingBorderColor }, muiSkeletonProps, muiTableBodyCellProps, }, setHoveredColumn, } = table;\n    const { actionCell, columnSizingInfo, creatingRow, density, draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, isLoading, showSkeletons, } = getState();\n    const { column, row } = cell;\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const args = { cell, column, row, table };\n    const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableBodyCellProps, args)), rest);\n    const skeletonProps = parseFromValuesOrFunc(muiSkeletonProps, {\n        cell,\n        column,\n        row,\n        table,\n    });\n    const [skeletonWidth, setSkeletonWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(100);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if ((!isLoading && !showSkeletons) || skeletonWidth !== 100)\n            return;\n        const size = column.getSize();\n        setSkeletonWidth(columnDefType === 'display'\n            ? size / 2\n            : Math.round(Math.random() * (size - size / 3) + size / 3));\n    }, [isLoading, showSkeletons]);\n    const draggingBorders = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;\n        const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;\n        const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;\n        const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;\n        const isFirstColumn = column.getIsFirstColumn();\n        const isLastColumn = column.getIsLastColumn();\n        const isLastRow = numRows && staticRowIndex === numRows - 1;\n        const isResizingColumn = columnSizingInfo.isResizingColumn === column.id;\n        const showResizeBorder = isResizingColumn && columnResizeMode === 'onChange';\n        const borderStyle = showResizeBorder\n            ? `2px solid ${draggingBorderColor} !important`\n            : isDraggingColumn || isDraggingRow\n                ? `1px dashed ${theme.palette.grey[500]} !important`\n                : isHoveredColumn || isHoveredRow || isResizingColumn\n                    ? `2px dashed ${draggingBorderColor} !important`\n                    : undefined;\n        if (showResizeBorder) {\n            return columnResizeDirection === 'ltr'\n                ? { borderRight: borderStyle }\n                : { borderLeft: borderStyle };\n        }\n        return borderStyle\n            ? {\n                borderBottom: isDraggingRow || isHoveredRow || (isLastRow && !isResizingColumn)\n                    ? borderStyle\n                    : undefined,\n                borderLeft: isDraggingColumn ||\n                    isHoveredColumn ||\n                    ((isDraggingRow || isHoveredRow) && isFirstColumn)\n                    ? borderStyle\n                    : undefined,\n                borderRight: isDraggingColumn ||\n                    isHoveredColumn ||\n                    ((isDraggingRow || isHoveredRow) && isLastColumn)\n                    ? borderStyle\n                    : undefined,\n                borderTop: isDraggingRow || isHoveredRow ? borderStyle : undefined,\n            }\n            : undefined;\n    }, [\n        columnSizingInfo.isResizingColumn,\n        draggingColumn,\n        draggingRow,\n        hoveredColumn,\n        hoveredRow,\n        staticRowIndex,\n    ]);\n    const isColumnPinned = enableColumnPinning &&\n        columnDef.columnDefType !== 'group' &&\n        column.getIsPinned();\n    const isEditable = isCellEditable({ cell, table });\n    const isEditing = isEditable &&\n        !['custom', 'modal'].includes(editDisplayMode) &&\n        (editDisplayMode === 'table' ||\n            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id ||\n            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) &&\n        !row.getIsGrouped();\n    const isCreating = isEditable && createDisplayMode === 'row' && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;\n    const showClickToCopyButton = (parseFromValuesOrFunc(enableClickToCopy, cell) === true ||\n        parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === true) &&\n        !['context-menu', false].includes(\n        // @ts-expect-error\n        parseFromValuesOrFunc(columnDef.enableClickToCopy, cell));\n    const isRightClickable = parseFromValuesOrFunc(enableCellActions, cell);\n    const cellValueProps = {\n        cell,\n        table,\n        staticColumnIndex,\n        staticRowIndex,\n    };\n    const handleDoubleClick = (event) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);\n        openEditingCell({ cell, table });\n    };\n    const handleDragEnter = (e) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);\n        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n            setHoveredColumn(null);\n        }\n        if (enableColumnOrdering && draggingColumn) {\n            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);\n        }\n    };\n    const handleDragOver = (e) => {\n        if (columnDef.enableColumnOrdering !== false) {\n            e.preventDefault();\n        }\n    };\n    const handleContextMenu = (e) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onContextMenu) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);\n        if (isRightClickable) {\n            e.preventDefault();\n            table.setActionCell(cell);\n            table.refs.actionCellRef.current = e.currentTarget;\n        }\n    };\n    const handleKeyDown = (event) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);\n        cellKeyboardShortcuts({\n            cell,\n            cellValue: cell.getValue(),\n            event,\n            table,\n        });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableCell__WEBPACK_IMPORTED_MODULE_56__[\"default\"], Object.assign({ align: theme.direction === 'rtl' ? 'right' : 'left', \"data-index\": staticColumnIndex, \"data-pinned\": !!isColumnPinned || undefined, tabIndex: enableKeyboardShortcuts ? 0 : undefined }, tableCellProps, { onKeyDown: handleKeyDown, onContextMenu: handleContextMenu, onDoubleClick: handleDoubleClick, onDragEnter: handleDragEnter, onDragOver: handleDragOver, sx: (theme) => (Object.assign(Object.assign({ '&:hover': {\n                outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id ||\n                    (editDisplayMode === 'cell' && isEditable) ||\n                    (editDisplayMode === 'table' && (isCreating || isEditing))\n                    ? `1px solid ${theme.palette.grey[500]}`\n                    : undefined,\n                textOverflow: 'clip',\n            }, alignItems: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'center' : undefined, cursor: isRightClickable\n                ? 'context-menu'\n                : isEditable && editDisplayMode === 'cell'\n                    ? 'pointer'\n                    : 'inherit', outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id\n                ? `1px solid ${theme.palette.grey[500]}`\n                : undefined, outlineOffset: '-1px', overflow: 'hidden', p: density === 'compact'\n                ? columnDefType === 'display'\n                    ? '0 0.5rem'\n                    : '0.5rem'\n                : density === 'comfortable'\n                    ? columnDefType === 'display'\n                        ? '0.5rem 0.75rem'\n                        : '1rem'\n                    : columnDefType === 'display'\n                        ? '1rem 1.25rem'\n                        : '1.5rem', textOverflow: columnDefType !== 'display' ? 'ellipsis' : undefined, whiteSpace: row.getIsPinned() || density === 'compact' ? 'nowrap' : 'normal' }, getCommonMRTCellStyles({\n            column,\n            table,\n            tableCellProps,\n            theme,\n        })), draggingBorders)), children: (_b = tableCellProps.children) !== null && _b !== void 0 ? _b : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [cell.getIsPlaceholder() ? (((_d = (_c = columnDef.PlaceholderCell) === null || _c === void 0 ? void 0 : _c.call(columnDef, { cell, column, row, table })) !== null && _d !== void 0 ? _d : null)) : showSkeletons !== false && (isLoading || showSkeletons) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Skeleton__WEBPACK_IMPORTED_MODULE_57__[\"default\"], Object.assign({ animation: \"wave\", height: 20, width: skeletonWidth }, skeletonProps))) : columnDefType === 'display' &&\n                    (['mrt-row-expand', 'mrt-row-numbers', 'mrt-row-select'].includes(column.id) ||\n                        !row.getIsGrouped()) ? ((_e = columnDef.Cell) === null || _e === void 0 ? void 0 : _e.call(columnDef, {\n                    cell,\n                    column,\n                    renderedCellValue: cell.renderValue(),\n                    row,\n                    rowRef,\n                    staticColumnIndex,\n                    staticRowIndex,\n                    table,\n                })) : isCreating || isEditing ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_EditCellTextField, { cell: cell, table: table })) : showClickToCopyButton && columnDef.enableClickToCopy !== false ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_CopyButton, { cell: cell, table: table, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyCellValue, Object.assign({}, cellValueProps))), cell.getIsGrouped() && !columnDef.GroupedCell && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\" (\", (_f = row.subRows) === null || _f === void 0 ? void 0 : _f.length, \")\"] }))] })) })));\n};\nconst Memo_MRT_TableBodyCell = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);\n\nconst MRT_TableDetailPanel = (_a) => {\n    var { parentRowRef, row, rowVirtualizer, staticRowIndex, table, virtualRow } = _a, rest = __rest(_a, [\"parentRowRef\", \"row\", \"rowVirtualizer\", \"staticRowIndex\", \"table\", \"virtualRow\"]);\n    const { getState, getVisibleLeafColumns, options: { layoutMode, mrtTheme: { baseBackgroundColor }, muiDetailPanelProps, muiTableBodyRowProps, renderDetailPanel, }, } = table;\n    const { isLoading } = getState();\n    const tableRowProps = parseFromValuesOrFunc(muiTableBodyRowProps, {\n        isDetailPanel: true,\n        row,\n        staticRowIndex,\n        table,\n    });\n    const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiDetailPanelProps, {\n        row,\n        table,\n    })), rest);\n    const DetailPanel = !isLoading && (renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableRow__WEBPACK_IMPORTED_MODULE_58__[\"default\"], Object.assign({ className: \"Mui-TableBodyCell-DetailPanel\", \"data-index\": renderDetailPanel ? staticRowIndex * 2 + 1 : staticRowIndex, ref: (node) => {\n            var _a;\n            if (node) {\n                (_a = rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement) === null || _a === void 0 ? void 0 : _a.call(rowVirtualizer, node);\n            }\n        } }, tableRowProps, { sx: (theme) => {\n            var _a, _b;\n            return (Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined, position: virtualRow ? 'absolute' : undefined, top: virtualRow\n                    ? `${(_b = (_a = parentRowRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height}px`\n                    : undefined, transform: virtualRow\n                    ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)`\n                    : undefined, width: '100%' }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)));\n        }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableCell__WEBPACK_IMPORTED_MODULE_56__[\"default\"], Object.assign({ className: \"Mui-TableBodyCell-DetailPanel\", colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => (Object.assign({ backgroundColor: virtualRow ? baseBackgroundColor : undefined, borderBottom: !row.getIsExpanded() ? 'none' : undefined, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined, py: !!DetailPanel && row.getIsExpanded() ? '1rem' : 0, transition: !virtualRow ? 'all 150ms ease-in-out' : undefined, width: `100%` }, parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme))), children: virtualRow ? (row.getIsExpanded() && DetailPanel) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Collapse__WEBPACK_IMPORTED_MODULE_59__[\"default\"], { in: row.getIsExpanded(), mountOnEnter: true, unmountOnExit: true, children: DetailPanel })) })) })));\n};\n\nconst MRT_TableBodyRow = (_a) => {\n    var _b, _c, _d, _f;\n    var { columnVirtualizer, numRows, pinnedRowIds, row, rowVirtualizer, staticRowIndex, table, virtualRow } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"numRows\", \"pinnedRowIds\", \"row\", \"rowVirtualizer\", \"staticRowIndex\", \"table\", \"virtualRow\"]);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    const { getState, options: { enableRowOrdering, enableRowPinning, enableStickyFooter, enableStickyHeader, layoutMode, memoMode, mrtTheme: { baseBackgroundColor, pinnedRowBackgroundColor, selectedRowBackgroundColor, }, muiTableBodyRowProps, renderDetailPanel, rowPinningDisplayMode, }, refs: { tableFooterRef, tableHeadRef }, setHoveredRow, } = table;\n    const { density, draggingColumn, draggingRow, editingCell, editingRow, hoveredRow, isFullScreen, rowPinning, } = getState();\n    const visibleCells = row.getVisibleCells();\n    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};\n    const isRowSelected = getIsRowSelected({ row, table });\n    const isRowPinned = enableRowPinning && row.getIsPinned();\n    const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;\n    const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;\n    const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyRowProps, {\n        row,\n        staticRowIndex,\n        table,\n    })), rest);\n    const [bottomPinnedIndex, topPinnedIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!enableRowPinning ||\n            !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) ||\n            !pinnedRowIds ||\n            !row.getIsPinned())\n            return [];\n        return [\n            [...pinnedRowIds].reverse().indexOf(row.id),\n            pinnedRowIds.indexOf(row.id),\n        ];\n    }, [pinnedRowIds, rowPinning]);\n    const tableHeadHeight = ((enableStickyHeader || isFullScreen) &&\n        ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight)) ||\n        0;\n    const tableFooterHeight = (enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight)) || 0;\n    const sx = parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme);\n    const defaultRowHeight = density === 'compact' ? 37 : density === 'comfortable' ? 53 : 69;\n    const customRowHeight = \n    // @ts-expect-error\n    parseInt((_f = (_d = tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style) === null || _d === void 0 ? void 0 : _d.height) !== null && _f !== void 0 ? _f : sx === null || sx === void 0 ? void 0 : sx.height, 10) || undefined;\n    const rowHeight = customRowHeight || defaultRowHeight;\n    const handleDragEnter = (_e) => {\n        if (enableRowOrdering && draggingRow) {\n            setHoveredRow(row);\n        }\n    };\n    const handleDragOver = (e) => {\n        e.preventDefault();\n    };\n    const rowRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const cellHighlightColor = isRowSelected\n        ? selectedRowBackgroundColor\n        : isRowPinned\n            ? pinnedRowBackgroundColor\n            : undefined;\n    const cellHighlightColorHover = (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false\n        ? isRowSelected\n            ? cellHighlightColor\n            : theme.palette.mode === 'dark'\n                ? `${(0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.lighten)(baseBackgroundColor, 0.3)}`\n                : `${(0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.darken)(baseBackgroundColor, 0.3)}`\n        : undefined;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_TableRow__WEBPACK_IMPORTED_MODULE_58__[\"default\"], Object.assign({ \"data-index\": renderDetailPanel ? staticRowIndex * 2 : staticRowIndex, \"data-pinned\": !!isRowPinned || undefined, \"data-selected\": isRowSelected || undefined, onDragEnter: handleDragEnter, onDragOver: handleDragOver, ref: (node) => {\n                    if (node) {\n                        rowRef.current = node;\n                        rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement(node);\n                    }\n                }, selected: isRowSelected }, tableRowProps, { style: Object.assign({ transform: virtualRow\n                        ? `translateY(${virtualRow.start}px)`\n                        : undefined }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style), sx: (theme) => (Object.assign({ '&:hover td:after': cellHighlightColorHover\n                        ? Object.assign({ backgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(cellHighlightColorHover, 0.3) }, commonCellBeforeAfterStyles) : undefined, backgroundColor: `${baseBackgroundColor} !important`, bottom: !virtualRow && bottomPinnedIndex !== undefined && isRowPinned\n                        ? `${bottomPinnedIndex * rowHeight +\n                            (enableStickyFooter ? tableFooterHeight - 1 : 0)}px`\n                        : undefined, boxSizing: 'border-box', display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined, opacity: isRowPinned ? 0.97 : isDraggingRow || isHoveredRow ? 0.5 : 1, position: virtualRow\n                        ? 'absolute'\n                        : (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && isRowPinned\n                            ? 'sticky'\n                            : 'relative', td: Object.assign({}, getCommonPinnedCellStyles({ table, theme })), 'td:after': cellHighlightColor\n                        ? Object.assign({ backgroundColor: cellHighlightColor }, commonCellBeforeAfterStyles) : undefined, top: virtualRow\n                        ? 0\n                        : topPinnedIndex !== undefined && isRowPinned\n                            ? `${topPinnedIndex * rowHeight +\n                                (enableStickyHeader || isFullScreen ? tableHeadHeight - 1 : 0)}px`\n                            : undefined, transition: virtualRow ? 'none' : 'all 150ms ease-in-out', width: '100%', zIndex: (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && isRowPinned ? 2 : 0 }, sx)), children: [virtualPaddingLeft ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"td\", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : visibleCells).map((cellOrVirtualCell, staticColumnIndex) => {\n                        let cell = cellOrVirtualCell;\n                        if (columnVirtualizer) {\n                            staticColumnIndex = cellOrVirtualCell.index;\n                            cell = visibleCells[staticColumnIndex];\n                        }\n                        const props = {\n                            cell,\n                            numRows,\n                            rowRef,\n                            staticColumnIndex,\n                            staticRowIndex,\n                            table,\n                        };\n                        const key = `${cell.id}-${staticRowIndex}`;\n                        return cell ? (memoMode === 'cells' &&\n                            cell.column.columnDef.columnDefType === 'data' &&\n                            !draggingColumn &&\n                            !draggingRow &&\n                            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id &&\n                            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Memo_MRT_TableBodyCell, Object.assign({}, props), key)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyCell, Object.assign({}, props), key))) : null;\n                    }), virtualPaddingRight ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"td\", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })), renderDetailPanel && !row.getIsGrouped() && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableDetailPanel, { parentRowRef: rowRef, row: row, rowVirtualizer: rowVirtualizer, staticRowIndex: staticRowIndex, table: table, virtualRow: virtualRow }))] }));\n};\nconst Memo_MRT_TableBodyRow = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.staticRowIndex === next.staticRowIndex);\n\nconst MRT_TableBody = (_a) => {\n    var _b, _c, _d, _e, _f, _g;\n    var { columnVirtualizer, table } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"table\"]);\n    const { getBottomRows, getIsSomeRowsPinned, getRowModel, getState, getTopRows, options: { enableStickyFooter, enableStickyHeader, layoutMode, localization, memoMode, muiTableBodyProps, renderDetailPanel, renderEmptyRowsFallback, rowPinningDisplayMode, }, refs: { tableFooterRef, tableHeadRef, tablePaperRef }, } = table;\n    const { columnFilters, globalFilter, isFullScreen, rowPinning } = getState();\n    const tableBodyProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyProps, { table })), rest);\n    const tableHeadHeight = ((enableStickyHeader || isFullScreen) &&\n        ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight)) ||\n        0;\n    const tableFooterHeight = (enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight)) || 0;\n    const pinnedRowIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a, _b;\n        if (!((_a = rowPinning.bottom) === null || _a === void 0 ? void 0 : _a.length) && !((_b = rowPinning.top) === null || _b === void 0 ? void 0 : _b.length))\n            return [];\n        return getRowModel()\n            .rows.filter((row) => row.getIsPinned())\n            .map((r) => r.id);\n    }, [rowPinning, getRowModel().rows]);\n    const rows = useMRT_Rows(table);\n    const rowVirtualizer = useMRT_RowVirtualizer(table, rows);\n    const { virtualRows } = rowVirtualizer !== null && rowVirtualizer !== void 0 ? rowVirtualizer : {};\n    const commonRowProps = {\n        columnVirtualizer,\n        numRows: rows.length,\n        table,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [!(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&\n                getIsSomeRowsPinned('top') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableBody__WEBPACK_IMPORTED_MODULE_60__[\"default\"], Object.assign({}, tableBodyProps, { sx: (theme) => (Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, position: 'sticky', top: tableHeadHeight - 1, zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme))), children: getTopRows().map((row, staticRowIndex) => {\n                    const props = Object.assign(Object.assign({}, commonRowProps), { row,\n                        staticRowIndex });\n                    return memoMode === 'rows' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyRow, Object.assign({}, props), row.id));\n                }) }))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableBody__WEBPACK_IMPORTED_MODULE_60__[\"default\"], Object.assign({}, tableBodyProps, { sx: (theme) => (Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, height: rowVirtualizer\n                        ? `${rowVirtualizer.getTotalSize()}px`\n                        : undefined, minHeight: !rows.length ? '100px' : undefined, position: 'relative' }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme))), children: (_d = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _d !== void 0 ? _d : (!rows.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"tr\", { style: {\n                        display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n                    }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"td\", { colSpan: table.getVisibleLeafColumns().length, style: {\n                            display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n                        }, children: (_e = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _e !== void 0 ? _e : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Typography__WEBPACK_IMPORTED_MODULE_61__[\"default\"], { sx: {\n                                color: 'text.secondary',\n                                fontStyle: 'italic',\n                                maxWidth: `min(100vw, ${(_g = (_f = tablePaperRef.current) === null || _f === void 0 ? void 0 : _f.clientWidth) !== null && _g !== void 0 ? _g : 360}px)`,\n                                py: '2rem',\n                                textAlign: 'center',\n                                width: '100%',\n                            }, children: globalFilter || columnFilters.length\n                                ? localization.noResultsFound\n                                : localization.noRecordsToDisplay })) }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, staticRowIndex) => {\n                        let row = rowOrVirtualRow;\n                        if (rowVirtualizer) {\n                            if (renderDetailPanel) {\n                                if (rowOrVirtualRow.index % 2 === 1) {\n                                    return null;\n                                }\n                                else {\n                                    staticRowIndex = rowOrVirtualRow.index / 2;\n                                }\n                            }\n                            else {\n                                staticRowIndex = rowOrVirtualRow.index;\n                            }\n                            row = rows[staticRowIndex];\n                        }\n                        const props = Object.assign(Object.assign({}, commonRowProps), { pinnedRowIds,\n                            row,\n                            rowVirtualizer,\n                            staticRowIndex, virtualRow: rowVirtualizer\n                                ? rowOrVirtualRow\n                                : undefined });\n                        const key = `${row.id}-${row.index}`;\n                        return memoMode === 'rows' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), key)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyRow, Object.assign({}, props), key));\n                    }) }))) })), !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&\n                getIsSomeRowsPinned('bottom') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableBody__WEBPACK_IMPORTED_MODULE_60__[\"default\"], Object.assign({}, tableBodyProps, { sx: (theme) => (Object.assign({ bottom: tableFooterHeight - 1, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, position: 'sticky', zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme))), children: getBottomRows().map((row, staticRowIndex) => {\n                    const props = Object.assign(Object.assign({}, commonRowProps), { row,\n                        staticRowIndex });\n                    return memoMode === 'rows' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBodyRow, Object.assign({}, props), row.id));\n                }) })))] }));\n};\nconst Memo_MRT_TableBody = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);\n\nconst MRT_TableFooterCell = (_a) => {\n    var _b, _c, _d;\n    var { footer, staticColumnIndex, table } = _a, rest = __rest(_a, [\"footer\", \"staticColumnIndex\", \"table\"]);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    const { getState, options: { enableColumnPinning, muiTableFooterCellProps, enableKeyboardShortcuts, }, } = table;\n    const { density } = getState();\n    const { column } = footer;\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const isColumnPinned = enableColumnPinning &&\n        columnDef.columnDefType !== 'group' &&\n        column.getIsPinned();\n    const args = { column, table };\n    const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableFooterCellProps, args)), rest);\n    const handleKeyDown = (event) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);\n        cellKeyboardShortcuts({\n            event,\n            cellValue: footer.column.columnDef.footer,\n            table,\n        });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableCell__WEBPACK_IMPORTED_MODULE_56__[\"default\"], Object.assign({ align: columnDefType === 'group'\n            ? 'center'\n            : theme.direction === 'rtl'\n                ? 'right'\n                : 'left', colSpan: footer.colSpan, \"data-index\": staticColumnIndex, \"data-pinned\": !!isColumnPinned || undefined, tabIndex: enableKeyboardShortcuts ? 0 : undefined, variant: \"footer\" }, tableCellProps, { onKeyDown: handleKeyDown, sx: (theme) => (Object.assign(Object.assign({ fontWeight: 'bold', p: density === 'compact'\n                ? '0.5rem'\n                : density === 'comfortable'\n                    ? '1rem'\n                    : '1.5rem', verticalAlign: 'top' }, getCommonMRTCellStyles({\n            column,\n            header: footer,\n            table,\n            tableCellProps,\n            theme,\n        })), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme))), children: (_b = tableCellProps.children) !== null && _b !== void 0 ? _b : (footer.isPlaceholder\n            ? null\n            : ((_d = (_c = parseFromValuesOrFunc(columnDef.Footer, {\n                column,\n                footer,\n                table,\n            })) !== null && _c !== void 0 ? _c : columnDef.footer) !== null && _d !== void 0 ? _d : null)) })));\n};\n\nconst MRT_TableFooterRow = (_a) => {\n    var _b;\n    var { columnVirtualizer, footerGroup, table } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"footerGroup\", \"table\"]);\n    const { options: { layoutMode, mrtTheme: { baseBackgroundColor }, muiTableFooterRowProps, }, } = table;\n    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};\n    // if no content in row, skip row\n    if (!((_b = footerGroup.headers) === null || _b === void 0 ? void 0 : _b.some((header) => (typeof header.column.columnDef.footer === 'string' &&\n        !!header.column.columnDef.footer) ||\n        header.column.columnDef.Footer))) {\n        return null;\n    }\n    const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterRowProps, {\n        footerGroup,\n        table,\n    })), rest);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_TableRow__WEBPACK_IMPORTED_MODULE_58__[\"default\"], Object.assign({}, tableRowProps, { sx: (theme) => (Object.assign({ backgroundColor: baseBackgroundColor, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined, position: 'relative', width: '100%' }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme))), children: [virtualPaddingLeft ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"th\", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter, staticColumnIndex) => {\n                let footer = footerOrVirtualFooter;\n                if (columnVirtualizer) {\n                    staticColumnIndex = footerOrVirtualFooter\n                        .index;\n                    footer = footerGroup.headers[staticColumnIndex];\n                }\n                return footer ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableFooterCell, { footer: footer, staticColumnIndex: staticColumnIndex, table: table }, footer.id)) : null;\n            }), virtualPaddingRight ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"th\", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })));\n};\n\nconst MRT_TableFooter = (_a) => {\n    var { columnVirtualizer, table } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"table\"]);\n    const { getState, options: { enableStickyFooter, layoutMode, muiTableFooterProps }, refs: { tableFooterRef }, } = table;\n    const { isFullScreen } = getState();\n    const tableFooterProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterProps, {\n        table,\n    })), rest);\n    const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;\n    const footerGroups = table.getFooterGroups();\n    //if no footer cells at all, skip footer\n    if (!footerGroups.some((footerGroup) => {\n        var _a;\n        return (_a = footerGroup.headers) === null || _a === void 0 ? void 0 : _a.some((header) => (typeof header.column.columnDef.footer === 'string' &&\n            !!header.column.columnDef.footer) ||\n            header.column.columnDef.Footer);\n    })) {\n        return null;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableFooter__WEBPACK_IMPORTED_MODULE_62__[\"default\"], Object.assign({}, tableFooterProps, { ref: (ref) => {\n            tableFooterRef.current = ref;\n            if (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.ref) {\n                // @ts-expect-error\n                tableFooterProps.ref.current = ref;\n            }\n        }, sx: (theme) => (Object.assign({ bottom: stickFooter ? 0 : undefined, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, opacity: stickFooter ? 0.97 : undefined, outline: stickFooter\n                ? theme.palette.mode === 'light'\n                    ? `1px solid ${theme.palette.grey[300]}`\n                    : `1px solid ${theme.palette.grey[700]}`\n                : undefined, position: stickFooter ? 'sticky' : 'relative', zIndex: stickFooter ? 1 : undefined }, parseFromValuesOrFunc(tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx, theme))), children: footerGroups.map((footerGroup) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableFooterRow, { columnVirtualizer: columnVirtualizer, footerGroup: footerGroup, table: table }, footerGroup.id))) })));\n};\n\nconst mrtFilterOptions = (localization) => [\n    {\n        divider: false,\n        label: localization.filterFuzzy,\n        option: 'fuzzy',\n        symbol: '',\n    },\n    {\n        divider: false,\n        label: localization.filterContains,\n        option: 'contains',\n        symbol: '*',\n    },\n    {\n        divider: false,\n        label: localization.filterStartsWith,\n        option: 'startsWith',\n        symbol: 'a',\n    },\n    {\n        divider: true,\n        label: localization.filterEndsWith,\n        option: 'endsWith',\n        symbol: 'z',\n    },\n    {\n        divider: false,\n        label: localization.filterEquals,\n        option: 'equals',\n        symbol: '=',\n    },\n    {\n        divider: true,\n        label: localization.filterNotEquals,\n        option: 'notEquals',\n        symbol: '',\n    },\n    {\n        divider: false,\n        label: localization.filterBetween,\n        option: 'between',\n        symbol: '',\n    },\n    {\n        divider: true,\n        label: localization.filterBetweenInclusive,\n        option: 'betweenInclusive',\n        symbol: '',\n    },\n    {\n        divider: false,\n        label: localization.filterGreaterThan,\n        option: 'greaterThan',\n        symbol: '>',\n    },\n    {\n        divider: false,\n        label: localization.filterGreaterThanOrEqualTo,\n        option: 'greaterThanOrEqualTo',\n        symbol: '',\n    },\n    {\n        divider: false,\n        label: localization.filterLessThan,\n        option: 'lessThan',\n        symbol: '<',\n    },\n    {\n        divider: true,\n        label: localization.filterLessThanOrEqualTo,\n        option: 'lessThanOrEqualTo',\n        symbol: '',\n    },\n    {\n        divider: false,\n        label: localization.filterEmpty,\n        option: 'empty',\n        symbol: '',\n    },\n    {\n        divider: false,\n        label: localization.filterNotEmpty,\n        option: 'notEmpty',\n        symbol: '!',\n    },\n];\nconst rangeModes = ['between', 'betweenInclusive', 'inNumberRange'];\nconst emptyModes = ['empty', 'notEmpty'];\nconst arrModes = ['arrIncludesSome', 'arrIncludesAll', 'arrIncludes'];\nconst rangeVariants = ['range-slider', 'date-range', 'datetime-range', 'range'];\nconst MRT_FilterOptionMenu = (_a) => {\n    var _b, _c, _d, _e;\n    var { anchorEl, header, onSelect, setAnchorEl, setFilterValue, table } = _a, rest = __rest(_a, [\"anchorEl\", \"header\", \"onSelect\", \"setAnchorEl\", \"setFilterValue\", \"table\"]);\n    const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, mrtTheme: { menuBackgroundColor }, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems, }, setColumnFilterFns, setGlobalFilterFn, } = table;\n    const { density, globalFilterFn } = getState();\n    const { column } = header !== null && header !== void 0 ? header : {};\n    const { columnDef } = column !== null && column !== void 0 ? column : {};\n    const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();\n    let allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;\n    if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {\n        allowedColumnFilterOptions = [\n            ...rangeModes,\n            ...(allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []),\n        ].filter((option) => rangeModes.includes(option));\n    }\n    const internalFilterOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => mrtFilterOptions(localization).filter((filterOption) => columnDef\n        ? allowedColumnFilterOptions === undefined ||\n            (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption.option))\n        : (!globalFilterModeOptions ||\n            globalFilterModeOptions.includes(filterOption.option)) &&\n            ['contains', 'fuzzy', 'startsWith'].includes(filterOption.option)), []);\n    const handleSelectFilterMode = (option) => {\n        var _a, _b;\n        const prevFilterMode = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a !== void 0 ? _a : '';\n        if (!header || !column) {\n            // global filter mode\n            setGlobalFilterFn(option);\n        }\n        else if (option !== prevFilterMode) {\n            // column filter mode\n            setColumnFilterFns((prev) => (Object.assign(Object.assign({}, prev), { [header.id]: option })));\n            // reset filter value and/or perform new filter render\n            if (emptyModes.includes(option)) {\n                // will now be empty/notEmpty filter mode\n                if (currentFilterValue !== ' ' &&\n                    !emptyModes.includes(prevFilterMode)) {\n                    column.setFilterValue(' ');\n                }\n                else if (currentFilterValue) {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n            else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === 'multi-select' ||\n                arrModes.includes(option)) {\n                // will now be array filter mode\n                if (currentFilterValue instanceof String ||\n                    (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {\n                    column.setFilterValue([]);\n                    setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue([]);\n                }\n                else if (currentFilterValue) {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n            else if (((_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === null || _b === void 0 ? void 0 : _b.includes('range')) ||\n                rangeModes.includes(option)) {\n                // will now be range filter mode\n                if (!Array.isArray(currentFilterValue) ||\n                    (!(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === '')) &&\n                        !rangeModes.includes(prevFilterMode))) {\n                    column.setFilterValue(['', '']);\n                    setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue('');\n                }\n                else {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n            else {\n                // will now be single value filter mode\n                if (Array.isArray(currentFilterValue)) {\n                    column.setFilterValue('');\n                    setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue('');\n                }\n                else if (currentFilterValue === ' ' &&\n                    emptyModes.includes(prevFilterMode)) {\n                    column.setFilterValue(undefined);\n                }\n                else {\n                    column.setFilterValue(currentFilterValue); // perform new filter render\n                }\n            }\n        }\n        setAnchorEl(null);\n        onSelect === null || onSelect === void 0 ? void 0 : onSelect();\n    };\n    const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Menu__WEBPACK_IMPORTED_MODULE_14__[\"default\"], Object.assign({ MenuListProps: {\n            dense: density === 'compact',\n            sx: {\n                backgroundColor: menuBackgroundColor,\n            },\n        }, anchorEl: anchorEl, anchorOrigin: { horizontal: 'right', vertical: 'center' }, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: (_e = (header && column && columnDef\n            ? ((_d = (_c = columnDef.renderColumnFilterModeMenuItems) === null || _c === void 0 ? void 0 : _c.call(columnDef, {\n                column: column,\n                internalFilterOptions,\n                onSelectFilterMode: handleSelectFilterMode,\n                table,\n            })) !== null && _d !== void 0 ? _d : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({\n                column: column,\n                internalFilterOptions,\n                onSelectFilterMode: handleSelectFilterMode,\n                table,\n            }))\n            : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({\n                internalFilterOptions,\n                onSelectFilterMode: handleSelectFilterMode,\n                table,\n            }))) !== null && _e !== void 0 ? _e : internalFilterOptions.map(({ divider, label, option, symbol }, index) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { divider: divider, icon: symbol, label: label, onClick: () => handleSelectFilterMode(option), selected: option === filterOption, table: table, value: option }, index))) })));\n};\n\nconst MRT_ColumnActionMenu = (_a) => {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    var { anchorEl, header, setAnchorEl, table } = _a, rest = __rest(_a, [\"anchorEl\", \"header\", \"setAnchorEl\", \"table\"]);\n    const { getAllLeafColumns, getState, options: { columnFilterDisplayMode, columnFilterModeOptions, enableColumnFilterModes, enableColumnFilters, enableColumnPinning, enableColumnResizing, enableGrouping, enableHiding, enableSorting, enableSortingRemoval, icons: { ClearAllIcon, DynamicFeedIcon, FilterListIcon, FilterListOffIcon, PushPinIcon, RestartAltIcon, SortIcon, ViewColumnIcon, VisibilityOffIcon, }, localization, mrtTheme: { menuBackgroundColor }, renderColumnActionsMenuItems, }, refs: { filterInputRefs }, setColumnFilterFns, setColumnOrder, setColumnSizingInfo, setShowColumnFilters, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const { columnSizing, columnVisibility, density, showColumnFilters } = getState();\n    const columnFilterValue = column.getFilterValue();\n    const [filterMenuAnchorEl, setFilterMenuAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleClearSort = () => {\n        column.clearSorting();\n        setAnchorEl(null);\n    };\n    const handleSortAsc = () => {\n        column.toggleSorting(false);\n        setAnchorEl(null);\n    };\n    const handleSortDesc = () => {\n        column.toggleSorting(true);\n        setAnchorEl(null);\n    };\n    const handleResetColumnSize = () => {\n        setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));\n        column.resetSize();\n        setAnchorEl(null);\n    };\n    const handleHideColumn = () => {\n        column.toggleVisibility(false);\n        setAnchorEl(null);\n    };\n    const handlePinColumn = (pinDirection) => {\n        column.pin(pinDirection);\n        setAnchorEl(null);\n    };\n    const handleGroupByColumn = () => {\n        column.toggleGrouping();\n        setColumnOrder((old) => ['mrt-row-expand', ...old]);\n        setAnchorEl(null);\n    };\n    const handleClearFilter = () => {\n        column.setFilterValue(undefined);\n        setAnchorEl(null);\n        if (['empty', 'notEmpty'].includes(columnDef._filterFn)) {\n            setColumnFilterFns((prev) => {\n                var _a;\n                return (Object.assign(Object.assign({}, prev), { [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy' }));\n            });\n        }\n    };\n    const handleFilterByColumn = () => {\n        setShowColumnFilters(true);\n        queueMicrotask(() => { var _a, _b; return (_b = (_a = filterInputRefs.current) === null || _a === void 0 ? void 0 : _a[`${column.id}-0`]) === null || _b === void 0 ? void 0 : _b.focus(); });\n        setAnchorEl(null);\n    };\n    const handleShowAllColumns = () => {\n        getAllLeafColumns()\n            .filter((col) => col.columnDef.enableHiding !== false)\n            .forEach((col) => col.toggleVisibility(true));\n        setAnchorEl(null);\n    };\n    const handleOpenFilterModeMenu = (event) => {\n        event.stopPropagation();\n        setFilterMenuAnchorEl(event.currentTarget);\n    };\n    const isSelectFilter = !!columnDef.filterSelectOptions;\n    const allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;\n    const showFilterModeSubMenu = enableColumnFilterModes &&\n        columnDef.enableColumnFilterModes !== false &&\n        !isSelectFilter &&\n        (allowedColumnFilterOptions === undefined ||\n            !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));\n    const internalColumnMenuItems = [\n        ...(enableSorting && column.getCanSort()\n            ? [\n                enableSortingRemoval !== false && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: column.getIsSorted() === false, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ClearAllIcon, {}), label: localization.clearSort, onClick: handleClearSort, table: table }, 0)),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: column.getIsSorted() === 'asc', icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SortIcon, { style: { transform: 'rotate(180deg) scaleX(-1)' } }), label: (_c = localization.sortByColumnAsc) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header)), onClick: handleSortAsc, table: table }, 1),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: column.getIsSorted() === 'desc', divider: enableColumnFilters || enableGrouping || enableHiding, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SortIcon, {}), label: (_d = localization.sortByColumnDesc) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header)), onClick: handleSortDesc, table: table }, 2),\n            ]\n            : []),\n        ...(enableColumnFilters && column.getCanFilter()\n            ? [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: !columnFilterValue ||\n                        (Array.isArray(columnFilterValue) &&\n                            !columnFilterValue.filter((value) => value).length), icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FilterListOffIcon, {}), label: localization.clearFilter, onClick: handleClearFilter, table: table }, 3),\n                columnFilterDisplayMode === 'subheader' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: showColumnFilters && !enableColumnFilterModes, divider: enableGrouping || enableHiding, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FilterListIcon, {}), label: (_e = localization.filterByColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header)), onClick: showColumnFilters\n                        ? handleOpenFilterModeMenu\n                        : handleFilterByColumn, onOpenSubMenu: showFilterModeSubMenu ? handleOpenFilterModeMenu : undefined, table: table }, 4)),\n                showFilterModeSubMenu && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterOptionMenu, { anchorEl: filterMenuAnchorEl, header: header, onSelect: handleFilterByColumn, setAnchorEl: setFilterMenuAnchorEl, table: table }, 5)),\n            ].filter(Boolean)\n            : []),\n        ...(enableGrouping && column.getCanGroup()\n            ? [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { divider: enableColumnPinning, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DynamicFeedIcon, {}), label: (_f = localization[column.getIsGrouped() ? 'ungroupByColumn' : 'groupByColumn']) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)), onClick: handleGroupByColumn, table: table }, 6),\n            ]\n            : []),\n        ...(enableColumnPinning && column.getCanPin()\n            ? [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: column.getIsPinned() === 'left' || !column.getCanPin(), icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, { style: { transform: 'rotate(90deg)' } }), label: localization.pinToLeft, onClick: () => handlePinColumn('left'), table: table }, 7),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: column.getIsPinned() === 'right' || !column.getCanPin(), icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, { style: { transform: 'rotate(-90deg)' } }), label: localization.pinToRight, onClick: () => handlePinColumn('right'), table: table }, 8),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: !column.getIsPinned(), divider: enableHiding, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, {}), label: localization.unpin, onClick: () => handlePinColumn(false), table: table }, 9),\n            ]\n            : []),\n        ...(enableColumnResizing && column.getCanResize()\n            ? [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: columnSizing[column.id] === undefined, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RestartAltIcon, {}), label: localization.resetColumnSize, onClick: handleResetColumnSize, table: table }, 10),\n            ]\n            : []),\n        ...(enableHiding\n            ? [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: !column.getCanHide(), icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VisibilityOffIcon, {}), label: (_g = localization.hideColumn) === null || _g === void 0 ? void 0 : _g.replace('{column}', String(columnDef.header)), onClick: handleHideColumn, table: table }, 11),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { disabled: !Object.values(columnVisibility).filter((visible) => !visible)\n                        .length, icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ViewColumnIcon, {}), label: (_h = localization.showAllColumns) === null || _h === void 0 ? void 0 : _h.replace('{column}', String(columnDef.header)), onClick: handleShowAllColumns, table: table }, 12),\n            ]\n            : []),\n    ].filter(Boolean);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Menu__WEBPACK_IMPORTED_MODULE_14__[\"default\"], Object.assign({ MenuListProps: {\n            dense: density === 'compact',\n            sx: {\n                backgroundColor: menuBackgroundColor,\n            },\n        }, anchorEl: anchorEl, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: (_l = (_k = (_j = columnDef.renderColumnActionsMenuItems) === null || _j === void 0 ? void 0 : _j.call(columnDef, {\n            closeMenu: () => setAnchorEl(null),\n            column,\n            internalColumnMenuItems,\n            table,\n        })) !== null && _k !== void 0 ? _k : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({\n            closeMenu: () => setAnchorEl(null),\n            column,\n            internalColumnMenuItems,\n            table,\n        })) !== null && _l !== void 0 ? _l : internalColumnMenuItems })));\n};\n\nconst MRT_TableHeadCellColumnActionsButton = (_a) => {\n    var _b, _c;\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    const { options: { icons: { MoreVertIcon }, localization, muiColumnActionsButtonProps, }, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const [anchorEl, setAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleClick = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        setAnchorEl(event.currentTarget);\n    };\n    const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnActionsButtonProps, {\n        column,\n        table,\n    })), parseFromValuesOrFunc(columnDef.muiColumnActionsButtonProps, {\n        column,\n        table,\n    })), rest);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps('top'), { title: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b !== void 0 ? _b : localization.columnActions, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.columnActions, onClick: handleClick, size: \"small\" }, iconButtonProps, { sx: (theme) => (Object.assign({ '&:hover': {\n                            opacity: 1,\n                        }, height: '2rem', m: '-8px -4px', opacity: 0.3, transition: 'all 150ms', width: '2rem' }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme))), title: undefined, children: (_c = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c !== void 0 ? _c : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MoreVertIcon, { style: { transform: 'scale(0.9)' } })) })) })), anchorEl && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ColumnActionMenu, { anchorEl: anchorEl, header: header, setAnchorEl: setAnchorEl, table: table }))] }));\n};\n\nconst MRT_FilterCheckbox = (_a) => {\n    var _b, _c, _d;\n    var { column, table } = _a, rest = __rest(_a, [\"column\", \"table\"]);\n    const { getState, options: { localization, muiFilterCheckboxProps }, } = table;\n    const { density } = getState();\n    const { columnDef } = column;\n    const checkboxProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterCheckboxProps, {\n        column,\n        table,\n    })), parseFromValuesOrFunc(columnDef.muiFilterCheckboxProps, {\n        column,\n        table,\n    })), rest);\n    const filterLabel = (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace('{column}', columnDef.header);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps(), { title: (_c = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_FormControlLabel__WEBPACK_IMPORTED_MODULE_63__[\"default\"], { control: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Checkbox__WEBPACK_IMPORTED_MODULE_18__[\"default\"], Object.assign({ checked: column.getFilterValue() === 'true', color: column.getFilterValue() === undefined ? 'default' : 'primary', indeterminate: column.getFilterValue() === undefined, size: density === 'compact' ? 'small' : 'medium' }, checkboxProps, { onChange: (e, checked) => {\n                    var _a;\n                    column.setFilterValue(column.getFilterValue() === undefined\n                        ? 'true'\n                        : column.getFilterValue() === 'true'\n                            ? 'false'\n                            : undefined);\n                    (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e, checked);\n                }, onClick: (e) => {\n                    var _a;\n                    e.stopPropagation();\n                    (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);\n                }, sx: (theme) => (Object.assign({ height: '2.5rem', width: '2.5rem' }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme))) })), disableTypography: true, label: (_d = checkboxProps.title) !== null && _d !== void 0 ? _d : filterLabel, sx: { color: 'text.secondary', fontWeight: 'normal', mt: '-4px' }, title: undefined }) })));\n};\n\nconst MRT_FilterTextField = (_a) => {\n    var _b, _c, _d, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    var { header, rangeFilterIndex, table } = _a, rest = __rest(_a, [\"header\", \"rangeFilterIndex\", \"table\"]);\n    const { options: { enableColumnFilterModes, icons: { CloseIcon, FilterListIcon }, localization, manualFiltering, muiFilterAutocompleteProps, muiFilterDatePickerProps, muiFilterDateTimePickerProps, muiFilterTextFieldProps, muiFilterTimePickerProps, }, refs: { filterInputRefs }, setColumnFilterFns, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const { filterVariant } = columnDef;\n    const args = { column, rangeFilterIndex, table };\n    const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTextFieldProps, args)), parseFromValuesOrFunc(columnDef.muiFilterTextFieldProps, args)), rest);\n    const autocompleteProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterAutocompleteProps, args)), parseFromValuesOrFunc(columnDef.muiFilterAutocompleteProps, args));\n    const datePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDatePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterDatePickerProps, args));\n    const dateTimePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDateTimePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterDateTimePickerProps, args));\n    const timePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTimePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterTimePickerProps, args));\n    const { allowedColumnFilterOptions, currentFilterOption, facetedUniqueValues, isAutocompleteFilter, isDateFilter, isMultiSelectFilter, isRangeFilter, isSelectFilter, isTextboxFilter, } = getColumnFilterInfo({ header, table });\n    const dropdownOptions = useDropdownOptions({ header, table });\n    const filterChipLabel = ['empty', 'notEmpty'].includes(currentFilterOption)\n        ? localization[`filter${((_c = (_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _b === void 0 ? void 0 : _b.call(currentFilterOption, 0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) +\n            (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]\n        : '';\n    const filterPlaceholder = !isRangeFilter\n        ? ((_d = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.placeholder) !== null && _d !== void 0 ? _d : (_f = localization.filterByColumn) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)))\n        : rangeFilterIndex === 0\n            ? localization.min\n            : rangeFilterIndex === 1\n                ? localization.max\n                : '';\n    const showChangeModeButton = !!(enableColumnFilterModes &&\n        columnDef.enableColumnFilterModes !== false &&\n        !rangeFilterIndex &&\n        (allowedColumnFilterOptions === undefined ||\n            !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length)));\n    const [anchorEl, setAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [filterValue, setFilterValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n        var _a, _b;\n        return isMultiSelectFilter\n            ? column.getFilterValue() || []\n            : isRangeFilter\n                ? ((_a = column.getFilterValue()) === null || _a === void 0 ? void 0 : _a[rangeFilterIndex]) || ''\n                : isAutocompleteFilter\n                    ? typeof column.getFilterValue() === 'string' ? column.getFilterValue() : ''\n                    : ((_b = column.getFilterValue()) !== null && _b !== void 0 ? _b : '');\n    });\n    const [autocompleteValue, setAutocompleteValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => isAutocompleteFilter ? (column.getFilterValue() || null) : null);\n    const handleChangeDebounced = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((0,_mui_material_utils__WEBPACK_IMPORTED_MODULE_64__[\"default\"])((newValue) => {\n        if (isRangeFilter) {\n            column.setFilterValue((old) => {\n                const newFilterValues = old !== null && old !== void 0 ? old : ['', ''];\n                newFilterValues[rangeFilterIndex] = newValue !== null && newValue !== void 0 ? newValue : undefined;\n                return newFilterValues;\n            });\n        }\n        else {\n            column.setFilterValue(newValue !== null && newValue !== void 0 ? newValue : undefined);\n        }\n    }, isTextboxFilter ? (manualFiltering ? 400 : 200) : 1), []);\n    const handleChange = (newValue) => {\n        setFilterValue(newValue !== null && newValue !== void 0 ? newValue : '');\n        handleChangeDebounced(newValue);\n    };\n    const handleTextFieldChange = (event) => {\n        var _a;\n        const newValue = textFieldProps.type === 'date'\n            ? event.target.valueAsDate\n            : textFieldProps.type === 'number'\n                ? event.target.valueAsNumber\n                : event.target.value;\n        handleChange(newValue);\n        (_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, event);\n    };\n    const handleAutocompleteInputChange = (_event, newValue, _reason) => {\n        handleChange(newValue);\n    };\n    const handleAutocompleteChange = (newValue) => {\n        setAutocompleteValue(newValue);\n        handleChangeDebounced(getValueAndLabel(newValue).value);\n    };\n    const handleClear = () => {\n        if (isMultiSelectFilter) {\n            setFilterValue([]);\n            column.setFilterValue([]);\n        }\n        else if (isRangeFilter) {\n            setFilterValue('');\n            column.setFilterValue((old) => {\n                const newFilterValues = (Array.isArray(old) && old) || ['', ''];\n                newFilterValues[rangeFilterIndex] = undefined;\n                return newFilterValues;\n            });\n        }\n        else if (isAutocompleteFilter) {\n            setAutocompleteValue(null);\n            setFilterValue('');\n            // when using 'autocomplete' this function is called only inside effect and only if the filterValue === undefined\n            // so the following call is excessive; should be uncommented if the handleClear becomes part of the Autocomplete component callbacks\n            // column.setFilterValue(undefined)\n        }\n        else {\n            setFilterValue('');\n            column.setFilterValue(undefined);\n        }\n    };\n    const handleClearEmptyFilterChip = () => {\n        setFilterValue('');\n        column.setFilterValue(undefined);\n        setColumnFilterFns((prev) => {\n            var _a;\n            return (Object.assign(Object.assign({}, prev), { [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy' }));\n        });\n    };\n    const handleFilterMenuOpen = (event) => {\n        setAnchorEl(event.currentTarget);\n    };\n    const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (isMounted.current) {\n            const filterValue = column.getFilterValue();\n            if (filterValue === undefined) {\n                handleClear();\n            }\n            else if (isRangeFilter && rangeFilterIndex !== undefined) {\n                setFilterValue(filterValue[rangeFilterIndex]);\n            }\n            else {\n                setFilterValue(filterValue);\n            }\n        }\n        isMounted.current = true;\n    }, [column.getFilterValue()]);\n    if (columnDef.Filter) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: (_g = columnDef.Filter) === null || _g === void 0 ? void 0 : _g.call(columnDef, { column, header, rangeFilterIndex, table }) }));\n    }\n    const endAdornment = !isAutocompleteFilter && !isDateFilter && !filterChipLabel ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_InputAdornment__WEBPACK_IMPORTED_MODULE_65__[\"default\"], { position: \"end\", sx: {\n            mr: isSelectFilter || isMultiSelectFilter ? '20px' : undefined,\n            visibility: ((_h = filterValue === null || filterValue === void 0 ? void 0 : filterValue.length) !== null && _h !== void 0 ? _h : 0) > 0 ? 'visible' : 'hidden',\n        }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { placement: \"right\", title: (_j = localization.clearFilter) !== null && _j !== void 0 ? _j : '', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.clearFilter, disabled: !((_k = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _k === void 0 ? void 0 : _k.length), onClick: handleClear, size: \"small\", sx: {\n                        height: '2rem',\n                        transform: 'scale(0.9)',\n                        width: '2rem',\n                    }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CloseIcon, {}) }) }) }) })) : null;\n    const startAdornment = showChangeModeButton ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_InputAdornment__WEBPACK_IMPORTED_MODULE_65__[\"default\"], { position: \"start\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.changeFilterMode, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.changeFilterMode, onClick: handleFilterMenuOpen, size: \"small\", sx: { height: '1.75rem', width: '1.75rem' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FilterListIcon, {}) }) }) }), filterChipLabel && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Chip__WEBPACK_IMPORTED_MODULE_66__[\"default\"], { label: filterChipLabel, onDelete: handleClearEmptyFilterChip }))] })) : null;\n    const commonTextFieldProps = Object.assign(Object.assign({ fullWidth: true, helperText: showChangeModeButton ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"label\", { children: localization.filterMode.replace('{filterType}', localization[`filter${((_l = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _l === void 0 ? void 0 : _l.toUpperCase()) +\n                (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]) })) : null, inputRef: (inputRef) => {\n            filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =\n                inputRef;\n            if (textFieldProps.inputRef) {\n                textFieldProps.inputRef = inputRef;\n            }\n        }, margin: 'none', placeholder: filterChipLabel || isSelectFilter || isMultiSelectFilter\n            ? undefined\n            : filterPlaceholder, variant: 'standard' }, textFieldProps), { slotProps: Object.assign(Object.assign({}, textFieldProps.slotProps), { formHelperText: Object.assign({ sx: {\n                    fontSize: '0.75rem',\n                    lineHeight: '0.8rem',\n                    whiteSpace: 'nowrap',\n                } }, (_m = textFieldProps.slotProps) === null || _m === void 0 ? void 0 : _m.formHelperText), input: endAdornment //hack because mui looks for presence of endAdornment key instead of undefined\n                ? Object.assign({ endAdornment, startAdornment }, (_o = textFieldProps.slotProps) === null || _o === void 0 ? void 0 : _o.input) : Object.assign({ startAdornment }, (_p = textFieldProps.slotProps) === null || _p === void 0 ? void 0 : _p.input), htmlInput: Object.assign({ 'aria-label': filterPlaceholder, autoComplete: 'off', disabled: !!filterChipLabel, sx: {\n                    textOverflow: 'ellipsis',\n                    width: filterChipLabel ? 0 : undefined,\n                }, title: filterPlaceholder }, (_q = textFieldProps.slotProps) === null || _q === void 0 ? void 0 : _q.htmlInput) }), onKeyDown: (e) => {\n            var _a;\n            e.stopPropagation();\n            (_a = textFieldProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, e);\n        }, sx: (theme) => (Object.assign({ minWidth: isDateFilter\n                ? '160px'\n                : enableColumnFilterModes && rangeFilterIndex === 0\n                    ? '110px'\n                    : isRangeFilter\n                        ? '100px'\n                        : !filterChipLabel\n                            ? '120px'\n                            : 'auto', mx: '-2px', p: 0, width: 'calc(100% + 4px)' }, parseFromValuesOrFunc(textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx, theme))) });\n    const commonDatePickerProps = {\n        onChange: (newDate) => {\n            handleChange(newDate);\n        },\n        value: filterValue || null,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('time')) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_x_date_pickers_TimePicker__WEBPACK_IMPORTED_MODULE_67__.TimePicker, Object.assign({}, commonDatePickerProps, timePickerProps, { slotProps: {\n                    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_r = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _r === void 0 ? void 0 : _r.field),\n                    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_s = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _s === void 0 ? void 0 : _s.textField),\n                } }))) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('datetime')) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_x_date_pickers_DateTimePicker__WEBPACK_IMPORTED_MODULE_68__.DateTimePicker, Object.assign({}, commonDatePickerProps, dateTimePickerProps, { slotProps: {\n                    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_t = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _t === void 0 ? void 0 : _t.field),\n                    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_u = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _u === void 0 ? void 0 : _u.textField),\n                } }))) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith('date')) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_x_date_pickers_DatePicker__WEBPACK_IMPORTED_MODULE_69__.DatePicker, Object.assign({}, commonDatePickerProps, datePickerProps, { slotProps: {\n                    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_v = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _v === void 0 ? void 0 : _v.field),\n                    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_w = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _w === void 0 ? void 0 : _w.textField),\n                } }))) : isAutocompleteFilter ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Autocomplete__WEBPACK_IMPORTED_MODULE_70__[\"default\"], Object.assign({ freeSolo: true, getOptionLabel: (option) => getValueAndLabel(option).label, onChange: (_e, newValue) => handleAutocompleteChange(newValue), options: (_x = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option) => getValueAndLabel(option))) !== null && _x !== void 0 ? _x : [], inputValue: filterValue, onInputChange: handleAutocompleteInputChange }, autocompleteProps, { renderInput: (builtinTextFieldProps) => {\n                    var _a, _b, _c, _d, _f;\n                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TextField__WEBPACK_IMPORTED_MODULE_55__[\"default\"], Object.assign({}, commonTextFieldProps, builtinTextFieldProps, { slotProps: Object.assign(Object.assign(Object.assign({}, builtinTextFieldProps.slotProps), commonTextFieldProps.slotProps), { input: Object.assign(Object.assign(Object.assign({}, builtinTextFieldProps.InputProps), (_a = builtinTextFieldProps.slotProps) === null || _a === void 0 ? void 0 : _a.input), { startAdornment: \n                                //@ts-expect-error\n                                (_c = (_b = commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.slotProps) === null || _b === void 0 ? void 0 : _b.input) === null || _c === void 0 ? void 0 : _c.startAdornment }), htmlInput: Object.assign(Object.assign(Object.assign({}, builtinTextFieldProps.inputProps), (_d = builtinTextFieldProps.slotProps) === null || _d === void 0 ? void 0 : _d.htmlInput), (_f = commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.slotProps) === null || _f === void 0 ? void 0 : _f.htmlInput) }), onClick: (e) => e.stopPropagation() })));\n                }, value: autocompleteValue }))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TextField__WEBPACK_IMPORTED_MODULE_55__[\"default\"], Object.assign({ select: isSelectFilter || isMultiSelectFilter }, commonTextFieldProps, { slotProps: Object.assign(Object.assign({}, commonTextFieldProps.slotProps), { inputLabel: Object.assign({ shrink: isSelectFilter || isMultiSelectFilter }, (_y = commonTextFieldProps.slotProps) === null || _y === void 0 ? void 0 : _y.inputLabel), select: Object.assign({ MenuProps: { disableScrollLock: true }, displayEmpty: true, multiple: isMultiSelectFilter, renderValue: isMultiSelectFilter\n                            ? (selected) => !Array.isArray(selected) || (selected === null || selected === void 0 ? void 0 : selected.length) === 0 ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { opacity: 0.5 }, children: filterPlaceholder })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { display: 'flex', flexWrap: 'wrap', gap: '2px' }, children: selected.map((value) => {\n                                    const selectedValue = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find((option) => getValueAndLabel(option).value === value);\n                                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Chip__WEBPACK_IMPORTED_MODULE_66__[\"default\"], { label: getValueAndLabel(selectedValue).label }, value));\n                                }) }))\n                            : undefined }, (_z = commonTextFieldProps.slotProps) === null || _z === void 0 ? void 0 : _z.select) }), onChange: handleTextFieldChange, onClick: (e) => e.stopPropagation(), value: isMultiSelectFilter\n                    ? Array.isArray(filterValue)\n                        ? filterValue\n                        : []\n                    : filterValue, children: (isSelectFilter || isMultiSelectFilter) && [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__[\"default\"], { disabled: true, divider: true, hidden: true, value: \"\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { opacity: 0.5 }, children: filterPlaceholder }) }, \"p\"),\n                    ...[\n                        (_0 = textFieldProps.children) !== null && _0 !== void 0 ? _0 : dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option, index) => {\n                            var _a;\n                            const { label, value } = getValueAndLabel(option);\n                            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__[\"default\"], { sx: {\n                                    alignItems: 'center',\n                                    display: 'flex',\n                                    gap: '0.5rem',\n                                    m: 0,\n                                }, value: value, children: [isMultiSelectFilter && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Checkbox__WEBPACK_IMPORTED_MODULE_18__[\"default\"], { checked: ((_a = column.getFilterValue()) !== null && _a !== void 0 ? _a : []).includes(value), sx: { mr: '0.5rem' } })), label, ' ', !columnDef.filterSelectOptions &&\n                                        `(${facetedUniqueValues.get(value)})`] }, `${index}-${value}`));\n                        }),\n                    ],\n                ] }))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterOptionMenu, { anchorEl: anchorEl, header: header, setAnchorEl: setAnchorEl, setFilterValue: setFilterValue, table: table })] }));\n};\n\nconst MRT_FilterRangeFields = (_a) => {\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], Object.assign({}, rest, { sx: (theme) => (Object.assign({ display: 'grid', gap: '1rem', gridTemplateColumns: '1fr 1fr' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: [0, 1].map((rangeFilterIndex) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterTextField, { header: header, rangeFilterIndex: rangeFilterIndex, table: table }, rangeFilterIndex))) })));\n};\n\nconst MRT_FilterRangeSlider = (_a) => {\n    var _b, _c;\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    const { options: { enableColumnFilterModes, localization, muiFilterSliderProps }, refs: { filterInputRefs }, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const currentFilterOption = columnDef._filterFn;\n    const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false;\n    const sliderProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterSliderProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterSliderProps, { column, table })), rest);\n    let [min, max] = sliderProps.min !== undefined && sliderProps.max !== undefined\n        ? [sliderProps.min, sliderProps.max]\n        : ((_b = column.getFacetedMinMaxValues()) !== null && _b !== void 0 ? _b : [0, 1]);\n    //fix potential TanStack Table bugs where min or max is an array\n    if (Array.isArray(min))\n        min = min[0];\n    if (Array.isArray(max))\n        max = max[0];\n    if (min === null)\n        min = 0;\n    if (max === null)\n        max = 1;\n    const [filterValues, setFilterValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([min, max]);\n    const columnFilterValue = column.getFilterValue();\n    const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // prevent moving the focus to the next/prev cell when using the arrow keys\n    const handleKeyDown = (event) => {\n        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {\n            event.stopPropagation();\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (isMounted.current) {\n            if (columnFilterValue === undefined) {\n                setFilterValues([min, max]);\n            }\n            else if (Array.isArray(columnFilterValue)) {\n                setFilterValues(columnFilterValue);\n            }\n        }\n        isMounted.current = true;\n    }, [columnFilterValue, min, max]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Stack__WEBPACK_IMPORTED_MODULE_16__[\"default\"], { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Slider__WEBPACK_IMPORTED_MODULE_71__[\"default\"], Object.assign({ disableSwap: true, max: max, min: min, onChange: (_event, values) => {\n                    setFilterValues(values);\n                }, onChangeCommitted: (_event, value) => {\n                    if (Array.isArray(value)) {\n                        if (value[0] <= min && value[1] >= max) {\n                            //if the user has selected the entire range, remove the filter\n                            column.setFilterValue(undefined);\n                        }\n                        else {\n                            column.setFilterValue(value);\n                        }\n                    }\n                }, onKeyDown: handleKeyDown, value: filterValues, valueLabelDisplay: \"auto\" }, sliderProps, { slotProps: {\n                    input: {\n                        ref: (node) => {\n                            var _a, _b;\n                            if (node) {\n                                filterInputRefs.current[`${column.id}-0`] = node;\n                                // @ts-expect-error\n                                if ((_b = (_a = sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.slotProps) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.ref) {\n                                    //@ts-expect-error\n                                    sliderProps.slotProps.input.ref = node;\n                                }\n                            }\n                        },\n                    },\n                }, sx: (theme) => (Object.assign({ m: 'auto', minWidth: `${column.getSize() - 50}px`, mt: !showChangeModeButton ? '10px' : '6px', px: '4px', width: 'calc(100% - 8px)' }, parseFromValuesOrFunc(sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.sx, theme))) })), showChangeModeButton ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_FormHelperText__WEBPACK_IMPORTED_MODULE_72__[\"default\"], { sx: {\n                    fontSize: '0.75rem',\n                    lineHeight: '0.8rem',\n                    m: '-3px -6px',\n                    whiteSpace: 'nowrap',\n                }, children: localization.filterMode.replace('{filterType}', localization[`filter${((_c = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) +\n                    (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]) })) : null] }));\n};\n\nconst MRT_TableHeadCellFilterContainer = (_a) => {\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    const { getState, options: { columnFilterDisplayMode }, } = table;\n    const { showColumnFilters } = getState();\n    const { column } = header;\n    const { columnDef } = column;\n    const { isRangeFilter } = getColumnFilterInfo({ header, table });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Collapse__WEBPACK_IMPORTED_MODULE_59__[\"default\"], Object.assign({ in: showColumnFilters || columnFilterDisplayMode === 'popover', mountOnEnter: true, unmountOnExit: true }, rest, { children: columnDef.filterVariant === 'checkbox' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterCheckbox, { column: column, table: table })) : columnDef.filterVariant === 'range-slider' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterRangeSlider, { header: header, table: table })) : isRangeFilter ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterRangeFields, { header: header, table: table })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterTextField, { header: header, table: table })) })));\n};\n\nconst MRT_TableHeadCellFilterLabel = (_a) => {\n    var _b;\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    const { options: { columnFilterDisplayMode, icons: { FilterAltIcon }, localization, }, refs: { filterInputRefs }, setShowColumnFilters, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const filterValue = column.getFilterValue();\n    const [anchorEl, setAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { currentFilterOption, isMultiSelectFilter, isRangeFilter, isSelectFilter, } = getColumnFilterInfo({ header, table });\n    const dropdownOptions = useDropdownOptions({ header, table });\n    const getSelectLabel = (index) => getValueAndLabel(dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find((option) => getValueAndLabel(option).value ===\n        (index !== undefined ? filterValue[index] : filterValue))).label;\n    const isFilterActive = (Array.isArray(filterValue) && filterValue.some(Boolean)) ||\n        (!!filterValue && !Array.isArray(filterValue));\n    const filterTooltip = columnFilterDisplayMode === 'popover' && !isFilterActive\n        ? (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header))\n        : localization.filteringByColumn\n            .replace('{column}', String(columnDef.header))\n            .replace('{filterType}', currentFilterOption\n            ? localization[`filter${currentFilterOption.charAt(0).toUpperCase() +\n                currentFilterOption.slice(1)}`]\n            : '')\n            .replace('{filterValue}', `\"${Array.isArray(filterValue)\n            ? filterValue\n                .map((value, index) => isMultiSelectFilter ? getSelectLabel(index) : value)\n                .join(`\" ${isRangeFilter ? localization.and : localization.or} \"`)\n            : isSelectFilter\n                ? getSelectLabel()\n                : filterValue}\"`)\n            .replace('\" \"', '');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Grow__WEBPACK_IMPORTED_MODULE_73__[\"default\"], { in: columnFilterDisplayMode === 'popover' ||\n                    (!!filterValue && !isRangeFilter) ||\n                    (isRangeFilter && (!!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[0]) || !!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[1]))), unmountOnExit: true, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { component: \"span\", sx: { flex: '0 0' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { placement: \"top\", title: filterTooltip, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ disableRipple: true, onClick: (event) => {\n                                if (columnFilterDisplayMode === 'popover') {\n                                    setAnchorEl(event.currentTarget);\n                                }\n                                else {\n                                    setShowColumnFilters(true);\n                                }\n                                queueMicrotask(() => {\n                                    var _a, _b, _c, _d, _e, _f;\n                                    (_c = (_b = (_a = filterInputRefs.current) === null || _a === void 0 ? void 0 : _a[`${column.id}-0`]) === null || _b === void 0 ? void 0 : _b.focus) === null || _c === void 0 ? void 0 : _c.call(_b);\n                                    (_f = (_e = (_d = filterInputRefs.current) === null || _d === void 0 ? void 0 : _d[`${column.id}-0`]) === null || _e === void 0 ? void 0 : _e.select) === null || _f === void 0 ? void 0 : _f.call(_e);\n                                });\n                                event.stopPropagation();\n                            }, size: \"small\" }, rest, { sx: (theme) => (Object.assign({ height: '16px', ml: '4px', opacity: isFilterActive ? 1 : 0.3, p: '8px', transform: 'scale(0.75)', transition: 'all 150ms ease-in-out', width: '16px' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FilterAltIcon, {}) })) }) }) }), columnFilterDisplayMode === 'popover' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Popover__WEBPACK_IMPORTED_MODULE_74__[\"default\"], { anchorEl: anchorEl, anchorOrigin: {\n                    horizontal: 'center',\n                    vertical: 'top',\n                }, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: (event) => {\n                    //@ts-expect-error\n                    event.stopPropagation();\n                    setAnchorEl(null);\n                }, onKeyDown: (event) => event.key === 'Enter' && setAnchorEl(null), open: !!anchorEl, slotProps: { paper: { sx: { overflow: 'visible' } } }, transformOrigin: {\n                    horizontal: 'center',\n                    vertical: 'bottom',\n                }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { p: '1rem' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellFilterContainer, { header: header, table: table }) }) }))] }));\n};\n\nconst MRT_TableHeadCellGrabHandle = (_a) => {\n    var { column, table, tableHeadCellRef } = _a, rest = __rest(_a, [\"column\", \"table\", \"tableHeadCellRef\"]);\n    const { getState, options: { enableColumnOrdering, muiColumnDragHandleProps }, setColumnOrder, setColumnPinning, setDraggingColumn, setHoveredColumn, } = table;\n    const { columnDef } = column;\n    const { columnOrder, draggingColumn, hoveredColumn } = getState();\n    const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnDragHandleProps, { column, table })), parseFromValuesOrFunc(columnDef.muiColumnDragHandleProps, {\n        column,\n        table,\n    })), rest);\n    const handleDragStart = (event) => {\n        var _a;\n        (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n        setDraggingColumn(column);\n        try {\n            event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    };\n    const handleDragEnd = (event) => {\n        var _a;\n        (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(iconButtonProps, event);\n        if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n            column.toggleGrouping();\n        }\n        else if (enableColumnOrdering &&\n            hoveredColumn &&\n            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {\n            const reorderedColumns = reorderColumn(column, hoveredColumn, columnOrder);\n            setColumnOrder(reorderedColumns);\n            setColumnPinning(({ left = [], right = [] }) => ({\n                left: reorderedColumns.filter(header => left.includes(header)),\n                right: reorderedColumns.filter(header => right.includes(header)),\n            }));\n        }\n        setDraggingColumn(null);\n        setHoveredColumn(null);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })));\n};\n\nconst MRT_TableHeadCellResizeHandle = (_a) => {\n    var _b;\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    const { getState, options: { columnResizeDirection, columnResizeMode }, setColumnSizingInfo, } = table;\n    const { density } = getState();\n    const { column } = header;\n    const handler = header.getResizeHandler();\n    const mx = density === 'compact'\n        ? '-8px'\n        : density === 'comfortable'\n            ? '-16px'\n            : '-24px';\n    const lr = column.columnDef.columnDefType === 'display' ? '4px' : '0';\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { className: \"Mui-TableHeadCell-ResizeHandle-Wrapper\", onDoubleClick: () => {\n            setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));\n            column.resetSize();\n        }, onMouseDown: handler, onTouchStart: handler, style: {\n            transform: column.getIsResizing() && columnResizeMode === 'onEnd'\n                ? `translateX(${(columnResizeDirection === 'rtl' ? -1 : 1) *\n                    ((_b = getState().columnSizingInfo.deltaOffset) !== null && _b !== void 0 ? _b : 0)}px)`\n                : undefined,\n        }, sx: (theme) => ({\n            '&:active > hr': {\n                backgroundColor: theme.palette.info.main,\n                opacity: header.subHeaders.length || columnResizeMode === 'onEnd' ? 1 : 0,\n            },\n            cursor: 'col-resize',\n            left: columnResizeDirection === 'rtl' ? lr : undefined,\n            ml: columnResizeDirection === 'rtl' ? mx : undefined,\n            mr: columnResizeDirection === 'ltr' ? mx : undefined,\n            position: 'absolute',\n            px: '4px',\n            right: columnResizeDirection === 'ltr' ? lr : undefined,\n        }), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Divider__WEBPACK_IMPORTED_MODULE_75__[\"default\"], { className: \"Mui-TableHeadCell-ResizeHandle-Divider\", flexItem: true, orientation: \"vertical\", sx: (theme) => (Object.assign({ borderRadius: '2px', borderWidth: '2px', height: '24px', touchAction: 'none', transform: 'translateX(4px)', transition: column.getIsResizing()\n                    ? undefined\n                    : 'all 150ms ease-in-out', userSelect: 'none', zIndex: 4 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))) }) }));\n};\n\nconst MRT_TableHeadCellSortLabel = (_a) => {\n    var { header, table } = _a, rest = __rest(_a, [\"header\", \"table\"]);\n    const { getState, options: { icons: { ArrowDownwardIcon, SyncAltIcon }, localization, }, } = table;\n    const { column } = header;\n    const { columnDef } = column;\n    const { isLoading, showSkeletons, sorting } = getState();\n    const isSorted = !!column.getIsSorted();\n    const sortTooltip = isLoading || showSkeletons\n        ? ''\n        : column.getIsSorted()\n            ? column.getIsSorted() === 'desc'\n                ? localization.sortedByColumnDesc.replace('{column}', columnDef.header)\n                : localization.sortedByColumnAsc.replace('{column}', columnDef.header)\n            : column.getNextSortingOrder() === 'desc'\n                ? localization.sortByColumnDesc.replace('{column}', columnDef.header)\n                : localization.sortByColumnAsc.replace('{column}', columnDef.header);\n    const direction = isSorted\n        ? column.getIsSorted()\n        : undefined;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { placement: \"top\", title: sortTooltip, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Badge__WEBPACK_IMPORTED_MODULE_76__[\"default\"], { badgeContent: sorting.length > 1 ? column.getSortIndex() + 1 : 0, overlap: \"circular\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableSortLabel__WEBPACK_IMPORTED_MODULE_77__[\"default\"], Object.assign({ IconComponent: !isSorted\n                    ? (props) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SyncAltIcon, Object.assign({}, props, { direction: direction, style: {\n                            transform: 'rotate(-90deg) scaleX(0.9) translateX(-1px)',\n                        } })))\n                    : ArrowDownwardIcon, active: true, \"aria-label\": sortTooltip, direction: direction, onClick: (e) => {\n                    var _a;\n                    e.stopPropagation();\n                    (_a = header.column.getToggleSortingHandler()) === null || _a === void 0 ? void 0 : _a(e);\n                } }, rest, { sx: (theme) => (Object.assign({ '.MuiTableSortLabel-icon': {\n                        color: `${theme.palette.mode === 'dark'\n                            ? theme.palette.text.primary\n                            : theme.palette.text.secondary} !important`,\n                    }, flex: '0 0', opacity: isSorted ? 1 : 0.3, transition: 'all 150ms ease-in-out', width: '3ch' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))) })) }) }));\n};\n\nconst MRT_TableHeadCell = (_a) => {\n    var _b, _c, _d, _f, _g, _h, _j;\n    var { columnVirtualizer, header, staticColumnIndex, table } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"header\", \"staticColumnIndex\", \"table\"]);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    const { getState, options: { columnFilterDisplayMode, columnResizeDirection, columnResizeMode, enableKeyboardShortcuts, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableColumnPinning, enableGrouping, enableMultiSort, layoutMode, mrtTheme: { draggingBorderColor }, muiTableHeadCellProps, }, refs: { tableHeadCellRefs }, setHoveredColumn, } = table;\n    const { columnSizingInfo, density, draggingColumn, grouping, hoveredColumn, showColumnFilters, } = getState();\n    const { column } = header;\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadCellProps, { column, table })), parseFromValuesOrFunc(columnDef.muiTableHeadCellProps, {\n        column,\n        table,\n    })), rest);\n    const isColumnPinned = enableColumnPinning &&\n        columnDef.columnDefType !== 'group' &&\n        column.getIsPinned();\n    const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) &&\n        columnDef.enableColumnActions !== false;\n    const showDragHandle = enableColumnDragging !== false &&\n        columnDef.enableColumnDragging !== false &&\n        (enableColumnDragging ||\n            (enableColumnOrdering && columnDef.enableColumnOrdering !== false) ||\n            (enableGrouping &&\n                columnDef.enableGrouping !== false &&\n                !grouping.includes(column.id)));\n    const headerPL = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        let pl = 0;\n        if (column.getCanSort())\n            pl += 1;\n        if (showColumnActions)\n            pl += 1.75;\n        if (showDragHandle)\n            pl += 1.5;\n        return pl;\n    }, [showColumnActions, showDragHandle]);\n    const draggingBorders = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const showResizeBorder = columnSizingInfo.isResizingColumn === column.id &&\n            columnResizeMode === 'onChange' &&\n            !header.subHeaders.length;\n        const borderStyle = showResizeBorder\n            ? `2px solid ${draggingBorderColor} !important`\n            : (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id\n                ? `1px dashed ${theme.palette.grey[500]}`\n                : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id\n                    ? `2px dashed ${draggingBorderColor}`\n                    : undefined;\n        if (showResizeBorder) {\n            return columnResizeDirection === 'ltr'\n                ? { borderRight: borderStyle }\n                : { borderLeft: borderStyle };\n        }\n        const draggingBorders = borderStyle\n            ? {\n                borderLeft: borderStyle,\n                borderRight: borderStyle,\n                borderTop: borderStyle,\n            }\n            : undefined;\n        return draggingBorders;\n    }, [draggingColumn, hoveredColumn, columnSizingInfo.isResizingColumn]);\n    const handleDragEnter = (_e) => {\n        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {\n            setHoveredColumn(null);\n        }\n        if (enableColumnOrdering && draggingColumn && columnDefType !== 'group') {\n            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);\n        }\n    };\n    const handleDragOver = (e) => {\n        if (columnDef.enableColumnOrdering !== false) {\n            e.preventDefault();\n        }\n    };\n    const handleKeyDown = (event) => {\n        var _a;\n        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);\n        cellKeyboardShortcuts({\n            event,\n            cellValue: header.column.columnDef.header,\n            table,\n            header,\n        });\n    };\n    const HeaderElement = (_b = parseFromValuesOrFunc(columnDef.Header, {\n        column,\n        header,\n        table,\n    })) !== null && _b !== void 0 ? _b : columnDef.header;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_TableCell__WEBPACK_IMPORTED_MODULE_56__[\"default\"], Object.assign({ align: columnDefType === 'group'\n            ? 'center'\n            : theme.direction === 'rtl'\n                ? 'right'\n                : 'left', \"aria-sort\": column.getIsSorted()\n            ? column.getIsSorted() === 'asc'\n                ? 'ascending'\n                : 'descending'\n            : 'none', colSpan: header.colSpan, \"data-can-sort\": column.getCanSort() || undefined, \"data-index\": staticColumnIndex, \"data-pinned\": !!isColumnPinned || undefined, \"data-sort\": column.getIsSorted() || undefined, onDragEnter: handleDragEnter, onDragOver: handleDragOver, ref: (node) => {\n            var _a;\n            if (node) {\n                tableHeadCellRefs.current[column.id] = node;\n                if (columnDefType !== 'group') {\n                    (_a = columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement) === null || _a === void 0 ? void 0 : _a.call(columnVirtualizer, node);\n                }\n            }\n        }, tabIndex: enableKeyboardShortcuts ? 0 : undefined }, tableCellProps, { onKeyDown: handleKeyDown, sx: (theme) => (Object.assign(Object.assign({ '& :hover': {\n                '.MuiButtonBase-root': {\n                    opacity: 1,\n                },\n            }, flexDirection: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'column' : undefined, fontWeight: 'bold', overflow: 'visible', p: density === 'compact'\n                ? '0.5rem'\n                : density === 'comfortable'\n                    ? columnDefType === 'display'\n                        ? '0.75rem'\n                        : '1rem'\n                    : columnDefType === 'display'\n                        ? '1rem 1.25rem'\n                        : '1.5rem', pb: columnDefType === 'display'\n                ? 0\n                : showColumnFilters || density === 'compact'\n                    ? '0.4rem'\n                    : '0.6rem', pt: columnDefType === 'group' || density === 'compact'\n                ? '0.25rem'\n                : density === 'comfortable'\n                    ? '.75rem'\n                    : '1.25rem', userSelect: enableMultiSort && column.getCanSort() ? 'none' : undefined, verticalAlign: 'top' }, getCommonMRTCellStyles({\n            column,\n            header,\n            table,\n            tableCellProps,\n            theme,\n        })), draggingBorders)), children: [header.isPlaceholder\n                ? null\n                : ((_c = tableCellProps.children) !== null && _c !== void 0 ? _c : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { className: \"Mui-TableHeadCell-Content\", sx: {\n                        alignItems: 'center',\n                        display: 'flex',\n                        flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',\n                        justifyContent: columnDefType === 'group' ||\n                            (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center'\n                            ? 'center'\n                            : column.getCanResize()\n                                ? 'space-between'\n                                : 'flex-start',\n                        position: 'relative',\n                        width: '100%',\n                    }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { className: \"Mui-TableHeadCell-Content-Labels\", onClick: column.getToggleSortingHandler(), sx: {\n                                alignItems: 'center',\n                                cursor: column.getCanSort() && columnDefType !== 'group'\n                                    ? 'pointer'\n                                    : undefined,\n                                display: 'flex',\n                                flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',\n                                overflow: columnDefType === 'data' ? 'hidden' : undefined,\n                                pl: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center'\n                                    ? `${headerPL}rem`\n                                    : undefined,\n                            }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { className: \"Mui-TableHeadCell-Content-Wrapper\", sx: {\n                                        '&:hover': {\n                                            textOverflow: 'clip',\n                                        },\n                                        minWidth: `${Math.min((_f = (_d = columnDef.header) === null || _d === void 0 ? void 0 : _d.length) !== null && _f !== void 0 ? _f : 0, 4)}ch`,\n                                        overflow: columnDefType === 'data' ? 'hidden' : undefined,\n                                        textOverflow: 'ellipsis',\n                                        whiteSpace: ((_h = (_g = columnDef.header) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0) < 20\n                                            ? 'nowrap'\n                                            : 'normal',\n                                    }, children: HeaderElement }), column.getCanFilter() && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellFilterLabel, { header: header, table: table })), column.getCanSort() && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellSortLabel, { header: header, table: table }))] }), columnDefType !== 'group' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { className: \"Mui-TableHeadCell-Content-Actions\", sx: {\n                                whiteSpace: 'nowrap',\n                            }, children: [showDragHandle && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellGrabHandle, { column: column, table: table, tableHeadCellRef: {\n                                        current: (_j = tableHeadCellRefs.current) === null || _j === void 0 ? void 0 : _j[column.id],\n                                    } })), showColumnActions && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellColumnActionsButton, { header: header, table: table }))] })), column.getCanResize() && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellResizeHandle, { header: header, table: table }))] }))), columnFilterDisplayMode === 'subheader' && column.getCanFilter() && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCellFilterContainer, { header: header, table: table }))] })));\n};\n\nconst MRT_TableHeadRow = (_a) => {\n    var { columnVirtualizer, headerGroup, table } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"headerGroup\", \"table\"]);\n    const { options: { enableStickyHeader, layoutMode, mrtTheme: { baseBackgroundColor }, muiTableHeadRowProps, }, } = table;\n    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};\n    const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadRowProps, {\n        headerGroup,\n        table,\n    })), rest);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_TableRow__WEBPACK_IMPORTED_MODULE_58__[\"default\"], Object.assign({}, tableRowProps, { sx: (theme) => (Object.assign({ backgroundColor: baseBackgroundColor, boxShadow: `4px 0 8px ${(0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(theme.palette.common.black, 0.1)}`, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'flex' : undefined, position: enableStickyHeader && layoutMode === 'semantic'\n                ? 'sticky'\n                : 'relative', top: 0 }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme))), children: [virtualPaddingLeft ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"th\", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader, staticColumnIndex) => {\n                let header = headerOrVirtualHeader;\n                if (columnVirtualizer) {\n                    staticColumnIndex = headerOrVirtualHeader\n                        .index;\n                    header = headerGroup.headers[staticColumnIndex];\n                }\n                return header ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadCell, { columnVirtualizer: columnVirtualizer, header: header, staticColumnIndex: staticColumnIndex, table: table }, header.id)) : null;\n            }), virtualPaddingRight ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"th\", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })));\n};\n\nconst MRT_ToolbarAlertBanner = (_a) => {\n    var _b, _c, _d;\n    var { stackAlertBanner, table } = _a, rest = __rest(_a, [\"stackAlertBanner\", \"table\"]);\n    const { getFilteredSelectedRowModel, getCoreRowModel, getState, options: { enableRowSelection, enableSelectAll, localization, manualPagination, muiToolbarAlertBannerChipProps, muiToolbarAlertBannerProps, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount, }, refs: { tablePaperRef }, } = table;\n    const { density, grouping, rowSelection, showAlertBanner } = getState();\n    const alertProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiToolbarAlertBannerProps, {\n        table,\n    })), rest);\n    const chipProps = parseFromValuesOrFunc(muiToolbarAlertBannerChipProps, {\n        table,\n    });\n    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getCoreRowModel().rows.length;\n    const filteredRowCount = getFilteredSelectedRowModel().rows.length;\n    const selectedRowCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => manualPagination\n        ? Object.values(rowSelection).filter(Boolean).length\n        : filteredRowCount, [rowSelection, totalRowCount, manualPagination, filteredRowCount]);\n    const selectedAlert = selectedRowCount > 0 ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Stack__WEBPACK_IMPORTED_MODULE_16__[\"default\"], { alignItems: \"center\", direction: \"row\", gap: \"16px\", children: [(_c = (_b = localization.selectedCountOfRowCountRowsSelected) === null || _b === void 0 ? void 0 : _b.replace('{selectedCount}', selectedRowCount.toLocaleString(localization.language))) === null || _c === void 0 ? void 0 : _c.replace('{rowCount}', totalRowCount.toLocaleString(localization.language)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { onClick: (event) => getMRT_SelectAllHandler({ table })(event, false, true), size: \"small\", sx: { p: '2px' }, children: localization.clearSelection })] })) : null;\n    const groupedAlert = grouping.length > 0 ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { children: [localization.groupedBy, ' ', grouping.map((columnId, index) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [index > 0 ? localization.thenBy : '', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Chip__WEBPACK_IMPORTED_MODULE_66__[\"default\"], Object.assign({ label: table.getColumn(columnId).columnDef.header, onDelete: () => table.getColumn(columnId).toggleGrouping() }, chipProps))] }, `${index}-${columnId}`)))] })) : null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Collapse__WEBPACK_IMPORTED_MODULE_59__[\"default\"], { in: showAlertBanner || !!selectedAlert || !!groupedAlert, timeout: stackAlertBanner ? 200 : 0, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Alert__WEBPACK_IMPORTED_MODULE_78__[\"default\"], Object.assign({ color: \"info\", icon: false }, alertProps, { sx: (theme) => {\n                var _a, _b;\n                return (Object.assign({ '& .MuiAlert-message': {\n                        maxWidth: `calc(${(_b = (_a = tablePaperRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 360}px - 1rem)`,\n                        width: '100%',\n                    }, borderRadius: 0, fontSize: '1rem', left: 0, mb: stackAlertBanner\n                        ? 0\n                        : positionToolbarAlertBanner === 'bottom'\n                            ? '-1rem'\n                            : undefined, p: 0, position: 'relative', right: 0, top: 0, width: '100%', zIndex: 2 }, parseFromValuesOrFunc(alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx, theme)));\n            }, children: (_d = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({\n                groupedAlert,\n                selectedAlert,\n                table,\n            })) !== null && _d !== void 0 ? _d : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(alertProps === null || alertProps === void 0 ? void 0 : alertProps.title) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_AlertTitle__WEBPACK_IMPORTED_MODULE_79__[\"default\"], { children: alertProps.title }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Stack__WEBPACK_IMPORTED_MODULE_16__[\"default\"], { sx: {\n                            p: positionToolbarAlertBanner !== 'head-overlay'\n                                ? '0.5rem 1rem'\n                                : density === 'spacious'\n                                    ? '0.75rem 1.25rem'\n                                    : density === 'comfortable'\n                                        ? '0.5rem 0.75rem'\n                                        : '0.25rem 0.5rem',\n                        }, children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"br\", {})), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { display: 'flex' }, children: [enableRowSelection &&\n                                        enableSelectAll &&\n                                        positionToolbarAlertBanner === 'head-overlay' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_SelectCheckbox, { table: table })), ' ', selectedAlert] }), selectedAlert && groupedAlert && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"br\", {}), groupedAlert] })] })) })) }));\n};\n\nconst MRT_TableHead = (_a) => {\n    var { columnVirtualizer, table } = _a, rest = __rest(_a, [\"columnVirtualizer\", \"table\"]);\n    const { getState, options: { enableStickyHeader, layoutMode, muiTableHeadProps, positionToolbarAlertBanner, }, refs: { tableHeadRef }, } = table;\n    const { isFullScreen, showAlertBanner } = getState();\n    const tableHeadProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadProps, { table })), rest);\n    const stickyHeader = enableStickyHeader || isFullScreen;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TableHead__WEBPACK_IMPORTED_MODULE_80__[\"default\"], Object.assign({}, tableHeadProps, { ref: (ref) => {\n            tableHeadRef.current = ref;\n            if (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.ref) {\n                // @ts-expect-error\n                tableHeadProps.ref.current = ref;\n            }\n        }, sx: (theme) => (Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, opacity: 0.97, position: stickyHeader ? 'sticky' : 'relative', top: stickyHeader && (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 0 : undefined, zIndex: stickyHeader ? 2 : undefined }, parseFromValuesOrFunc(tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx, theme))), children: positionToolbarAlertBanner === 'head-overlay' &&\n            (showAlertBanner || table.getSelectedRowModel().rows.length > 0) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"tr\", { style: {\n                display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n            }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"th\", { colSpan: table.getVisibleLeafColumns().length, style: {\n                    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined,\n                    padding: 0,\n                }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToolbarAlertBanner, { table: table }) }) })) : (table\n            .getHeaderGroups()\n            .map((headerGroup) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHeadRow, { columnVirtualizer: columnVirtualizer, headerGroup: headerGroup, table: table }, headerGroup.id)))) })));\n};\n\nconst MRT_Table = (_a) => {\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getFlatHeaders, getState, options: { columns, enableStickyHeader, enableTableFooter, enableTableHead, layoutMode, memoMode, muiTableProps, renderCaption, }, } = table;\n    const { columnSizing, columnSizingInfo, columnVisibility, isFullScreen } = getState();\n    const tableProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableProps, { table })), rest);\n    const Caption = parseFromValuesOrFunc(renderCaption, { table });\n    const columnSizeVars = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const headers = getFlatHeaders();\n        const colSizes = {};\n        for (let i = 0; i < headers.length; i++) {\n            const header = headers[i];\n            const colSize = header.getSize();\n            colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;\n            colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;\n        }\n        return colSizes;\n    }, [columns, columnSizing, columnSizingInfo, columnVisibility]);\n    const columnVirtualizer = useMRT_ColumnVirtualizer(table);\n    const commonTableGroupProps = {\n        columnVirtualizer,\n        table,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Table__WEBPACK_IMPORTED_MODULE_81__[\"default\"], Object.assign({ stickyHeader: enableStickyHeader || isFullScreen }, tableProps, { style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style), sx: (theme) => (Object.assign({ borderCollapse: 'separate', display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, position: 'relative' }, parseFromValuesOrFunc(tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx, theme))), children: [!!Caption && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"caption\", { children: Caption }), enableTableHead && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableHead, Object.assign({}, commonTableGroupProps)), memoMode === 'table-body' || columnSizingInfo.isResizingColumn ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Memo_MRT_TableBody, Object.assign({}, commonTableGroupProps))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableBody, Object.assign({}, commonTableGroupProps))), enableTableFooter && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableFooter, Object.assign({}, commonTableGroupProps))] })));\n};\n\nconst MRT_TableLoadingOverlay = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { options: { id, localization, mrtTheme: { baseBackgroundColor }, muiCircularProgressProps, }, } = table;\n    const circularProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCircularProgressProps, { table })), rest);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n            alignItems: 'center',\n            backgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(baseBackgroundColor, 0.5),\n            bottom: 0,\n            display: 'flex',\n            justifyContent: 'center',\n            left: 0,\n            maxHeight: '100vh',\n            position: 'absolute',\n            right: 0,\n            top: 0,\n            width: '100%',\n            zIndex: 3,\n        }, children: (_b = circularProgressProps === null || circularProgressProps === void 0 ? void 0 : circularProgressProps.Component) !== null && _b !== void 0 ? _b : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_CircularProgress__WEBPACK_IMPORTED_MODULE_9__[\"default\"], Object.assign({ \"aria-label\": localization.noRecordsToDisplay, id: `mrt-progress-${id}` }, circularProgressProps))) }));\n};\n\nconst MRT_CellActionMenu = (_a) => {\n    var _b, _c;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { editDisplayMode, enableClickToCopy, enableEditing, icons: { ContentCopy, EditIcon }, localization, mrtTheme: { menuBackgroundColor }, renderCellActionMenuItems, }, refs: { actionCellRef }, } = table;\n    const { actionCell, density } = getState();\n    const cell = actionCell;\n    const { row } = cell;\n    const { column } = cell;\n    const { columnDef } = column;\n    const handleClose = (event) => {\n        event === null || event === void 0 ? void 0 : event.stopPropagation();\n        table.setActionCell(null);\n        actionCellRef.current = null;\n    };\n    const internalMenuItems = [\n        (parseFromValuesOrFunc(enableClickToCopy, cell) === 'context-menu' ||\n            parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) ===\n                'context-menu') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ContentCopy, {}), label: localization.copy, onClick: (event) => {\n                event.stopPropagation();\n                navigator.clipboard.writeText(cell.getValue());\n                handleClose();\n            }, table: table }, 'mrt-copy')),\n        parseFromValuesOrFunc(enableEditing, row) && editDisplayMode === 'cell' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ActionMenuItem, { icon: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditIcon, {}), label: localization.edit, onClick: () => {\n                openEditingCell({ cell, table });\n                handleClose();\n            }, table: table }, 'mrt-edit')),\n    ].filter(Boolean);\n    const renderActionProps = {\n        cell,\n        closeMenu: handleClose,\n        column,\n        internalMenuItems,\n        row,\n        table,\n    };\n    const menuItems = (_c = (_b = columnDef.renderCellActionMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, renderActionProps)) !== null && _c !== void 0 ? _c : renderCellActionMenuItems === null || renderCellActionMenuItems === void 0 ? void 0 : renderCellActionMenuItems(renderActionProps);\n    return ((!!(menuItems === null || menuItems === void 0 ? void 0 : menuItems.length) || !!(internalMenuItems === null || internalMenuItems === void 0 ? void 0 : internalMenuItems.length)) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Menu__WEBPACK_IMPORTED_MODULE_14__[\"default\"], Object.assign({ MenuListProps: {\n            dense: density === 'compact',\n            sx: {\n                backgroundColor: menuBackgroundColor,\n            },\n        }, anchorEl: actionCellRef.current, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: handleClose, open: !!cell, transformOrigin: { horizontal: -100, vertical: 8 } }, rest, { children: menuItems !== null && menuItems !== void 0 ? menuItems : internalMenuItems }))));\n};\n\nconst MRT_EditRowModal = (_a) => {\n    var _b;\n    var { open, table } = _a, rest = __rest(_a, [\"open\", \"table\"]);\n    const { getState, options: { localization, muiCreateRowModalProps, muiEditRowDialogProps, onCreatingRowCancel, onEditingRowCancel, renderCreateRowDialogContent, renderEditRowDialogContent, }, setCreatingRow, setEditingRow, } = table;\n    const { creatingRow, editingRow } = getState();\n    const row = (creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow);\n    const dialogProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditRowDialogProps, { row, table })), (creatingRow &&\n        parseFromValuesOrFunc(muiCreateRowModalProps, { row, table }))), rest);\n    const internalEditComponents = row\n        .getAllCells()\n        .filter((cell) => cell.column.columnDef.columnDefType === 'data')\n        .map((cell) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_EditCellTextField, { cell: cell, table: table }, cell.id)));\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Dialog__WEBPACK_IMPORTED_MODULE_82__[\"default\"], Object.assign({ fullWidth: true, maxWidth: \"xs\", onClose: (event, reason) => {\n            var _a;\n            if (creatingRow) {\n                onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });\n                setCreatingRow(null);\n            }\n            else {\n                onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });\n                setEditingRow(null);\n            }\n            row._valuesCache = {}; //reset values cache\n            (_a = dialogProps.onClose) === null || _a === void 0 ? void 0 : _a.call(dialogProps, event, reason);\n        }, open: open }, dialogProps, { children: (_b = ((creatingRow &&\n            (renderCreateRowDialogContent === null || renderCreateRowDialogContent === void 0 ? void 0 : renderCreateRowDialogContent({\n                internalEditComponents,\n                row,\n                table,\n            }))) ||\n            (renderEditRowDialogContent === null || renderEditRowDialogContent === void 0 ? void 0 : renderEditRowDialogContent({\n                internalEditComponents,\n                row,\n                table,\n            })))) !== null && _b !== void 0 ? _b : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_DialogTitle__WEBPACK_IMPORTED_MODULE_83__[\"default\"], { sx: { textAlign: 'center' }, children: localization.edit }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_DialogContent__WEBPACK_IMPORTED_MODULE_84__[\"default\"], { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"form\", { onSubmit: (e) => e.preventDefault(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Stack__WEBPACK_IMPORTED_MODULE_16__[\"default\"], { sx: {\n                                gap: '32px',\n                                paddingTop: '16px',\n                                width: '100%',\n                            }, children: internalEditComponents }) }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_DialogActions__WEBPACK_IMPORTED_MODULE_85__[\"default\"], { sx: { p: '1.25rem' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_EditActionButtons, { row: row, table: table, variant: \"text\" }) })] })) })));\n};\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nconst MRT_TableContainer = (_a) => {\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { createDisplayMode, editDisplayMode, enableCellActions, enableStickyHeader, muiTableContainerProps, }, refs: { bottomToolbarRef, tableContainerRef, topToolbarRef }, } = table;\n    const { actionCell, creatingRow, editingRow, isFullScreen, isLoading, showLoadingOverlay, } = getState();\n    const loading = showLoadingOverlay !== false && (isLoading || showLoadingOverlay);\n    const [totalToolbarHeight, setTotalToolbarHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const tableContainerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableContainerProps, {\n        table,\n    })), rest);\n    useIsomorphicLayoutEffect(() => {\n        var _a, _b, _c, _d;\n        const topToolbarHeight = typeof document !== 'undefined'\n            ? ((_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0)\n            : 0;\n        const bottomToolbarHeight = typeof document !== 'undefined'\n            ? ((_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0)\n            : 0;\n        setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);\n    });\n    const createModalOpen = createDisplayMode === 'modal' && creatingRow;\n    const editModalOpen = editDisplayMode === 'modal' && editingRow;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_TableContainer__WEBPACK_IMPORTED_MODULE_86__[\"default\"], Object.assign({ \"aria-busy\": loading, \"aria-describedby\": loading ? 'mrt-progress' : undefined }, tableContainerProps, { ref: (node) => {\n            if (node) {\n                tableContainerRef.current = node;\n                if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {\n                    //@ts-expect-error\n                    tableContainerProps.ref.current = node;\n                }\n            }\n        }, style: Object.assign({ maxHeight: isFullScreen\n                ? `calc(100vh - ${totalToolbarHeight}px)`\n                : undefined }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style), sx: (theme) => (Object.assign({ maxHeight: enableStickyHeader\n                ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)`\n                : undefined, maxWidth: '100%', overflow: 'auto', position: 'relative' }, parseFromValuesOrFunc(tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx, theme))), children: [loading ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableLoadingOverlay, { table: table }) : null, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_Table, { table: table }), (createModalOpen || editModalOpen) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_EditRowModal, { open: true, table: table })), enableCellActions && actionCell && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_CellActionMenu, { table: table })] })));\n};\n\nconst MRT_LinearProgressBar = (_a) => {\n    var { isTopToolbar, table } = _a, rest = __rest(_a, [\"isTopToolbar\", \"table\"]);\n    const { getState, options: { muiLinearProgressProps }, } = table;\n    const { isSaving, showProgressBars } = getState();\n    const linearProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiLinearProgressProps, {\n        isTopToolbar,\n        table,\n    })), rest);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Collapse__WEBPACK_IMPORTED_MODULE_59__[\"default\"], { in: showProgressBars !== false && (showProgressBars || isSaving), mountOnEnter: true, sx: {\n            bottom: isTopToolbar ? 0 : undefined,\n            position: 'absolute',\n            top: !isTopToolbar ? 0 : undefined,\n            width: '100%',\n        }, unmountOnExit: true, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_LinearProgress__WEBPACK_IMPORTED_MODULE_87__[\"default\"], Object.assign({ \"aria-busy\": \"true\", \"aria-label\": \"Loading\", sx: { position: 'relative' } }, linearProgressProps)) }));\n};\n\nconst defaultRowsPerPage = [5, 10, 15, 20, 25, 30, 50, 100];\nconst MRT_TablePagination = (_a) => {\n    var { position = 'bottom', table } = _a, rest = __rest(_a, [\"position\", \"table\"]);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    const isMobile = (0,_mui_material_useMediaQuery__WEBPACK_IMPORTED_MODULE_88__[\"default\"])('(max-width: 720px)');\n    const { getState, options: { enableToolbarInternalActions, icons: { ChevronLeftIcon, ChevronRightIcon, FirstPageIcon, LastPageIcon }, id, localization, muiPaginationProps, paginationDisplayMode, }, } = table;\n    const { pagination: { pageIndex = 0, pageSize = 10 }, } = getState();\n    const paginationProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiPaginationProps, {\n        table,\n    })), rest);\n    const totalRowCount = table.getRowCount();\n    const numberOfPages = table.getPageCount();\n    const showFirstLastPageButtons = numberOfPages > 2;\n    const firstRowIndex = pageIndex * pageSize;\n    const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);\n    const _b = paginationProps !== null && paginationProps !== void 0 ? paginationProps : {}, { SelectProps = {}, disabled = false, rowsPerPageOptions = defaultRowsPerPage, showFirstButton = showFirstLastPageButtons, showLastButton = showFirstLastPageButtons, showRowsPerPage = true } = _b, restPaginationProps = __rest(_b, [\"SelectProps\", \"disabled\", \"rowsPerPageOptions\", \"showFirstButton\", \"showLastButton\", \"showRowsPerPage\"]);\n    const disableBack = pageIndex <= 0 || disabled;\n    const disableNext = lastRowIndex >= totalRowCount || disabled;\n    if (isMobile && (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) !== false) {\n        SelectProps.native = true;\n    }\n    const tooltipProps = getCommonTooltipProps();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { className: \"MuiTablePagination-root\", sx: {\n            alignItems: 'center',\n            display: 'flex',\n            flexWrap: 'wrap',\n            gap: '8px',\n            justifyContent: { md: 'space-between', sm: 'center' },\n            justifySelf: 'flex-end',\n            mt: position === 'top' && enableToolbarInternalActions\n                ? '3rem'\n                : undefined,\n            position: 'relative',\n            px: '8px',\n            py: '12px',\n            zIndex: 2,\n        }, children: [showRowsPerPage && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { alignItems: 'center', display: 'flex', gap: '8px' }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_InputLabel__WEBPACK_IMPORTED_MODULE_89__[\"default\"], { htmlFor: `mrt-rows-per-page-${id}`, sx: { mb: 0 }, children: localization.rowsPerPage }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Select__WEBPACK_IMPORTED_MODULE_90__[\"default\"], Object.assign({ MenuProps: { disableScrollLock: true }, disableUnderline: true, disabled: disabled, inputProps: {\n                            'aria-label': localization.rowsPerPage,\n                            id: `mrt-rows-per-page-${id}`,\n                        }, label: localization.rowsPerPage, onChange: (event) => table.setPageSize(+event.target.value), sx: { mb: 0 }, value: pageSize, variant: \"standard\" }, SelectProps, { children: rowsPerPageOptions.map((option) => {\n                            var _a;\n                            const value = typeof option !== 'number' ? option.value : option;\n                            const label = typeof option !== 'number' ? option.label : `${option}`;\n                            return ((_a = SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.children) !== null && _a !== void 0 ? _a : ((SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"option\", { value: value, children: label }, value)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__[\"default\"], { sx: { m: 0 }, value: value, children: label }, value))));\n                        }) }))] })), paginationDisplayMode === 'pages' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Pagination__WEBPACK_IMPORTED_MODULE_91__[\"default\"], Object.assign({ count: numberOfPages, disabled: disabled, onChange: (_e, newPageIndex) => table.setPageIndex(newPageIndex - 1), page: pageIndex + 1, renderItem: (item) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_PaginationItem__WEBPACK_IMPORTED_MODULE_92__[\"default\"], Object.assign({ slots: {\n                        first: FirstPageIcon,\n                        last: LastPageIcon,\n                        next: ChevronRightIcon,\n                        previous: ChevronLeftIcon,\n                    } }, item))), showFirstButton: showFirstButton, showLastButton: showLastButton }, restPaginationProps))) : paginationDisplayMode === 'default' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Typography__WEBPACK_IMPORTED_MODULE_61__[\"default\"], { align: \"center\", component: \"span\", sx: { m: '0 4px', minWidth: '8ch' }, variant: \"body2\", children: `${lastRowIndex === 0\n                            ? 0\n                            : (firstRowIndex + 1).toLocaleString(localization.language)}-${lastRowIndex.toLocaleString(localization.language)} ${localization.of} ${totalRowCount.toLocaleString(localization.language)}` }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { gap: \"xs\", children: [showFirstButton && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, tooltipProps, { title: localization.goToFirstPage, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.goToFirstPage, disabled: disableBack, onClick: () => table.firstPage(), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FirstPageIcon, Object.assign({}, flipIconStyles(theme))) }) }) }))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, tooltipProps, { title: localization.goToPreviousPage, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.goToPreviousPage, disabled: disableBack, onClick: () => table.previousPage(), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ChevronLeftIcon, Object.assign({}, flipIconStyles(theme))) }) }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, tooltipProps, { title: localization.goToNextPage, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.goToNextPage, disabled: disableNext, onClick: () => table.nextPage(), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ChevronRightIcon, Object.assign({}, flipIconStyles(theme))) }) }) })), showLastButton && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, tooltipProps, { title: localization.goToLastPage, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.goToLastPage, disabled: disableNext, onClick: () => table.lastPage(), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LastPageIcon, Object.assign({}, flipIconStyles(theme))) }) }) })))] })] })) : null] }));\n};\n\nconst MRT_ToolbarDropZone = (_a) => {\n    var _b, _c;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone, } = table;\n    const { draggingColumn, grouping, hoveredColumn, showToolbarDropZone } = getState();\n    const handleDragEnter = (_event) => {\n        setHoveredColumn({ id: 'drop-zone' });\n    };\n    const handleDragOver = (e) => {\n        e.preventDefault();\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (((_a = table.options.state) === null || _a === void 0 ? void 0 : _a.showToolbarDropZone) !== undefined) {\n            setShowToolbarDropZone(!!enableGrouping &&\n                !!draggingColumn &&\n                draggingColumn.columnDef.enableGrouping !== false &&\n                !grouping.includes(draggingColumn.id));\n        }\n    }, [enableGrouping, draggingColumn, grouping]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Fade__WEBPACK_IMPORTED_MODULE_93__[\"default\"], { in: showToolbarDropZone, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], Object.assign({ className: \"Mui-ToolbarDropZone\", onDragEnter: handleDragEnter, onDragOver: handleDragOver }, rest, { sx: (theme) => (Object.assign({ alignItems: 'center', backdropFilter: 'blur(4px)', backgroundColor: (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(theme.palette.info.main, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone' ? 0.2 : 0.1), border: `dashed ${theme.palette.info.main} 2px`, boxSizing: 'border-box', display: 'flex', height: '100%', justifyContent: 'center', position: 'absolute', width: '100%', zIndex: 4 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Typography__WEBPACK_IMPORTED_MODULE_61__[\"default\"], { fontStyle: \"italic\", children: localization.dropToGroupBy.replace('{column}', (_c = (_b = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _b === void 0 ? void 0 : _b.header) !== null && _c !== void 0 ? _c : '') }) })) }));\n};\n\nconst MRT_BottomToolbar = (_a) => {\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { enablePagination, muiBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions, }, refs: { bottomToolbarRef }, } = table;\n    const { isFullScreen } = getState();\n    const isMobile = (0,_mui_material_useMediaQuery__WEBPACK_IMPORTED_MODULE_88__[\"default\"])('(max-width:720px)');\n    const toolbarProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiBottomToolbarProps, { table })), rest);\n    const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], Object.assign({}, toolbarProps, { ref: (node) => {\n            if (node) {\n                bottomToolbarRef.current = node;\n                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {\n                    // @ts-expect-error\n                    toolbarProps.ref.current = node;\n                }\n            }\n        }, sx: (theme) => (Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({ table, theme })), { bottom: isFullScreen ? '0' : undefined, boxShadow: `0 1px 2px -1px ${(0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_11__.alpha)(theme.palette.grey[700], 0.5)} inset`, left: 0, position: isFullScreen ? 'fixed' : 'relative', right: 0 }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme))), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_LinearProgressBar, { isTopToolbar: false, table: table }), positionToolbarAlertBanner === 'bottom' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'bottom'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToolbarDropZone, { table: table })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                    alignItems: 'center',\n                    boxSizing: 'border-box',\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                    p: '0.5rem',\n                    width: '100%',\n                }, children: [renderBottomToolbarCustomActions ? (renderBottomToolbarCustomActions({ table })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {})), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                            display: 'flex',\n                            justifyContent: 'flex-end',\n                            position: stackAlertBanner ? 'relative' : 'absolute',\n                            right: 0,\n                            top: 0,\n                        }, children: enablePagination &&\n                            ['both', 'bottom'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TablePagination, { position: \"bottom\", table: table })) })] })] })));\n};\n\nconst MRT_ColumnPinningButtons = (_a) => {\n    var { column, table } = _a, rest = __rest(_a, [\"column\", \"table\"]);\n    const { options: { icons: { PushPinIcon }, localization, }, } = table;\n    const handlePinColumn = (pinDirection) => {\n        column.pin(pinDirection);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], Object.assign({}, rest, { sx: (theme) => (Object.assign({ minWidth: '70px', textAlign: 'center' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: column.getIsPinned() ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.unpin, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { onClick: () => handlePinColumn(false), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, {}) }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.pinToLeft, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { onClick: () => handlePinColumn('left'), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, { style: {\n                                transform: 'rotate(90deg)',\n                            } }) }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.pinToRight, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { onClick: () => handlePinColumn('right'), size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PushPinIcon, { style: {\n                                transform: 'rotate(-90deg)',\n                            } }) }) })] })) })));\n};\n\nconst MRT_ShowHideColumnsMenuItems = (_a) => {\n    var _b;\n    var { allColumns, column, hoveredColumn, isNestedColumns, setHoveredColumn, table } = _a, rest = __rest(_a, [\"allColumns\", \"column\", \"hoveredColumn\", \"isNestedColumns\", \"setHoveredColumn\", \"table\"]);\n    const { getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, mrtTheme: { draggingBorderColor }, }, setColumnOrder, setColumnPinning, } = table;\n    const { columnOrder } = getState();\n    const { columnDef } = column;\n    const { columnDefType } = columnDef;\n    const switchChecked = column.getIsVisible();\n    const handleToggleColumnHidden = (column) => {\n        var _a, _b;\n        if (columnDefType === 'group') {\n            (_b = (_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (childColumn) => {\n                childColumn.toggleVisibility(!switchChecked);\n            });\n        }\n        else {\n            column.toggleVisibility();\n        }\n    };\n    const menuItemRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleDragStart = (e) => {\n        setIsDragging(true);\n        try {\n            e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    };\n    const handleDragEnd = (_e) => {\n        setIsDragging(false);\n        setHoveredColumn(null);\n        if (hoveredColumn) {\n            const reorderedColumns = reorderColumn(column, hoveredColumn, columnOrder);\n            setColumnOrder(reorderedColumns);\n            setColumnPinning(({ left = [], right = [] }) => ({\n                left: reorderedColumns.filter(header => left.includes(header)),\n                right: reorderedColumns.filter(header => right.includes(header)),\n            }));\n        }\n    };\n    const handleDragEnter = (_e) => {\n        if (!isDragging && columnDef.enableColumnOrdering !== false) {\n            setHoveredColumn(column);\n        }\n    };\n    if (!columnDef.header || columnDef.visibleInShowHideMenu === false) {\n        return null;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_MenuItem__WEBPACK_IMPORTED_MODULE_12__[\"default\"], Object.assign({ disableRipple: true, onDragEnter: handleDragEnter, ref: menuItemRef }, rest, { sx: (theme) => (Object.assign({ alignItems: 'center', justifyContent: 'flex-start', my: 0, opacity: isDragging ? 0.5 : 1, outline: isDragging\n                        ? `2px dashed ${theme.palette.grey[500]}`\n                        : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id\n                            ? `2px dashed ${draggingBorderColor}`\n                            : 'none', outlineOffset: '-2px', pl: `${(column.depth + 0.5) * 2}rem`, py: '6px' }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                        display: 'flex',\n                        flexWrap: 'nowrap',\n                        gap: '8px',\n                    }, children: [columnDefType !== 'group' &&\n                            enableColumnOrdering &&\n                            !isNestedColumns &&\n                            (columnDef.enableColumnOrdering !== false ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { width: '28px' } }))), enableColumnPinning &&\n                            (column.getCanPin() ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ColumnPinningButtons, { column: column, table: table })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: { width: '70px' } }))), enableHiding ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_FormControlLabel__WEBPACK_IMPORTED_MODULE_63__[\"default\"], { checked: switchChecked, componentsProps: {\n                                typography: {\n                                    sx: {\n                                        mb: 0,\n                                        opacity: columnDefType !== 'display' ? 1 : 0.5,\n                                    },\n                                },\n                            }, control: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign({}, getCommonTooltipProps(), { title: localization.toggleVisibility, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Switch__WEBPACK_IMPORTED_MODULE_94__[\"default\"], {}) })), disabled: !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Typography__WEBPACK_IMPORTED_MODULE_61__[\"default\"], { sx: { alignSelf: 'center' }, children: columnDef.header }))] }) })), (_b = column.columns) === null || _b === void 0 ? void 0 : _b.map((c, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: c, hoveredColumn: hoveredColumn, isNestedColumns: isNestedColumns, setHoveredColumn: setHoveredColumn, table: table }, `${i}-${c.id}`)))] }));\n};\n\nconst MRT_ShowHideColumnsMenu = (_a) => {\n    var { anchorEl, setAnchorEl, table } = _a, rest = __rest(_a, [\"anchorEl\", \"setAnchorEl\", \"table\"]);\n    const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, initialState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, mrtTheme: { menuBackgroundColor }, }, } = table;\n    const { columnOrder, columnPinning, density } = getState();\n    const handleToggleAllColumns = (value) => {\n        getAllLeafColumns()\n            .filter((col) => col.columnDef.enableHiding !== false)\n            .forEach((col) => col.toggleVisibility(value));\n    };\n    const allColumns = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const columns = getAllColumns();\n        if (columnOrder.length > 0 &&\n            !columns.some((col) => col.columnDef.columnDefType === 'group')) {\n            return [\n                ...getLeftLeafColumns(),\n                ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),\n                ...getRightLeafColumns(),\n            ].filter(Boolean);\n        }\n        return columns;\n    }, [\n        columnOrder,\n        columnPinning,\n        getAllColumns(),\n        getCenterLeafColumns(),\n        getLeftLeafColumns(),\n        getRightLeafColumns(),\n    ]);\n    const isNestedColumns = allColumns.some((col) => col.columnDef.columnDefType === 'group');\n    const hasColumnOrderChanged = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => columnOrder.length !== initialState.columnOrder.length ||\n        !columnOrder.every((column, index) => column === initialState.columnOrder[index]), [columnOrder, initialState.columnOrder]);\n    const [hoveredColumn, setHoveredColumn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Menu__WEBPACK_IMPORTED_MODULE_14__[\"default\"], Object.assign({ MenuListProps: {\n            dense: density === 'compact',\n            sx: {\n                backgroundColor: menuBackgroundColor,\n            },\n        }, anchorEl: anchorEl, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                    p: '0.5rem',\n                    pt: 0,\n                }, children: [enableHiding && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { disabled: !getIsSomeColumnsVisible(), onClick: () => handleToggleAllColumns(false), children: localization.hideAll })), enableColumnOrdering && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options, true)), disabled: !hasColumnOrderChanged, children: localization.resetOrder })), enableColumnPinning && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), children: localization.unpinAll })), enableHiding && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Button__WEBPACK_IMPORTED_MODULE_10__[\"default\"], { disabled: getIsAllColumnsVisible(), onClick: () => handleToggleAllColumns(true), children: localization.showAll }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Divider__WEBPACK_IMPORTED_MODULE_75__[\"default\"], {}), allColumns.map((column, index) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: column, hoveredColumn: hoveredColumn, isNestedColumns: isNestedColumns, setHoveredColumn: setHoveredColumn, table: table }, `${index}-${column.id}`)))] })));\n};\n\nconst MRT_ShowHideColumnsButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { options: { icons: { ViewColumnIcon }, localization, }, } = table;\n    const [anchorEl, setAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleClick = (event) => {\n        setAnchorEl(event.currentTarget);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.showHideColumns, onClick: handleClick }, rest, { title: undefined, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ViewColumnIcon, {}) })) }), anchorEl && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ShowHideColumnsMenu, { anchorEl: anchorEl, setAnchorEl: setAnchorEl, table: table }))] }));\n};\n\nconst MRT_ToggleDensePaddingButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { DensityLargeIcon, DensityMediumIcon, DensitySmallIcon }, localization, }, setDensity, } = table;\n    const { density } = getState();\n    const handleToggleDensePadding = () => {\n        const nextDensity = density === 'comfortable'\n            ? 'compact'\n            : density === 'compact'\n                ? 'spacious'\n                : 'comfortable';\n        setDensity(nextDensity);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.toggleDensity, onClick: handleToggleDensePadding }, rest, { title: undefined, children: density === 'compact' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DensitySmallIcon, {})) : density === 'comfortable' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DensityMediumIcon, {})) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DensityLargeIcon, {})) })) }));\n};\n\nconst MRT_ToggleFiltersButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { FilterListIcon, FilterListOffIcon }, localization, }, setShowColumnFilters, } = table;\n    const { showColumnFilters } = getState();\n    const handleToggleShowFilters = () => {\n        setShowColumnFilters(!showColumnFilters);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.showHideFilters, onClick: handleToggleShowFilters }, rest, { title: undefined, children: showColumnFilters ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FilterListOffIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FilterListIcon, {}) })) }));\n};\n\nconst MRT_ToggleFullScreenButton = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { FullscreenExitIcon, FullscreenIcon }, localization, }, setIsFullScreen, } = table;\n    const { isFullScreen } = getState();\n    const [tooltipOpened, setTooltipOpened] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleToggleFullScreen = () => {\n        setTooltipOpened(false);\n        setIsFullScreen(!isFullScreen);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { open: tooltipOpened, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": localization.toggleFullScreen, onBlur: () => setTooltipOpened(false), onClick: handleToggleFullScreen, onFocus: () => setTooltipOpened(true), onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false) }, rest, { title: undefined, children: isFullScreen ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FullscreenExitIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FullscreenIcon, {}) })) }));\n};\n\nconst MRT_ToggleGlobalFilterButton = (_a) => {\n    var _b, _c;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { icons: { SearchIcon, SearchOffIcon }, localization, }, refs: { searchInputRef }, setShowGlobalFilter, } = table;\n    const { globalFilter, showGlobalFilter } = getState();\n    const handleToggleSearch = () => {\n        setShowGlobalFilter(!showGlobalFilter);\n        queueMicrotask(() => { var _a; return (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign({ \"aria-label\": (_c = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c !== void 0 ? _c : localization.showHideSearch, disabled: !!globalFilter && showGlobalFilter, onClick: handleToggleSearch }, rest, { title: undefined, children: showGlobalFilter ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SearchOffIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SearchIcon, {}) })) }));\n};\n\nconst MRT_ToolbarInternalButtons = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableColumnPinning, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, initialState, renderToolbarInternalActions, }, } = table;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], Object.assign({}, rest, { sx: (theme) => (Object.assign({ alignItems: 'center', display: 'flex', zIndex: 3 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme))), children: (_b = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({\n            table,\n        })) !== null && _b !== void 0 ? _b : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [enableFilters &&\n                    enableGlobalFilter &&\n                    !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToggleGlobalFilterButton, { table: table })), enableFilters &&\n                    enableColumnFilters &&\n                    columnFilterDisplayMode !== 'popover' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToggleFiltersButton, { table: table })), (enableHiding || enableColumnOrdering || enableColumnPinning) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ShowHideColumnsButton, { table: table })), enableDensityToggle && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToggleDensePaddingButton, { table: table })), enableFullScreenToggle && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToggleFullScreenButton, { table: table }))] })) })));\n};\n\nconst MRT_GlobalFilterTextField = (_a) => {\n    var _b;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { enableGlobalFilterModes, icons: { CloseIcon, SearchIcon }, localization, manualFiltering, muiSearchTextFieldProps, }, refs: { searchInputRef }, setGlobalFilter, } = table;\n    const { globalFilter, showGlobalFilter } = getState();\n    const textFieldProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiSearchTextFieldProps, {\n        table,\n    })), rest);\n    const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [anchorEl, setAnchorEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [searchValue, setSearchValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalFilter !== null && globalFilter !== void 0 ? globalFilter : '');\n    const handleChangeDebounced = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((0,_mui_material_utils__WEBPACK_IMPORTED_MODULE_64__[\"default\"])((event) => {\n        var _a;\n        setGlobalFilter((_a = event.target.value) !== null && _a !== void 0 ? _a : undefined);\n    }, manualFiltering ? 500 : 250), []);\n    const handleChange = (event) => {\n        setSearchValue(event.target.value);\n        handleChangeDebounced(event);\n    };\n    const handleGlobalFilterMenuOpen = (event) => {\n        setAnchorEl(event.currentTarget);\n    };\n    const handleClear = () => {\n        setSearchValue('');\n        setGlobalFilter(undefined);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (isMounted.current) {\n            if (globalFilter === undefined) {\n                handleClear();\n            }\n            else {\n                setSearchValue(globalFilter);\n            }\n        }\n        isMounted.current = true;\n    }, [globalFilter]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Collapse__WEBPACK_IMPORTED_MODULE_59__[\"default\"], { in: showGlobalFilter, mountOnEnter: true, orientation: \"horizontal\", unmountOnExit: true, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_TextField__WEBPACK_IMPORTED_MODULE_55__[\"default\"], Object.assign({ inputProps: Object.assign({ autoComplete: 'off' }, textFieldProps.inputProps), onChange: handleChange, placeholder: localization.search, size: \"small\", value: searchValue !== null && searchValue !== void 0 ? searchValue : '', variant: \"outlined\" }, textFieldProps, { InputProps: Object.assign(Object.assign({ endAdornment: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_InputAdornment__WEBPACK_IMPORTED_MODULE_65__[\"default\"], { position: \"end\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: (_b = localization.clearSearch) !== null && _b !== void 0 ? _b : '', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: \"small\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CloseIcon, {}) }) }) }) })), startAdornment: enableGlobalFilterModes ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_InputAdornment__WEBPACK_IMPORTED_MODULE_65__[\"default\"], { position: \"start\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_Tooltip__WEBPACK_IMPORTED_MODULE_7__[\"default\"], { title: localization.changeSearchMode, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_mui_material_IconButton__WEBPACK_IMPORTED_MODULE_8__[\"default\"], { \"aria-label\": localization.changeSearchMode, onClick: handleGlobalFilterMenuOpen, size: \"small\", sx: { height: '1.75rem', width: '1.75rem' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SearchIcon, {}) }) }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SearchIcon, { style: { marginRight: '4px' } })) }, textFieldProps.InputProps), { sx: (theme) => {\n                        var _a;\n                        return (Object.assign({ mb: 0 }, parseFromValuesOrFunc((_a = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a === void 0 ? void 0 : _a.sx, theme)));\n                    } }), inputRef: (inputRef) => {\n                    searchInputRef.current = inputRef;\n                    if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.inputRef) {\n                        textFieldProps.inputRef = inputRef;\n                    }\n                } })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_FilterOptionMenu, { anchorEl: anchorEl, onSelect: handleClear, setAnchorEl: setAnchorEl, table: table })] }));\n};\n\nconst MRT_TopToolbar = ({ table, }) => {\n    var _a;\n    const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, muiTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions, }, refs: { topToolbarRef }, } = table;\n    const { isFullScreen, showGlobalFilter } = getState();\n    const isMobile = (0,_mui_material_useMediaQuery__WEBPACK_IMPORTED_MODULE_88__[\"default\"])('(max-width:720px)');\n    const isTablet = (0,_mui_material_useMediaQuery__WEBPACK_IMPORTED_MODULE_88__[\"default\"])('(max-width:1024px)');\n    const toolbarProps = parseFromValuesOrFunc(muiTopToolbarProps, { table });\n    const stackAlertBanner = isMobile ||\n        !!renderTopToolbarCustomActions ||\n        (showGlobalFilter && isTablet);\n    const globalFilterProps = {\n        sx: !isTablet\n            ? {\n                zIndex: 2,\n            }\n            : undefined,\n        table,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], Object.assign({}, toolbarProps, { ref: (ref) => {\n            topToolbarRef.current = ref;\n            if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {\n                // @ts-expect-error\n                toolbarProps.ref.current = ref;\n            }\n        }, sx: (theme) => (Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({ table, theme })), { position: isFullScreen ? 'sticky' : 'relative', top: isFullScreen ? '0' : undefined }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme))), children: [positionToolbarAlertBanner === 'top' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'top'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToolbarDropZone, { table: table })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                    alignItems: 'flex-start',\n                    boxSizing: 'border-box',\n                    display: 'flex',\n                    gap: '0.5rem',\n                    justifyContent: 'space-between',\n                    p: '0.5rem',\n                    position: stackAlertBanner ? 'relative' : 'absolute',\n                    right: 0,\n                    top: 0,\n                    width: '100%',\n                }, children: [enableGlobalFilter && positionGlobalFilter === 'left' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps))), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {}), enableToolbarInternalActions ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Box__WEBPACK_IMPORTED_MODULE_6__[\"default\"], { sx: {\n                            alignItems: 'center',\n                            display: 'flex',\n                            flexWrap: 'wrap-reverse',\n                            gap: '0.5rem',\n                            justifyContent: 'flex-end',\n                        }, children: [enableGlobalFilter && positionGlobalFilter === 'right' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_ToolbarInternalButtons, { table: table })] })) : (enableGlobalFilter &&\n                        positionGlobalFilter === 'right' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps))))] }), enablePagination &&\n                ['both', 'top'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TablePagination, { position: \"top\", table: table })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_LinearProgressBar, { isTopToolbar: true, table: table })] })));\n};\n\nconst MRT_TablePaper = (_a) => {\n    var _b, _c;\n    var { table } = _a, rest = __rest(_a, [\"table\"]);\n    const { getState, options: { enableBottomToolbar, enableTopToolbar, mrtTheme: { baseBackgroundColor }, muiTablePaperProps, renderBottomToolbar, renderTopToolbar, }, refs: { tablePaperRef }, } = table;\n    const { isFullScreen } = getState();\n    const paperProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTablePaperProps, { table })), rest);\n    const theme = (0,_mui_material_styles__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_mui_material_Paper__WEBPACK_IMPORTED_MODULE_95__[\"default\"], Object.assign({ elevation: 2, onKeyDown: (e) => e.key === 'Escape' && table.setIsFullScreen(false) }, paperProps, { ref: (ref) => {\n            tablePaperRef.current = ref;\n            if (paperProps === null || paperProps === void 0 ? void 0 : paperProps.ref) {\n                //@ts-expect-error\n                paperProps.ref.current = ref;\n            }\n        }, style: Object.assign(Object.assign({}, (isFullScreen\n            ? {\n                bottom: 0,\n                height: '100dvh',\n                left: 0,\n                margin: 0,\n                maxHeight: '100dvh',\n                maxWidth: '100dvw',\n                padding: 0,\n                position: 'fixed',\n                right: 0,\n                top: 0,\n                width: '100dvw',\n                zIndex: theme.zIndex.modal,\n            }\n            : {})), paperProps === null || paperProps === void 0 ? void 0 : paperProps.style), sx: (theme) => (Object.assign({ backgroundColor: baseBackgroundColor, backgroundImage: 'unset', overflow: 'hidden', transition: 'all 100ms ease-in-out' }, parseFromValuesOrFunc(paperProps === null || paperProps === void 0 ? void 0 : paperProps.sx, theme))), children: [enableTopToolbar &&\n                ((_b = parseFromValuesOrFunc(renderTopToolbar, { table })) !== null && _b !== void 0 ? _b : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TopToolbar, { table: table }))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TableContainer, { table: table }), enableBottomToolbar &&\n                ((_c = parseFromValuesOrFunc(renderBottomToolbar, { table })) !== null && _c !== void 0 ? _c : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_BottomToolbar, { table: table })))] })));\n};\n\nconst isTableInstanceProp = (props) => props.table !== undefined;\nconst MaterialReactTable = (props) => {\n    let table;\n    if (isTableInstanceProp(props)) {\n        table = props.table;\n    }\n    else {\n        table = useMaterialReactTable(props);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MRT_TablePaper, { table: table });\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWF0ZXJpYWwtcmVhY3QtdGFibGUvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ1Y7QUFDcE07QUFDNUQ7QUFDeEI7QUFDTjtBQUNOO0FBQ1I7QUFDTTtBQUNvQjtBQUNVO0FBQ2xDO0FBQ2dCO0FBQ1I7QUFDTjtBQUNNO0FBQ047QUFDMEI7QUFDTjtBQUNSO0FBQ1U7QUFDRTtBQUNSO0FBQ047QUFDUTtBQUNNO0FBQ0U7QUFDRjtBQUNKO0FBQ0U7QUFDZDtBQUNZO0FBQ0Y7QUFDRTtBQUNNO0FBQ1I7QUFDRTtBQUNRO0FBQ2tCO0FBQzlCO0FBQ0U7QUFDRjtBQUNGO0FBQ007QUFDWjtBQUNJO0FBQ007QUFDVjtBQUNNO0FBQ007QUFDTTtBQUNjO0FBQ3hDO0FBQ2tCO0FBQ2xCO0FBQ1E7QUFDRTtBQUNKO0FBQ0E7QUFDRTtBQUNIO0FBQ0c7QUFDRjtBQUNNO0FBQ0o7QUFDYztBQUNSO0FBQ2hCO0FBQ29CO0FBQ1g7QUFDYTtBQUNRO0FBQ1I7QUFDRjtBQUNoQjtBQUNKO0FBQ007QUFDQTtBQUNKO0FBQ2tCO0FBQ2xCO0FBQ1U7QUFDUjtBQUNjO0FBQ0E7QUFDSjtBQUNJO0FBQ0U7QUFDUjtBQUNBO0FBQ1E7QUFDaEI7QUFDSjtBQUNJOztBQUUxQyxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJC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Y0FBYyxNQUFNO0FBQzdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQUcsbUJBQW1CLGNBQWM7QUFDL0M7O0FBRW12RTtBQUNudkUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcd2FuYW5cXFdvcmtzcGFjZVxcdnNjb2RlXFx0cmFkaW5nXFx3ZWJhcHBcXGNvdC10cmFkaW5nLWZyb250ZW5kXFxub2RlX21vZHVsZXNcXG1hdGVyaWFsLXJlYWN0LXRhYmxlXFxkaXN0XFxpbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmxleFJlbmRlciBhcyBmbGV4UmVuZGVyJDEsIGNyZWF0ZVJvdyBhcyBjcmVhdGVSb3ckMSwgc29ydGluZ0ZucywgYWdncmVnYXRpb25GbnMsIGZpbHRlckZucywgZ2V0Q29yZVJvd01vZGVsLCBnZXRFeHBhbmRlZFJvd01vZGVsLCBnZXRGYWNldGVkTWluTWF4VmFsdWVzLCBnZXRGYWNldGVkUm93TW9kZWwsIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMsIGdldEZpbHRlcmVkUm93TW9kZWwsIGdldEdyb3VwZWRSb3dNb2RlbCwgZ2V0UGFnaW5hdGlvblJvd01vZGVsLCBnZXRTb3J0ZWRSb3dNb2RlbCwgdXNlUmVhY3RUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC10YWJsZSc7XG5pbXBvcnQgeyB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlSWQsIHVzZVJlZHVjZXIsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgbWVtbywgRnJhZ21lbnQgYXMgRnJhZ21lbnQkMSwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29tcGFyZUl0ZW1zLCByYW5rSXRlbSwgcmFua2luZ3MgfSBmcm9tICdAdGFuc3RhY2svbWF0Y2gtc29ydGVyLXV0aWxzJztcbmltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICdAbXVpL21hdGVyaWFsL0ljb25CdXR0b24nO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnQG11aS9tYXRlcmlhbC9Ub29sdGlwJztcbmltcG9ydCBCb3ggZnJvbSAnQG11aS9tYXRlcmlhbC9Cb3gnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICdAbXVpL21hdGVyaWFsL0J1dHRvbic7XG5pbXBvcnQgQ2lyY3VsYXJQcm9ncmVzcyBmcm9tICdAbXVpL21hdGVyaWFsL0NpcmN1bGFyUHJvZ3Jlc3MnO1xuaW1wb3J0IHsgbGlnaHRlbiwgZGFya2VuLCBhbHBoYSwgdXNlVGhlbWUgfSBmcm9tICdAbXVpL21hdGVyaWFsL3N0eWxlcyc7XG5pbXBvcnQgTWVudSBmcm9tICdAbXVpL21hdGVyaWFsL01lbnUnO1xuaW1wb3J0IExpc3RJdGVtSWNvbiBmcm9tICdAbXVpL21hdGVyaWFsL0xpc3RJdGVtSWNvbic7XG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnQG11aS9tYXRlcmlhbC9NZW51SXRlbSc7XG5pbXBvcnQgU3RhY2sgZnJvbSAnQG11aS9tYXRlcmlhbC9TdGFjayc7XG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnQG11aS9tYXRlcmlhbC9DaGVja2JveCc7XG5pbXBvcnQgUmFkaW8gZnJvbSAnQG11aS9tYXRlcmlhbC9SYWRpbyc7XG5pbXBvcnQgQXJyb3dEb3dud2FyZEljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9BcnJvd0Rvd253YXJkJztcbmltcG9ydCBBcnJvd1JpZ2h0SWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL0Fycm93UmlnaHQnO1xuaW1wb3J0IENhbmNlbEljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9DYW5jZWwnO1xuaW1wb3J0IENoZXZyb25MZWZ0SWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL0NoZXZyb25MZWZ0JztcbmltcG9ydCBDaGV2cm9uUmlnaHRJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvQ2hldnJvblJpZ2h0JztcbmltcG9ydCBDbGVhckFsbEljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9DbGVhckFsbCc7XG5pbXBvcnQgQ2xvc2VJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvQ2xvc2UnO1xuaW1wb3J0IENvbnRlbnRDb3B5IGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvQ29udGVudENvcHknO1xuaW1wb3J0IERlbnNpdHlMYXJnZUljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9EZW5zaXR5TGFyZ2UnO1xuaW1wb3J0IERlbnNpdHlNZWRpdW1JY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvRGVuc2l0eU1lZGl1bSc7XG5pbXBvcnQgRGVuc2l0eVNtYWxsSWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL0RlbnNpdHlTbWFsbCc7XG5pbXBvcnQgRHJhZ0hhbmRsZUljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9EcmFnSGFuZGxlJztcbmltcG9ydCBEeW5hbWljRmVlZEljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9EeW5hbWljRmVlZCc7XG5pbXBvcnQgRWRpdEljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9FZGl0JztcbmltcG9ydCBFeHBhbmRNb3JlSWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL0V4cGFuZE1vcmUnO1xuaW1wb3J0IEZpbHRlckFsdEljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9GaWx0ZXJBbHQnO1xuaW1wb3J0IEZpbHRlckxpc3RJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvRmlsdGVyTGlzdCc7XG5pbXBvcnQgRmlsdGVyTGlzdE9mZkljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9GaWx0ZXJMaXN0T2ZmJztcbmltcG9ydCBGaXJzdFBhZ2VJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvRmlyc3RQYWdlJztcbmltcG9ydCBGdWxsc2NyZWVuSWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL0Z1bGxzY3JlZW4nO1xuaW1wb3J0IEZ1bGxzY3JlZW5FeGl0SWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL0Z1bGxzY3JlZW5FeGl0JztcbmltcG9ydCBLZXlib2FyZERvdWJsZUFycm93RG93bkljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9LZXlib2FyZERvdWJsZUFycm93RG93bic7XG5pbXBvcnQgTGFzdFBhZ2VJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvTGFzdFBhZ2UnO1xuaW1wb3J0IE1vcmVIb3Jpekljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9Nb3JlSG9yaXonO1xuaW1wb3J0IE1vcmVWZXJ0SWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL01vcmVWZXJ0JztcbmltcG9ydCBQdXNoUGluSWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL1B1c2hQaW4nO1xuaW1wb3J0IFJlc3RhcnRBbHRJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvUmVzdGFydEFsdCc7XG5pbXBvcnQgU2F2ZUljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9TYXZlJztcbmltcG9ydCBTZWFyY2hJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvU2VhcmNoJztcbmltcG9ydCBTZWFyY2hPZmZJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvU2VhcmNoT2ZmJztcbmltcG9ydCBTb3J0SWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL1NvcnQnO1xuaW1wb3J0IFN5bmNBbHRJY29uIGZyb20gJ0BtdWkvaWNvbnMtbWF0ZXJpYWwvU3luY0FsdCc7XG5pbXBvcnQgVmlld0NvbHVtbkljb24gZnJvbSAnQG11aS9pY29ucy1tYXRlcmlhbC9WaWV3Q29sdW1uJztcbmltcG9ydCBWaXNpYmlsaXR5T2ZmSWNvbiBmcm9tICdAbXVpL2ljb25zLW1hdGVyaWFsL1Zpc2liaWxpdHlPZmYnO1xuaW1wb3J0IHsgZGVmYXVsdFJhbmdlRXh0cmFjdG9yLCB1c2VWaXJ0dWFsaXplciB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC12aXJ0dWFsJztcbmltcG9ydCBQYXBlciBmcm9tICdAbXVpL21hdGVyaWFsL1BhcGVyJztcbmltcG9ydCBUYWJsZUNvbnRhaW5lciBmcm9tICdAbXVpL21hdGVyaWFsL1RhYmxlQ29udGFpbmVyJztcbmltcG9ydCBUYWJsZSBmcm9tICdAbXVpL21hdGVyaWFsL1RhYmxlJztcbmltcG9ydCBUYWJsZUJvZHkgZnJvbSAnQG11aS9tYXRlcmlhbC9UYWJsZUJvZHknO1xuaW1wb3J0IFR5cG9ncmFwaHkgZnJvbSAnQG11aS9tYXRlcmlhbC9UeXBvZ3JhcGh5JztcbmltcG9ydCBUYWJsZVJvdyBmcm9tICdAbXVpL21hdGVyaWFsL1RhYmxlUm93JztcbmltcG9ydCBTa2VsZXRvbiBmcm9tICdAbXVpL21hdGVyaWFsL1NrZWxldG9uJztcbmltcG9ydCBUYWJsZUNlbGwgZnJvbSAnQG11aS9tYXRlcmlhbC9UYWJsZUNlbGwnO1xuaW1wb3J0IGhpZ2hsaWdodFdvcmRzIGZyb20gJ2hpZ2hsaWdodC13b3Jkcyc7XG5pbXBvcnQgVGV4dEZpZWxkIGZyb20gJ0BtdWkvbWF0ZXJpYWwvVGV4dEZpZWxkJztcbmltcG9ydCBDb2xsYXBzZSBmcm9tICdAbXVpL21hdGVyaWFsL0NvbGxhcHNlJztcbmltcG9ydCBUYWJsZUZvb3RlciBmcm9tICdAbXVpL21hdGVyaWFsL1RhYmxlRm9vdGVyJztcbmltcG9ydCBUYWJsZUhlYWQgZnJvbSAnQG11aS9tYXRlcmlhbC9UYWJsZUhlYWQnO1xuaW1wb3J0IEZvcm1Db250cm9sTGFiZWwgZnJvbSAnQG11aS9tYXRlcmlhbC9Gb3JtQ29udHJvbExhYmVsJztcbmltcG9ydCBBdXRvY29tcGxldGUgZnJvbSAnQG11aS9tYXRlcmlhbC9BdXRvY29tcGxldGUnO1xuaW1wb3J0IENoaXAgZnJvbSAnQG11aS9tYXRlcmlhbC9DaGlwJztcbmltcG9ydCBJbnB1dEFkb3JubWVudCBmcm9tICdAbXVpL21hdGVyaWFsL0lucHV0QWRvcm5tZW50JztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnQG11aS9tYXRlcmlhbC91dGlscyc7XG5pbXBvcnQgeyBEYXRlUGlja2VyIH0gZnJvbSAnQG11aS94LWRhdGUtcGlja2Vycy9EYXRlUGlja2VyJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyIH0gZnJvbSAnQG11aS94LWRhdGUtcGlja2Vycy9EYXRlVGltZVBpY2tlcic7XG5pbXBvcnQgeyBUaW1lUGlja2VyIH0gZnJvbSAnQG11aS94LWRhdGUtcGlja2Vycy9UaW1lUGlja2VyJztcbmltcG9ydCBGb3JtSGVscGVyVGV4dCBmcm9tICdAbXVpL21hdGVyaWFsL0Zvcm1IZWxwZXJUZXh0JztcbmltcG9ydCBTbGlkZXIgZnJvbSAnQG11aS9tYXRlcmlhbC9TbGlkZXInO1xuaW1wb3J0IEdyb3cgZnJvbSAnQG11aS9tYXRlcmlhbC9Hcm93JztcbmltcG9ydCBQb3BvdmVyIGZyb20gJ0BtdWkvbWF0ZXJpYWwvUG9wb3Zlcic7XG5pbXBvcnQgRGl2aWRlciBmcm9tICdAbXVpL21hdGVyaWFsL0RpdmlkZXInO1xuaW1wb3J0IEJhZGdlIGZyb20gJ0BtdWkvbWF0ZXJpYWwvQmFkZ2UnO1xuaW1wb3J0IFRhYmxlU29ydExhYmVsIGZyb20gJ0BtdWkvbWF0ZXJpYWwvVGFibGVTb3J0TGFiZWwnO1xuaW1wb3J0IEFsZXJ0IGZyb20gJ0BtdWkvbWF0ZXJpYWwvQWxlcnQnO1xuaW1wb3J0IEFsZXJ0VGl0bGUgZnJvbSAnQG11aS9tYXRlcmlhbC9BbGVydFRpdGxlJztcbmltcG9ydCBEaWFsb2cgZnJvbSAnQG11aS9tYXRlcmlhbC9EaWFsb2cnO1xuaW1wb3J0IERpYWxvZ0FjdGlvbnMgZnJvbSAnQG11aS9tYXRlcmlhbC9EaWFsb2dBY3Rpb25zJztcbmltcG9ydCBEaWFsb2dDb250ZW50IGZyb20gJ0BtdWkvbWF0ZXJpYWwvRGlhbG9nQ29udGVudCc7XG5pbXBvcnQgRGlhbG9nVGl0bGUgZnJvbSAnQG11aS9tYXRlcmlhbC9EaWFsb2dUaXRsZSc7XG5pbXBvcnQgdXNlTWVkaWFRdWVyeSBmcm9tICdAbXVpL21hdGVyaWFsL3VzZU1lZGlhUXVlcnknO1xuaW1wb3J0IExpbmVhclByb2dyZXNzIGZyb20gJ0BtdWkvbWF0ZXJpYWwvTGluZWFyUHJvZ3Jlc3MnO1xuaW1wb3J0IElucHV0TGFiZWwgZnJvbSAnQG11aS9tYXRlcmlhbC9JbnB1dExhYmVsJztcbmltcG9ydCBQYWdpbmF0aW9uIGZyb20gJ0BtdWkvbWF0ZXJpYWwvUGFnaW5hdGlvbic7XG5pbXBvcnQgUGFnaW5hdGlvbkl0ZW0gZnJvbSAnQG11aS9tYXRlcmlhbC9QYWdpbmF0aW9uSXRlbSc7XG5pbXBvcnQgU2VsZWN0IGZyb20gJ0BtdWkvbWF0ZXJpYWwvU2VsZWN0JztcbmltcG9ydCBGYWRlIGZyb20gJ0BtdWkvbWF0ZXJpYWwvRmFkZSc7XG5pbXBvcnQgU3dpdGNoIGZyb20gJ0BtdWkvbWF0ZXJpYWwvU3dpdGNoJztcblxuY29uc3QgZ2V0Q29sdW1uSWQgPSAoY29sdW1uRGVmKSA9PiB7IHZhciBfYSwgX2IsIF9jLCBfZDsgcmV0dXJuIChfZCA9IChfYSA9IGNvbHVtbkRlZi5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gY29sdW1uRGVmLmFjY2Vzc29yS2V5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9TdHJpbmcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29sdW1uRGVmLmhlYWRlcjsgfTtcbmNvbnN0IGdldEFsbExlYWZDb2x1bW5EZWZzID0gKGNvbHVtbnMpID0+IHtcbiAgICBjb25zdCBhbGxMZWFmQ29sdW1uRGVmcyA9IFtdO1xuICAgIGNvbnN0IGdldExlYWZDb2x1bW5zID0gKGNvbHMpID0+IHtcbiAgICAgICAgY29scy5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2wuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIGdldExlYWZDb2x1bW5zKGNvbC5jb2x1bW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsbExlYWZDb2x1bW5EZWZzLnB1c2goY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBnZXRMZWFmQ29sdW1ucyhjb2x1bW5zKTtcbiAgICByZXR1cm4gYWxsTGVhZkNvbHVtbkRlZnM7XG59O1xuY29uc3QgcHJlcGFyZUNvbHVtbnMgPSAoeyBjb2x1bW5EZWZzLCB0YWJsZU9wdGlvbnMsIH0pID0+IHtcbiAgICBjb25zdCB7IGFnZ3JlZ2F0aW9uRm5zID0ge30sIGRlZmF1bHREaXNwbGF5Q29sdW1uLCBmaWx0ZXJGbnMgPSB7fSwgc29ydGluZ0ZucyA9IHt9LCBzdGF0ZTogeyBjb2x1bW5GaWx0ZXJGbnMgPSB7fSB9ID0ge30sIH0gPSB0YWJsZU9wdGlvbnM7XG4gICAgcmV0dXJuIGNvbHVtbkRlZnMubWFwKChjb2x1bW5EZWYpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy9hc3NpZ24gY29sdW1uSWRcbiAgICAgICAgaWYgKCFjb2x1bW5EZWYuaWQpXG4gICAgICAgICAgICBjb2x1bW5EZWYuaWQgPSBnZXRDb2x1bW5JZChjb2x1bW5EZWYpO1xuICAgICAgICAvL2Fzc2lnbiBjb2x1bW5EZWZUeXBlXG4gICAgICAgIGlmICghY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUpXG4gICAgICAgICAgICBjb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9ICdkYXRhJztcbiAgICAgICAgaWYgKChfYSA9IGNvbHVtbkRlZi5jb2x1bW5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9ICdncm91cCc7XG4gICAgICAgICAgICAvL3JlY3Vyc2l2ZWx5IHByZXBhcmUgY29sdW1ucyBpZiB0aGlzIGlzIGEgZ3JvdXAgY29sdW1uXG4gICAgICAgICAgICBjb2x1bW5EZWYuY29sdW1ucyA9IHByZXBhcmVDb2x1bW5zKHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWZzOiBjb2x1bW5EZWYuY29sdW1ucyxcbiAgICAgICAgICAgICAgICB0YWJsZU9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAvL2Fzc2lnbiBhZ2dyZWdhdGlvbkZucyBpZiBtdWx0aXBsZSBhZ2dyZWdhdGlvbkZucyBhcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZ0ZucyA9IGNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuO1xuICAgICAgICAgICAgICAgIGNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuID0gKGNvbHVtbklkLCBsZWFmUm93cywgY2hpbGRSb3dzKSA9PiBhZ2dGbnMubWFwKChmbikgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBhZ2dyZWdhdGlvbkZuc1tmbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFnZ3JlZ2F0aW9uRm5zLCBjb2x1bW5JZCwgbGVhZlJvd3MsIGNoaWxkUm93cyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9hc3NpZ24gZmlsdGVyRm5zXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyRm5zKS5pbmNsdWRlcyhjb2x1bW5GaWx0ZXJGbnNbY29sdW1uRGVmLmlkXSkpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWYuZmlsdGVyRm4gPVxuICAgICAgICAgICAgICAgICAgICAoX2IgPSBmaWx0ZXJGbnNbY29sdW1uRmlsdGVyRm5zW2NvbHVtbkRlZi5pZF1dKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmaWx0ZXJGbnMuZnV6enk7XG4gICAgICAgICAgICAgICAgY29sdW1uRGVmLl9maWx0ZXJGbiA9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkZpbHRlckZuc1tjb2x1bW5EZWYuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9hc3NpZ24gc29ydGluZ0Zuc1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNvcnRpbmdGbnMpLmluY2x1ZGVzKGNvbHVtbkRlZi5zb3J0aW5nRm4pKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGNvbHVtbkRlZi5zb3J0aW5nRm4gPSBzb3J0aW5nRm5zW2NvbHVtbkRlZi5zb3J0aW5nRm5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlID09PSAnZGlzcGxheScpIHtcbiAgICAgICAgICAgIGNvbHVtbkRlZiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERpc3BsYXlDb2x1bW4pLCBjb2x1bW5EZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5EZWY7XG4gICAgfSk7XG59O1xuY29uc3QgcmVvcmRlckNvbHVtbiA9IChkcmFnZ2VkQ29sdW1uLCB0YXJnZXRDb2x1bW4sIGNvbHVtbk9yZGVyKSA9PiB7XG4gICAgaWYgKGRyYWdnZWRDb2x1bW4uZ2V0Q2FuUGluKCkpIHtcbiAgICAgICAgZHJhZ2dlZENvbHVtbi5waW4odGFyZ2V0Q29sdW1uLmdldElzUGlubmVkKCkpO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb2x1bW5PcmRlciA9IFsuLi5jb2x1bW5PcmRlcl07XG4gICAgbmV3Q29sdW1uT3JkZXIuc3BsaWNlKG5ld0NvbHVtbk9yZGVyLmluZGV4T2YodGFyZ2V0Q29sdW1uLmlkKSwgMCwgbmV3Q29sdW1uT3JkZXIuc3BsaWNlKG5ld0NvbHVtbk9yZGVyLmluZGV4T2YoZHJhZ2dlZENvbHVtbi5pZCksIDEpWzBdKTtcbiAgICByZXR1cm4gbmV3Q29sdW1uT3JkZXI7XG59O1xuY29uc3QgZ2V0RGVmYXVsdENvbHVtbkZpbHRlckZuID0gKGNvbHVtbkRlZikgPT4ge1xuICAgIGNvbnN0IHsgZmlsdGVyVmFyaWFudCB9ID0gY29sdW1uRGVmO1xuICAgIGlmIChmaWx0ZXJWYXJpYW50ID09PSAnbXVsdGktc2VsZWN0JylcbiAgICAgICAgcmV0dXJuICdhcnJJbmNsdWRlc1NvbWUnO1xuICAgIGlmIChmaWx0ZXJWYXJpYW50ID09PSBudWxsIHx8IGZpbHRlclZhcmlhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlclZhcmlhbnQuaW5jbHVkZXMoJ3JhbmdlJykpXG4gICAgICAgIHJldHVybiAnYmV0d2VlbkluY2x1c2l2ZSc7XG4gICAgaWYgKGZpbHRlclZhcmlhbnQgPT09ICdzZWxlY3QnIHx8IGZpbHRlclZhcmlhbnQgPT09ICdjaGVja2JveCcpXG4gICAgICAgIHJldHVybiAnZXF1YWxzJztcbiAgICByZXR1cm4gJ2Z1enp5Jztcbn07XG5jb25zdCBnZXRDb2x1bW5GaWx0ZXJJbmZvID0gKHsgaGVhZGVyLCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyTW9kZU9wdGlvbnMgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGZpbHRlclZhcmlhbnQgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBpc0RhdGVGaWx0ZXIgPSAhISgoZmlsdGVyVmFyaWFudCA9PT0gbnVsbCB8fCBmaWx0ZXJWYXJpYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXJWYXJpYW50LnN0YXJ0c1dpdGgoJ2RhdGUnKSkgfHwgKGZpbHRlclZhcmlhbnQgPT09IG51bGwgfHwgZmlsdGVyVmFyaWFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyVmFyaWFudC5zdGFydHNXaXRoKCd0aW1lJykpKTtcbiAgICBjb25zdCBpc0F1dG9jb21wbGV0ZUZpbHRlciA9IGZpbHRlclZhcmlhbnQgPT09ICdhdXRvY29tcGxldGUnO1xuICAgIGNvbnN0IGlzUmFuZ2VGaWx0ZXIgPSAoZmlsdGVyVmFyaWFudCA9PT0gbnVsbCB8fCBmaWx0ZXJWYXJpYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXJWYXJpYW50LmluY2x1ZGVzKCdyYW5nZScpKSB8fFxuICAgICAgICBbJ2JldHdlZW4nLCAnYmV0d2VlbkluY2x1c2l2ZScsICdpbk51bWJlclJhbmdlJ10uaW5jbHVkZXMoY29sdW1uRGVmLl9maWx0ZXJGbik7XG4gICAgY29uc3QgaXNTZWxlY3RGaWx0ZXIgPSBmaWx0ZXJWYXJpYW50ID09PSAnc2VsZWN0JztcbiAgICBjb25zdCBpc011bHRpU2VsZWN0RmlsdGVyID0gZmlsdGVyVmFyaWFudCA9PT0gJ211bHRpLXNlbGVjdCc7XG4gICAgY29uc3QgaXNUZXh0Ym94RmlsdGVyID0gWydhdXRvY29tcGxldGUnLCAndGV4dCddLmluY2x1ZGVzKGZpbHRlclZhcmlhbnQpIHx8XG4gICAgICAgICghaXNTZWxlY3RGaWx0ZXIgJiYgIWlzTXVsdGlTZWxlY3RGaWx0ZXIpO1xuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJPcHRpb24gPSBjb2x1bW5EZWYuX2ZpbHRlckZuO1xuICAgIGNvbnN0IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID0gKF9hID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmNvbHVtbkZpbHRlck1vZGVPcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2x1bW5GaWx0ZXJNb2RlT3B0aW9ucztcbiAgICBjb25zdCBmYWNldGVkVW5pcXVlVmFsdWVzID0gY29sdW1uLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyxcbiAgICAgICAgY3VycmVudEZpbHRlck9wdGlvbixcbiAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcyxcbiAgICAgICAgaXNBdXRvY29tcGxldGVGaWx0ZXIsXG4gICAgICAgIGlzRGF0ZUZpbHRlcixcbiAgICAgICAgaXNNdWx0aVNlbGVjdEZpbHRlcixcbiAgICAgICAgaXNSYW5nZUZpbHRlcixcbiAgICAgICAgaXNTZWxlY3RGaWx0ZXIsXG4gICAgICAgIGlzVGV4dGJveEZpbHRlcixcbiAgICB9O1xufTtcbmNvbnN0IHVzZURyb3Bkb3duT3B0aW9ucyA9ICh7IGhlYWRlciwgdGFibGUsIH0pID0+IHtcbiAgICBjb25zdCB7IGNvbHVtbiB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW47XG4gICAgY29uc3QgeyBmYWNldGVkVW5pcXVlVmFsdWVzLCBpc0F1dG9jb21wbGV0ZUZpbHRlciwgaXNNdWx0aVNlbGVjdEZpbHRlciwgaXNTZWxlY3RGaWx0ZXIsIH0gPSBnZXRDb2x1bW5GaWx0ZXJJbmZvKHsgaGVhZGVyLCB0YWJsZSB9KTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IGNvbHVtbkRlZi5maWx0ZXJTZWxlY3RPcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKGlzU2VsZWN0RmlsdGVyIHx8IGlzTXVsdGlTZWxlY3RGaWx0ZXIgfHwgaXNBdXRvY29tcGxldGVGaWx0ZXIpICYmXG4gICAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzXG4gICAgICAgICAgICA/IEFycmF5LmZyb20oZmFjZXRlZFVuaXF1ZVZhbHVlcy5rZXlzKCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICB9LCBbXG4gICAgICAgIGNvbHVtbkRlZi5maWx0ZXJTZWxlY3RPcHRpb25zLFxuICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLFxuICAgICAgICBpc011bHRpU2VsZWN0RmlsdGVyLFxuICAgICAgICBpc1NlbGVjdEZpbHRlcixcbiAgICBdKTtcbn07XG5cbmNvbnN0IGZsZXhSZW5kZXIgPSBmbGV4UmVuZGVyJDE7XG5mdW5jdGlvbiBjcmVhdGVNUlRDb2x1bW5IZWxwZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXNzb3I6IChhY2Nlc3NvciwgY29sdW1uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbHVtbiksIHsgYWNjZXNzb3JGbjogYWNjZXNzb3IgfSlcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sdW1uKSwgeyBhY2Nlc3NvcktleTogYWNjZXNzb3IgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IChjb2x1bW4pID0+IGNvbHVtbixcbiAgICAgICAgZ3JvdXA6IChjb2x1bW4pID0+IGNvbHVtbixcbiAgICB9O1xufVxuY29uc3QgY3JlYXRlUm93ID0gKHRhYmxlLCBvcmlnaW5hbFJvdywgcm93SW5kZXggPSAtMSwgZGVwdGggPSAwLCBzdWJSb3dzLCBwYXJlbnRJZCkgPT4gY3JlYXRlUm93JDEodGFibGUsICdtcnQtcm93LWNyZWF0ZScsIG9yaWdpbmFsUm93ICE9PSBudWxsICYmIG9yaWdpbmFsUm93ICE9PSB2b2lkIDAgPyBvcmlnaW5hbFJvdyA6IE9iamVjdC5hc3NpZ24oe30sIC4uLmdldEFsbExlYWZDb2x1bW5EZWZzKHRhYmxlLm9wdGlvbnMuY29sdW1ucykubWFwKChjb2wpID0+ICh7XG4gICAgW2dldENvbHVtbklkKGNvbCldOiAnJyxcbn0pKSksIHJvd0luZGV4LCBkZXB0aCwgc3ViUm93cywgcGFyZW50SWQpO1xuXG5jb25zdCBmdXp6eSQxID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gICAgbGV0IGRpciA9IDA7XG4gICAgaWYgKHJvd0EuY29sdW1uRmlsdGVyc01ldGFbY29sdW1uSWRdKSB7XG4gICAgICAgIGRpciA9IGNvbXBhcmVJdGVtcyhyb3dBLmNvbHVtbkZpbHRlcnNNZXRhW2NvbHVtbklkXSwgcm93Qi5jb2x1bW5GaWx0ZXJzTWV0YVtjb2x1bW5JZF0pO1xuICAgIH1cbiAgICAvLyBQcm92aWRlIGEgZmFsbGJhY2sgZm9yIHdoZW4gdGhlIGl0ZW0gcmFua3MgYXJlIGVxdWFsXG4gICAgcmV0dXJuIGRpciA9PT0gMFxuICAgICAgICA/IHNvcnRpbmdGbnMuYWxwaGFudW1lcmljKHJvd0EsIHJvd0IsIGNvbHVtbklkKVxuICAgICAgICA6IGRpcjtcbn07XG5jb25zdCBNUlRfU29ydGluZ0ZucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc29ydGluZ0ZucyksIHsgZnV6enk6IGZ1enp5JDEgfSk7XG5jb25zdCByYW5rR2xvYmFsRnV6enkgPSAocm93QSwgcm93QikgPT4gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhyb3dCLmNvbHVtbkZpbHRlcnNNZXRhKS5tYXAoKHYpID0+IHYucmFuaykpIC1cbiAgICBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKHJvd0EuY29sdW1uRmlsdGVyc01ldGEpLm1hcCgodikgPT4gdi5yYW5rKSk7XG5cbmNvbnN0IHBhcnNlRnJvbVZhbHVlc09yRnVuYyA9IChmbiwgYXJnKSA9PiAoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZuKGFyZykgOiBmbik7XG5jb25zdCBnZXRWYWx1ZUFuZExhYmVsID0gKG9wdGlvbikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGxhYmVsID0gJyc7XG4gICAgbGV0IHZhbHVlID0gJyc7XG4gICAgaWYgKG9wdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGxhYmVsID0gb3B0aW9uO1xuICAgICAgICAgICAgdmFsdWUgPSBvcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCA9IChfYSA9IG9wdGlvbi5sYWJlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSAoX2IgPSBvcHRpb24udmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxhYmVsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxhYmVsLCB2YWx1ZSB9O1xufTtcblxuY29uc3QgZ2V0TVJUX1Jvd3MgPSAodGFibGUsIGFsbCkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0Q2VudGVyUm93cywgZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsLCBnZXRSb3dNb2RlbCwgZ2V0U3RhdGUsIGdldFRvcFJvd3MsIG9wdGlvbnM6IHsgY3JlYXRlRGlzcGxheU1vZGUsIGVuYWJsZVBhZ2luYXRpb24sIGVuYWJsZVJvd1Bpbm5pbmcsIG1hbnVhbFBhZ2luYXRpb24sIHBvc2l0aW9uQ3JlYXRpbmdSb3csIHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIHBhZ2luYXRpb24gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNSYW5raW5nUm93cyA9IGdldElzUmFua2luZ1Jvd3ModGFibGUpO1xuICAgIGxldCByb3dzID0gW107XG4gICAgaWYgKCFpc1JhbmtpbmdSb3dzKSB7XG4gICAgICAgIHJvd3MgPVxuICAgICAgICAgICAgIWVuYWJsZVJvd1Bpbm5pbmcgfHwgKHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gbnVsbCB8fCByb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZS5pbmNsdWRlcygnc3RpY2t5JykpXG4gICAgICAgICAgICAgICAgPyBhbGxcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5yb3dzXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Um93TW9kZWwoKS5yb3dzXG4gICAgICAgICAgICAgICAgOiBnZXRDZW50ZXJSb3dzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmdXp6eSByYW5raW5nIGFkanVzdG1lbnRzXG4gICAgICAgIHJvd3MgPSBnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5yb3dzLnNvcnQoKGEsIGIpID0+IHJhbmtHbG9iYWxGdXp6eShhLCBiKSk7XG4gICAgICAgIGlmIChlbmFibGVQYWdpbmF0aW9uICYmICFtYW51YWxQYWdpbmF0aW9uICYmICFhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcGFnaW5hdGlvbi5wYWdlSW5kZXggKiBwYWdpbmF0aW9uLnBhZ2VTaXplO1xuICAgICAgICAgICAgcm93cyA9IHJvd3Muc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgcGFnaW5hdGlvbi5wYWdlU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZVJvd1Bpbm5pbmcgJiYgIShyb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IG51bGwgfHwgcm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dQaW5uaW5nRGlzcGxheU1vZGUuaW5jbHVkZXMoJ3N0aWNreScpKSkge1xuICAgICAgICAgICAgLy8gXCJyZS1jZW50ZXItaXplXCIgdGhlIHJvd3MgKG5vIHRvcCBvciBib3R0b20gcGlubmVkIHJvd3MgdW5sZXNzIHN0aWNreSlcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLmZpbHRlcigocm93KSA9PiAhcm93LmdldElzUGlubmVkKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJvdyBwaW5uaW5nIGFkanVzdG1lbnRzXG4gICAgaWYgKGVuYWJsZVJvd1Bpbm5pbmcgJiYgKHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gbnVsbCB8fCByb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZS5pbmNsdWRlcygnc3RpY2t5JykpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlclBpbm5lZFJvd0lkcyA9IHJvd3NcbiAgICAgICAgICAgIC5maWx0ZXIoKHJvdykgPT4gcm93LmdldElzUGlubmVkKCkpXG4gICAgICAgICAgICAubWFwKChyKSA9PiByLmlkKTtcbiAgICAgICAgcm93cyA9IFtcbiAgICAgICAgICAgIC4uLmdldFRvcFJvd3MoKS5maWx0ZXIoKHJvdykgPT4gIWNlbnRlclBpbm5lZFJvd0lkcy5pbmNsdWRlcyhyb3cuaWQpKSxcbiAgICAgICAgICAgIC4uLnJvd3MsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIGJsYW5rIGluc2VydGVkIGNyZWF0aW5nIHJvdyBhZGp1c3RtZW50c1xuICAgIGlmIChwb3NpdGlvbkNyZWF0aW5nUm93ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY3JlYXRpbmdSb3cgJiZcbiAgICAgICAgY3JlYXRlRGlzcGxheU1vZGUgPT09ICdyb3cnKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0aW5nUm93SW5kZXggPSAhaXNOYU4oK3Bvc2l0aW9uQ3JlYXRpbmdSb3cpXG4gICAgICAgICAgICA/ICtwb3NpdGlvbkNyZWF0aW5nUm93XG4gICAgICAgICAgICA6IHBvc2l0aW9uQ3JlYXRpbmdSb3cgPT09ICd0b3AnXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiByb3dzLmxlbmd0aDtcbiAgICAgICAgcm93cyA9IFtcbiAgICAgICAgICAgIC4uLnJvd3Muc2xpY2UoMCwgY3JlYXRpbmdSb3dJbmRleCksXG4gICAgICAgICAgICBjcmVhdGluZ1JvdyxcbiAgICAgICAgICAgIC4uLnJvd3Muc2xpY2UoY3JlYXRpbmdSb3dJbmRleCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xufTtcbmNvbnN0IGdldENhblJhbmtSb3dzID0gKHRhYmxlKSA9PiB7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVHbG9iYWxGaWx0ZXJSYW5rZWRSZXN1bHRzLCBtYW51YWxFeHBhbmRpbmcsIG1hbnVhbEZpbHRlcmluZywgbWFudWFsR3JvdXBpbmcsIG1hbnVhbFNvcnRpbmcsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGV4cGFuZGVkLCBnbG9iYWxGaWx0ZXJGbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gKCFtYW51YWxFeHBhbmRpbmcgJiZcbiAgICAgICAgIW1hbnVhbEZpbHRlcmluZyAmJlxuICAgICAgICAhbWFudWFsR3JvdXBpbmcgJiZcbiAgICAgICAgIW1hbnVhbFNvcnRpbmcgJiZcbiAgICAgICAgZW5hYmxlR2xvYmFsRmlsdGVyUmFua2VkUmVzdWx0cyAmJlxuICAgICAgICBnbG9iYWxGaWx0ZXJGbiA9PT0gJ2Z1enp5JyAmJlxuICAgICAgICBleHBhbmRlZCAhPT0gdHJ1ZSAmJlxuICAgICAgICAhT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKSk7XG59O1xuY29uc3QgZ2V0SXNSYW5raW5nUm93cyA9ICh0YWJsZSkgPT4ge1xuICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyLCBzb3J0aW5nIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiAoZ2V0Q2FuUmFua1Jvd3ModGFibGUpICYmXG4gICAgICAgIGdsb2JhbEZpbHRlciAmJlxuICAgICAgICAhT2JqZWN0LnZhbHVlcyhzb3J0aW5nKS5zb21lKEJvb2xlYW4pKTtcbn07XG5jb25zdCBnZXRJc1Jvd1NlbGVjdGVkID0gKHsgcm93LCB0YWJsZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBlbmFibGVSb3dTZWxlY3Rpb24gfSwgfSA9IHRhYmxlO1xuICAgIHJldHVybiAocm93LmdldElzU2VsZWN0ZWQoKSB8fFxuICAgICAgICAocGFyc2VGcm9tVmFsdWVzT3JGdW5jKGVuYWJsZVJvd1NlbGVjdGlvbiwgcm93KSAmJlxuICAgICAgICAgICAgcm93LmdldENhblNlbGVjdFN1YlJvd3MoKSAmJlxuICAgICAgICAgICAgcm93LmdldElzQWxsU3ViUm93c1NlbGVjdGVkKCkpKTtcbn07XG5jb25zdCBnZXRNUlRfUm93U2VsZWN0aW9uSGFuZGxlciA9ICh7IHJvdywgc3RhdGljUm93SW5kZXggPSAwLCB0YWJsZSwgfSkgPT4gKGV2ZW50LCB2YWx1ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZUJhdGNoUm93U2VsZWN0aW9uLCBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiwgZW5hYmxlUm93UGlubmluZywgbWFudWFsUGFnaW5hdGlvbiwgcm93UGlubmluZ0Rpc3BsYXlNb2RlLCB9LCByZWZzOiB7IGxhc3RTZWxlY3RlZFJvd0lkOiBsYXN0U2VsZWN0ZWRSb3dJZCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBwYWdpbmF0aW9uOiB7IHBhZ2VJbmRleCwgcGFnZVNpemUgfSwgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgcGFnaW5hdGlvbk9mZnNldCA9IG1hbnVhbFBhZ2luYXRpb24gPyAwIDogcGFnZVNpemUgKiBwYWdlSW5kZXg7XG4gICAgY29uc3Qgd2FzQ3VycmVudFJvd0NoZWNrZWQgPSBnZXRJc1Jvd1NlbGVjdGVkKHsgcm93LCB0YWJsZSB9KTtcbiAgICAvLyB0b2dnbGUgc2VsZWN0aW9uIG9mIHRoaXMgcm93XG4gICAgcm93LnRvZ2dsZVNlbGVjdGVkKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6ICF3YXNDdXJyZW50Um93Q2hlY2tlZCk7XG4gICAgY29uc3QgY2hhbmdlZFJvd0lkcyA9IG5ldyBTZXQoW3Jvdy5pZF0pO1xuICAgIC8vIGlmIHNoaWZ0IGtleSBpcyBwcmVzc2VkLCBzZWxlY3QgYWxsIHJvd3MgYmV0d2VlbiBsYXN0IHNlbGVjdGVkIGFuZCB0aGlzIG9uZVxuICAgIGlmIChlbmFibGVCYXRjaFJvd1NlbGVjdGlvbiAmJlxuICAgICAgICBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiAmJlxuICAgICAgICBldmVudC5uYXRpdmVFdmVudC5zaGlmdEtleSAmJlxuICAgICAgICBsYXN0U2VsZWN0ZWRSb3dJZC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBnZXRNUlRfUm93cyh0YWJsZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHJvd3MuZmluZEluZGV4KChyKSA9PiByLmlkID09PSBsYXN0U2VsZWN0ZWRSb3dJZC5jdXJyZW50KTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdEluZGV4Q2hlY2tlZCA9IGdldElzUm93U2VsZWN0ZWQoe1xuICAgICAgICAgICAgICAgIHJvdzogcm93cyA9PT0gbnVsbCB8fCByb3dzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dzW2xhc3RJbmRleF0sXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHN0YXRpY1Jvd0luZGV4ICsgcGFnaW5hdGlvbk9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGxhc3RJbmRleCA8IGN1cnJlbnRJbmRleFxuICAgICAgICAgICAgICAgID8gW2xhc3RJbmRleCwgY3VycmVudEluZGV4XVxuICAgICAgICAgICAgICAgIDogW2N1cnJlbnRJbmRleCwgbGFzdEluZGV4XTtcbiAgICAgICAgICAgIC8vIHRvZ2dsZSBzZWxlY3Rpb24gb2YgYWxsIHJvd3MgYmV0d2VlbiBsYXN0IHNlbGVjdGVkIGFuZCB0aGlzIG9uZVxuICAgICAgICAgICAgLy8gYnV0IG9ubHkgaWYgdGhlIGxhc3Qgc2VsZWN0ZWQgcm93IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgICAgIGlmICh3YXNDdXJyZW50Um93Q2hlY2tlZCAhPT0gaXNMYXN0SW5kZXhDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3NbaV0udG9nZ2xlU2VsZWN0ZWQoIXdhc0N1cnJlbnRSb3dDaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFJvd0lkcy5hZGQocm93c1tpXS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJlY29yZCB0aGUgbGFzdCBzZWxlY3RlZCByb3cgaWRcbiAgICBsYXN0U2VsZWN0ZWRSb3dJZC5jdXJyZW50ID0gcm93LmlkO1xuICAgIC8vIGlmIGFsbCBzdWIgcm93cyB3ZXJlIHNlbGVjdGVkLCB1bnNlbGVjdCB0aGVtXG4gICAgaWYgKHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzKCkgJiYgcm93LmdldElzQWxsU3ViUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgKF9hID0gcm93LnN1YlJvd3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChyKSA9PiByLnRvZ2dsZVNlbGVjdGVkKGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChlbmFibGVSb3dQaW5uaW5nICYmIChyb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IG51bGwgfHwgcm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dQaW5uaW5nRGlzcGxheU1vZGUuaW5jbHVkZXMoJ3NlbGVjdCcpKSkge1xuICAgICAgICBjaGFuZ2VkUm93SWRzLmZvckVhY2goKHJvd0lkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3dUb1RvZ2dsZVBpbiA9IHRhYmxlLmdldFJvdyhyb3dJZCk7XG4gICAgICAgICAgICByb3dUb1RvZ2dsZVBpbi5waW4oIXdhc0N1cnJlbnRSb3dDaGVja2VkIC8vd2FzIG5vdCBwcmV2aW91c2x5IHBpbm5lZCBvciBzZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gKHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gbnVsbCB8fCByb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZS5pbmNsdWRlcygnYm90dG9tJykpXG4gICAgICAgICAgICAgICAgICAgID8gJ2JvdHRvbSdcbiAgICAgICAgICAgICAgICAgICAgOiAndG9wJ1xuICAgICAgICAgICAgICAgIDogZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgZ2V0TVJUX1NlbGVjdEFsbEhhbmRsZXIgPSAoeyB0YWJsZSB9KSA9PiAoZXZlbnQsIHZhbHVlLCBmb3JjZUFsbCkgPT4ge1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBlbmFibGVSb3dQaW5uaW5nLCByb3dQaW5uaW5nRGlzcGxheU1vZGUsIHNlbGVjdEFsbE1vZGUgfSwgcmVmczogeyBsYXN0U2VsZWN0ZWRSb3dJZCB9LCB9ID0gdGFibGU7XG4gICAgc2VsZWN0QWxsTW9kZSA9PT0gJ2FsbCcgfHwgZm9yY2VBbGxcbiAgICAgICAgPyB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogZXZlbnQudGFyZ2V0LmNoZWNrZWQpXG4gICAgICAgIDogdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgaWYgKGVuYWJsZVJvd1Bpbm5pbmcgJiYgKHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gbnVsbCB8fCByb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZS5pbmNsdWRlcygnc2VsZWN0JykpKSB7XG4gICAgICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcoeyBib3R0b206IFtdLCB0b3A6IFtdIH0pO1xuICAgIH1cbiAgICBsYXN0U2VsZWN0ZWRSb3dJZC5jdXJyZW50ID0gbnVsbDtcbn07XG5cbmNvbnN0IGlzV2luQ3RybE1hY01ldGEgPSAoZXZlbnQpID0+IHtcbiAgICByZXR1cm4gKChldmVudC5jdHJsS2V5ICYmIG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd3aW4nKSkgfHxcbiAgICAgICAgKGV2ZW50Lm1ldGFLZXkgJiYgbmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ21hYycpKSk7XG59O1xuY29uc3QgaXNDZWxsRWRpdGFibGUgPSAoeyBjZWxsLCB0YWJsZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgZW5hYmxlRWRpdGluZyB9ID0gdGFibGUub3B0aW9ucztcbiAgICBjb25zdCB7IGNvbHVtbjogeyBjb2x1bW5EZWYgfSwgcm93LCB9ID0gY2VsbDtcbiAgICByZXR1cm4gKCFjZWxsLmdldElzUGxhY2Vob2xkZXIoKSAmJlxuICAgICAgICBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoZW5hYmxlRWRpdGluZywgcm93KSAmJlxuICAgICAgICBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLmVuYWJsZUVkaXRpbmcsIHJvdykgIT09IGZhbHNlKTtcbn07XG5jb25zdCBvcGVuRWRpdGluZ0NlbGwgPSAoeyBjZWxsLCB0YWJsZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBlZGl0RGlzcGxheU1vZGUgfSwgcmVmczogeyBlZGl0SW5wdXRSZWZzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbiB9ID0gY2VsbDtcbiAgICBpZiAoaXNDZWxsRWRpdGFibGUoeyBjZWxsLCB0YWJsZSB9KSAmJiBlZGl0RGlzcGxheU1vZGUgPT09ICdjZWxsJykge1xuICAgICAgICB0YWJsZS5zZXRFZGl0aW5nQ2VsbChjZWxsKTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHRleHRGaWVsZCA9IChfYSA9IGVkaXRJbnB1dFJlZnMuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NvbHVtbi5pZF07XG4gICAgICAgICAgICBpZiAodGV4dEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGV4dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgKF9iID0gdGV4dEZpZWxkLnNlbGVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGV4dEZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGNlbGxLZXlib2FyZFNob3J0Y3V0cyA9ICh7IGNlbGwsIGNlbGxFbGVtZW50cywgY2VsbFZhbHVlLCBjb250YWluZXJFbGVtZW50LCBldmVudCwgaGVhZGVyLCBwYXJlbnRFbGVtZW50LCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgaWYgKCF0YWJsZS5vcHRpb25zLmVuYWJsZUtleWJvYXJkU2hvcnRjdXRzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgaWYgKGNlbGxWYWx1ZSAmJiBpc1dpbkN0cmxNYWNNZXRhKGV2ZW50KSAmJiBldmVudC5rZXkgPT09ICdjJykge1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjZWxsVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChbJ0VudGVyJywgJyAnXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIGlmICgoKF9hID0gY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLmNvbHVtbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSA9PT0gJ21ydC1yb3ctc2VsZWN0Jykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdldE1SVF9Sb3dTZWxlY3Rpb25IYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93LFxuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHN0YXRpY1Jvd0luZGV4OiArZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpLFxuICAgICAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2IgPSBoZWFkZXIgPT09IG51bGwgfHwgaGVhZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZWFkZXIuY29sdW1uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQpID09PSAnbXJ0LXJvdy1zZWxlY3QnICYmXG4gICAgICAgICAgICB0YWJsZS5vcHRpb25zLmVuYWJsZVNlbGVjdEFsbCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdldE1SVF9TZWxlY3RBbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9jID0gY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLmNvbHVtbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlkKSA9PT0gJ21ydC1yb3ctZXhwYW5kJyAmJlxuICAgICAgICAgICAgKGNlbGwucm93LmdldENhbkV4cGFuZCgpIHx8XG4gICAgICAgICAgICAgICAgKChfZSA9IChfZCA9IHRhYmxlLm9wdGlvbnMpLnJlbmRlckRldGFpbFBhbmVsKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCwgeyByb3c6IGNlbGwucm93LCB0YWJsZSB9KSkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY2VsbC5yb3cudG9nZ2xlRXhwYW5kZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9mID0gaGVhZGVyID09PSBudWxsIHx8IGhlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVyLmNvbHVtbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlkKSA9PT0gJ21ydC1yb3ctZXhwYW5kJyAmJlxuICAgICAgICAgICAgdGFibGUub3B0aW9ucy5lbmFibGVFeHBhbmRBbGwpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLmNvbHVtbi5pZCkgPT09ICdtcnQtcm93LXBpbicpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjZWxsLnJvdy5nZXRJc1Bpbm5lZCgpXG4gICAgICAgICAgICAgICAgPyBjZWxsLnJvdy5waW4oZmFsc2UpXG4gICAgICAgICAgICAgICAgOiBjZWxsLnJvdy5waW4oKChfZyA9IHRhYmxlLm9wdGlvbnMucm93UGlubmluZ0Rpc3BsYXlNb2RlKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuaW5jbHVkZXMoJ2JvdHRvbScpKVxuICAgICAgICAgICAgICAgICAgICA/ICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgIDogJ3RvcCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhlYWRlciAmJiBpc1dpbkN0cmxNYWNNZXRhKGV2ZW50KSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uc0J1dHRvbiA9IGN1cnJlbnRDZWxsLnF1ZXJ5U2VsZWN0b3IoYGJ1dHRvblthcmlhLWxhYmVsPVwiJHt0YWJsZS5vcHRpb25zLmxvY2FsaXphdGlvbi5jb2x1bW5BY3Rpb25zfVwiXWApO1xuICAgICAgICAgICAgaWYgKGFjdGlvbnNCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zQnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKF9oID0gaGVhZGVyID09PSBudWxsIHx8IGhlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVyLmNvbHVtbikgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmdldENhblNvcnQoKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGhlYWRlci5jb2x1bW4udG9nZ2xlU29ydGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKFtcbiAgICAgICAgJ0Fycm93UmlnaHQnLFxuICAgICAgICAnQXJyb3dMZWZ0JyxcbiAgICAgICAgJ0Fycm93VXAnLFxuICAgICAgICAnQXJyb3dEb3duJyxcbiAgICAgICAgJ0hvbWUnLFxuICAgICAgICAnRW5kJyxcbiAgICAgICAgJ1BhZ2VVcCcsXG4gICAgICAgICdQYWdlRG93bicsXG4gICAgXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBwYXJlbnRFbGVtZW50IHx8IGN1cnJlbnRDZWxsLmNsb3Nlc3QoJ3RyJyk7XG4gICAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGNvbnRhaW5lckVsZW1lbnQgfHwgY3VycmVudENlbGwuY2xvc2VzdCgndGFibGUnKTtcbiAgICAgICAgY29uc3QgYWxsQ2VsbHMgPSBjZWxsRWxlbWVudHMgfHxcbiAgICAgICAgICAgIEFycmF5LmZyb20oKHRhYmxlRWxlbWVudCA9PT0gbnVsbCB8fCB0YWJsZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCd0aCwgdGQnKSkgfHwgW10pO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEluZGV4ID0gYWxsQ2VsbHMuaW5kZXhPZihjdXJyZW50Q2VsbCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHBhcnNlSW50KGN1cnJlbnRDZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpIHx8ICcwJyk7XG4gICAgICAgIGxldCBuZXh0Q2VsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy9ob21lL2VuZCBmaXJzdCBvciBsYXN0IGNlbGwgaW4gcm93XG4gICAgICAgIGNvbnN0IGZpbmRFZGdlQ2VsbCA9IChyb3dJbmRleCwgZWRnZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gcm93SW5kZXggPT09ICdjJ1xuICAgICAgICAgICAgICAgID8gY3VycmVudFJvd1xuICAgICAgICAgICAgICAgIDogcm93SW5kZXggPT09ICdmJ1xuICAgICAgICAgICAgICAgICAgICA/IHRhYmxlRWxlbWVudCA9PT0gbnVsbCB8fCB0YWJsZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0cicpXG4gICAgICAgICAgICAgICAgICAgIDogKF9hID0gdGFibGVFbGVtZW50ID09PSBudWxsIHx8IHRhYmxlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgY29uc3Qgcm93Q2VsbHMgPSBBcnJheS5mcm9tKChyb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuY2hpbGRyZW4pIHx8IFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldENlbGwgPSBlZGdlID09PSAnZicgPyByb3dDZWxsc1swXSA6IHJvd0NlbGxzW3Jvd0NlbGxzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENlbGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vcGFnZSB1cC9kb3duIGZpcnN0IG9yIGxhc3QgY2VsbCBpbiBjb2x1bW5cbiAgICAgICAgY29uc3QgZmluZEJvdHRvbVRvcENlbGwgPSAoY29sdW1uSW5kZXgsIGVkZ2UpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGVkZ2UgPT09ICd0J1xuICAgICAgICAgICAgICAgID8gdGFibGVFbGVtZW50ID09PSBudWxsIHx8IHRhYmxlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RyJylcbiAgICAgICAgICAgICAgICA6IChfYSA9IHRhYmxlRWxlbWVudCA9PT0gbnVsbCB8fCB0YWJsZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlRWxlbWVudC5sYXN0RWxlbWVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIGNvbnN0IHJvd0NlbGxzID0gQXJyYXkuZnJvbSgocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93LmNoaWxkcmVuKSB8fCBbXSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRDZWxsID0gcm93Q2VsbHNbY29sdW1uSW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENlbGw7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbmRBZGphY2VudENlbGwgPSAoY29sdW1uSW5kZXgsIHNlYXJjaERpcmVjdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoQXJyYXkgPSBzZWFyY2hEaXJlY3Rpb24gPT09ICdmJ1xuICAgICAgICAgICAgICAgID8gYWxsQ2VsbHMuc2xpY2UoY3VycmVudENlbGxJbmRleCArIDEpXG4gICAgICAgICAgICAgICAgOiBhbGxDZWxscy5zbGljZSgwLCBjdXJyZW50Q2VsbEluZGV4KS5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoQXJyYXkuZmluZCgoY2VsbCkgPT4gY2VsbC5tYXRjaGVzKGBbZGF0YS1pbmRleD1cIiR7Y29sdW1uSW5kZXh9XCJdYCkpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICAgICAgbmV4dENlbGwgPSBmaW5kQWRqYWNlbnRDZWxsKGN1cnJlbnRJbmRleCArIDEsICdmJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgICAgIG5leHRDZWxsID0gZmluZEFkamFjZW50Q2VsbChjdXJyZW50SW5kZXggLSAxLCAnYicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgbmV4dENlbGwgPSBmaW5kQWRqYWNlbnRDZWxsKGN1cnJlbnRJbmRleCwgJ2InKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgbmV4dENlbGwgPSBmaW5kQWRqYWNlbnRDZWxsKGN1cnJlbnRJbmRleCwgJ2YnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgICAgICAgICAgIG5leHRDZWxsID0gZmluZEVkZ2VDZWxsKGlzV2luQ3RybE1hY01ldGEoZXZlbnQpID8gJ2YnIDogJ2MnLCAnZicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICAgICAgICBuZXh0Q2VsbCA9IGZpbmRFZGdlQ2VsbChpc1dpbkN0cmxNYWNNZXRhKGV2ZW50KSA/ICdsJyA6ICdjJywgJ2wnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BhZ2VVcCc6XG4gICAgICAgICAgICAgICAgbmV4dENlbGwgPSBmaW5kQm90dG9tVG9wQ2VsbChjdXJyZW50SW5kZXgsICd0Jyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgICAgICAgbmV4dENlbGwgPSBmaW5kQm90dG9tVG9wQ2VsbChjdXJyZW50SW5kZXgsICdiJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRDZWxsKSB7XG4gICAgICAgICAgICBuZXh0Q2VsbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXlDb2x1bW5Qcm9wcyh7IGhlYWRlciwgaWQsIHNpemUsIHRhYmxlT3B0aW9ucywgfSkge1xuICAgIGNvbnN0IHsgZGVmYXVsdERpc3BsYXlDb2x1bW4sIGRpc3BsYXlDb2x1bW5EZWZPcHRpb25zLCBsb2NhbGl6YXRpb24gfSA9IHRhYmxlT3B0aW9ucztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERpc3BsYXlDb2x1bW4pLCB7IGhlYWRlcjogaGVhZGVyID8gbG9jYWxpemF0aW9uW2hlYWRlcl0gOiAnJywgc2l6ZSB9KSwgZGlzcGxheUNvbHVtbkRlZk9wdGlvbnMgPT09IG51bGwgfHwgZGlzcGxheUNvbHVtbkRlZk9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3BsYXlDb2x1bW5EZWZPcHRpb25zW2lkXSksIHsgaWQgfSk7XG59XG5jb25zdCBzaG93Um93UGlubmluZ0NvbHVtbiA9ICh0YWJsZU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGVuYWJsZVJvd1Bpbm5pbmcsIHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSB9ID0gdGFibGVPcHRpb25zO1xuICAgIHJldHVybiAhIShlbmFibGVSb3dQaW5uaW5nICYmICEocm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSBudWxsIHx8IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93UGlubmluZ0Rpc3BsYXlNb2RlLnN0YXJ0c1dpdGgoJ3NlbGVjdCcpKSk7XG59O1xuY29uc3Qgc2hvd1Jvd0RyYWdDb2x1bW4gPSAodGFibGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBlbmFibGVSb3dEcmFnZ2luZywgZW5hYmxlUm93T3JkZXJpbmcgfSA9IHRhYmxlT3B0aW9ucztcbiAgICByZXR1cm4gISEoZW5hYmxlUm93RHJhZ2dpbmcgfHwgZW5hYmxlUm93T3JkZXJpbmcpO1xufTtcbmNvbnN0IHNob3dSb3dFeHBhbmRDb2x1bW4gPSAodGFibGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBlbmFibGVFeHBhbmRpbmcsIGVuYWJsZUdyb3VwaW5nLCByZW5kZXJEZXRhaWxQYW5lbCwgc3RhdGU6IHsgZ3JvdXBpbmcgfSwgfSA9IHRhYmxlT3B0aW9ucztcbiAgICByZXR1cm4gISEoZW5hYmxlRXhwYW5kaW5nIHx8XG4gICAgICAgIChlbmFibGVHcm91cGluZyAmJiAoZ3JvdXBpbmcgPT09IG51bGwgfHwgZ3JvdXBpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwaW5nLmxlbmd0aCkpIHx8XG4gICAgICAgIHJlbmRlckRldGFpbFBhbmVsKTtcbn07XG5jb25zdCBzaG93Um93QWN0aW9uc0NvbHVtbiA9ICh0YWJsZU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZURpc3BsYXlNb2RlLCBlZGl0RGlzcGxheU1vZGUsIGVuYWJsZUVkaXRpbmcsIGVuYWJsZVJvd0FjdGlvbnMsIHN0YXRlOiB7IGNyZWF0aW5nUm93IH0sIH0gPSB0YWJsZU9wdGlvbnM7XG4gICAgcmV0dXJuICEhKGVuYWJsZVJvd0FjdGlvbnMgfHxcbiAgICAgICAgKGNyZWF0aW5nUm93ICYmIGNyZWF0ZURpc3BsYXlNb2RlID09PSAncm93JykgfHxcbiAgICAgICAgKGVuYWJsZUVkaXRpbmcgJiYgWydtb2RhbCcsICdyb3cnXS5pbmNsdWRlcyhlZGl0RGlzcGxheU1vZGUgIT09IG51bGwgJiYgZWRpdERpc3BsYXlNb2RlICE9PSB2b2lkIDAgPyBlZGl0RGlzcGxheU1vZGUgOiAnJykpKTtcbn07XG5jb25zdCBzaG93Um93U2VsZWN0aW9uQ29sdW1uID0gKHRhYmxlT3B0aW9ucykgPT4gISF0YWJsZU9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uO1xuY29uc3Qgc2hvd1Jvd051bWJlcnNDb2x1bW4gPSAodGFibGVPcHRpb25zKSA9PiAhIXRhYmxlT3B0aW9ucy5lbmFibGVSb3dOdW1iZXJzO1xuY29uc3Qgc2hvd1Jvd1NwYWNlckNvbHVtbiA9ICh0YWJsZU9wdGlvbnMpID0+IHRhYmxlT3B0aW9ucy5sYXlvdXRNb2RlID09PSAnZ3JpZC1uby1ncm93JztcbmNvbnN0IGdldExlYWRpbmdEaXNwbGF5Q29sdW1uSWRzID0gKHRhYmxlT3B0aW9ucykgPT4gW1xuICAgIHNob3dSb3dQaW5uaW5nQ29sdW1uKHRhYmxlT3B0aW9ucykgJiYgJ21ydC1yb3ctcGluJyxcbiAgICBzaG93Um93RHJhZ0NvbHVtbih0YWJsZU9wdGlvbnMpICYmICdtcnQtcm93LWRyYWcnLFxuICAgIHRhYmxlT3B0aW9ucy5wb3NpdGlvbkFjdGlvbnNDb2x1bW4gPT09ICdmaXJzdCcgJiZcbiAgICAgICAgc2hvd1Jvd0FjdGlvbnNDb2x1bW4odGFibGVPcHRpb25zKSAmJlxuICAgICAgICAnbXJ0LXJvdy1hY3Rpb25zJyxcbiAgICB0YWJsZU9wdGlvbnMucG9zaXRpb25FeHBhbmRDb2x1bW4gPT09ICdmaXJzdCcgJiZcbiAgICAgICAgc2hvd1Jvd0V4cGFuZENvbHVtbih0YWJsZU9wdGlvbnMpICYmXG4gICAgICAgICdtcnQtcm93LWV4cGFuZCcsXG4gICAgc2hvd1Jvd1NlbGVjdGlvbkNvbHVtbih0YWJsZU9wdGlvbnMpICYmICdtcnQtcm93LXNlbGVjdCcsXG4gICAgc2hvd1Jvd051bWJlcnNDb2x1bW4odGFibGVPcHRpb25zKSAmJiAnbXJ0LXJvdy1udW1iZXJzJyxcbl0uZmlsdGVyKEJvb2xlYW4pO1xuY29uc3QgZ2V0VHJhaWxpbmdEaXNwbGF5Q29sdW1uSWRzID0gKHRhYmxlT3B0aW9ucykgPT4gW1xuICAgIHRhYmxlT3B0aW9ucy5wb3NpdGlvbkFjdGlvbnNDb2x1bW4gPT09ICdsYXN0JyAmJlxuICAgICAgICBzaG93Um93QWN0aW9uc0NvbHVtbih0YWJsZU9wdGlvbnMpICYmXG4gICAgICAgICdtcnQtcm93LWFjdGlvbnMnLFxuICAgIHRhYmxlT3B0aW9ucy5wb3NpdGlvbkV4cGFuZENvbHVtbiA9PT0gJ2xhc3QnICYmXG4gICAgICAgIHNob3dSb3dFeHBhbmRDb2x1bW4odGFibGVPcHRpb25zKSAmJlxuICAgICAgICAnbXJ0LXJvdy1leHBhbmQnLFxuICAgIHNob3dSb3dTcGFjZXJDb2x1bW4odGFibGVPcHRpb25zKSAmJiAnbXJ0LXJvdy1zcGFjZXInLFxuXS5maWx0ZXIoQm9vbGVhbik7XG5jb25zdCBnZXREZWZhdWx0Q29sdW1uT3JkZXJJZHMgPSAodGFibGVPcHRpb25zLCByZXNldCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0ZTogeyBjb2x1bW5PcmRlcjogY3VycmVudENvbHVtbk9yZGVySWRzID0gW10gfSwgfSA9IHRhYmxlT3B0aW9ucztcbiAgICBjb25zdCBsZWFkaW5nRGlzcGxheUNvbElkcyA9IGdldExlYWRpbmdEaXNwbGF5Q29sdW1uSWRzKHRhYmxlT3B0aW9ucyk7XG4gICAgY29uc3QgdHJhaWxpbmdEaXNwbGF5Q29sSWRzID0gZ2V0VHJhaWxpbmdEaXNwbGF5Q29sdW1uSWRzKHRhYmxlT3B0aW9ucyk7XG4gICAgY29uc3QgZGVmYXVsdENvbHVtbkRlZklkcyA9IGdldEFsbExlYWZDb2x1bW5EZWZzKHRhYmxlT3B0aW9ucy5jb2x1bW5zKS5tYXAoKGNvbHVtbkRlZikgPT4gZ2V0Q29sdW1uSWQoY29sdW1uRGVmKSk7XG4gICAgbGV0IGFsbExlYWZDb2x1bW5EZWZJZHMgPSByZXNldFxuICAgICAgICA/IGRlZmF1bHRDb2x1bW5EZWZJZHNcbiAgICAgICAgOiBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLmN1cnJlbnRDb2x1bW5PcmRlcklkcywgLi4uZGVmYXVsdENvbHVtbkRlZklkc10pKTtcbiAgICBhbGxMZWFmQ29sdW1uRGVmSWRzID0gYWxsTGVhZkNvbHVtbkRlZklkcy5maWx0ZXIoKGNvbElkKSA9PiAhbGVhZGluZ0Rpc3BsYXlDb2xJZHMuaW5jbHVkZXMoY29sSWQpICYmXG4gICAgICAgICF0cmFpbGluZ0Rpc3BsYXlDb2xJZHMuaW5jbHVkZXMoY29sSWQpKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5sZWFkaW5nRGlzcGxheUNvbElkcyxcbiAgICAgICAgLi4uYWxsTGVhZkNvbHVtbkRlZklkcyxcbiAgICAgICAgLi4udHJhaWxpbmdEaXNwbGF5Q29sSWRzLFxuICAgIF07XG59O1xuXG5jb25zdCBNUlRfQWdncmVnYXRpb25GbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhZ2dyZWdhdGlvbkZucyk7XG5cbmNvbnN0IGZ1enp5ID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlLCBhZGRNZXRhKSA9PiB7XG4gICAgY29uc3QgaXRlbVJhbmsgPSByYW5rSXRlbShyb3cuZ2V0VmFsdWUoY29sdW1uSWQpLCBmaWx0ZXJWYWx1ZSwge1xuICAgICAgICB0aHJlc2hvbGQ6IHJhbmtpbmdzLk1BVENIRVMsXG4gICAgfSk7XG4gICAgYWRkTWV0YShpdGVtUmFuayk7XG4gICAgcmV0dXJuIGl0ZW1SYW5rLnBhc3NlZDtcbn07XG5mdXp6eS5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IGNvbnRhaW5zID0gKHJvdywgaWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSByb3dcbiAgICAgICAgLmdldFZhbHVlKGlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkuaW5jbHVkZXMoZmlsdGVyVmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKSkpO1xufTtcbmNvbnRhaW5zLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3Qgc3RhcnRzV2l0aCA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoKF9hID0gcm93XG4gICAgICAgIC5nZXRWYWx1ZShpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpLnN0YXJ0c1dpdGgoZmlsdGVyVmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKSkpO1xufTtcbnN0YXJ0c1dpdGguYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBlbmRzV2l0aCA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoKF9hID0gcm93XG4gICAgICAgIC5nZXRWYWx1ZShpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpLmVuZHNXaXRoKGZpbHRlclZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkpKTtcbn07XG5lbmRzV2l0aC5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IGVxdWFscyA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHJvdy5nZXRWYWx1ZShpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpKSA9PT1cbiAgICAgICAgZmlsdGVyVmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbn07XG5lcXVhbHMuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBub3RFcXVhbHMgPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSByb3cuZ2V0VmFsdWUoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKSkgIT09XG4gICAgICAgIGZpbHRlclZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCk7XG59O1xubm90RXF1YWxzLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgZ3JlYXRlclRoYW4gPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gIWlzTmFOKCtmaWx0ZXJWYWx1ZSkgJiYgIWlzTmFOKCtyb3cuZ2V0VmFsdWUoaWQpKVxuICAgICAgICA/ICsoKF9hID0gcm93LmdldFZhbHVlKGlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgPiArZmlsdGVyVmFsdWVcbiAgICAgICAgOiAoKF9jID0gKChfYiA9IHJvdy5nZXRWYWx1ZShpZCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkpID4gZmlsdGVyVmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbn07XG5ncmVhdGVyVGhhbi5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IGdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gKHJvdywgaWQsIGZpbHRlclZhbHVlKSA9PiBlcXVhbHMocm93LCBpZCwgZmlsdGVyVmFsdWUpIHx8IGdyZWF0ZXJUaGFuKHJvdywgaWQsIGZpbHRlclZhbHVlKTtcbmdyZWF0ZXJUaGFuT3JFcXVhbFRvLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgbGVzc1RoYW4gPSAocm93LCBpZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gIWlzTmFOKCtmaWx0ZXJWYWx1ZSkgJiYgIWlzTmFOKCtyb3cuZ2V0VmFsdWUoaWQpKVxuICAgICAgICA/ICsoKF9hID0gcm93LmdldFZhbHVlKGlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgPCArZmlsdGVyVmFsdWVcbiAgICAgICAgOiAoKF9jID0gKChfYiA9IHJvdy5nZXRWYWx1ZShpZCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCkpIDwgZmlsdGVyVmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbn07XG5sZXNzVGhhbi5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IGxlc3NUaGFuT3JFcXVhbFRvID0gKHJvdywgaWQsIGZpbHRlclZhbHVlKSA9PiBlcXVhbHMocm93LCBpZCwgZmlsdGVyVmFsdWUpIHx8IGxlc3NUaGFuKHJvdywgaWQsIGZpbHRlclZhbHVlKTtcbmxlc3NUaGFuT3JFcXVhbFRvLmF1dG9SZW1vdmUgPSAodmFsKSA9PiAhdmFsO1xuY29uc3QgYmV0d2VlbiA9IChyb3csIGlkLCBmaWx0ZXJWYWx1ZXMpID0+IChbJycsIHVuZGVmaW5lZF0uaW5jbHVkZXMoZmlsdGVyVmFsdWVzWzBdKSB8fFxuICAgIGdyZWF0ZXJUaGFuKHJvdywgaWQsIGZpbHRlclZhbHVlc1swXSkpICYmXG4gICAgKCghaXNOYU4oK2ZpbHRlclZhbHVlc1swXSkgJiZcbiAgICAgICAgIWlzTmFOKCtmaWx0ZXJWYWx1ZXNbMV0pICYmXG4gICAgICAgICtmaWx0ZXJWYWx1ZXNbMF0gPiArZmlsdGVyVmFsdWVzWzFdKSB8fFxuICAgICAgICBbJycsIHVuZGVmaW5lZF0uaW5jbHVkZXMoZmlsdGVyVmFsdWVzWzFdKSB8fFxuICAgICAgICBsZXNzVGhhbihyb3csIGlkLCBmaWx0ZXJWYWx1ZXNbMV0pKTtcbmJldHdlZW4uYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBiZXR3ZWVuSW5jbHVzaXZlID0gKHJvdywgaWQsIGZpbHRlclZhbHVlcykgPT4gKFsnJywgdW5kZWZpbmVkXS5pbmNsdWRlcyhmaWx0ZXJWYWx1ZXNbMF0pIHx8XG4gICAgZ3JlYXRlclRoYW5PckVxdWFsVG8ocm93LCBpZCwgZmlsdGVyVmFsdWVzWzBdKSkgJiZcbiAgICAoKCFpc05hTigrZmlsdGVyVmFsdWVzWzBdKSAmJlxuICAgICAgICAhaXNOYU4oK2ZpbHRlclZhbHVlc1sxXSkgJiZcbiAgICAgICAgK2ZpbHRlclZhbHVlc1swXSA+ICtmaWx0ZXJWYWx1ZXNbMV0pIHx8XG4gICAgICAgIFsnJywgdW5kZWZpbmVkXS5pbmNsdWRlcyhmaWx0ZXJWYWx1ZXNbMV0pIHx8XG4gICAgICAgIGxlc3NUaGFuT3JFcXVhbFRvKHJvdywgaWQsIGZpbHRlclZhbHVlc1sxXSkpO1xuYmV0d2VlbkluY2x1c2l2ZS5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IGVtcHR5ID0gKHJvdywgaWQsIF9maWx0ZXJWYWx1ZSkgPT4geyB2YXIgX2E7IHJldHVybiAhKChfYSA9IHJvdy5nZXRWYWx1ZShpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpLnRyaW0oKSk7IH07XG5lbXB0eS5hdXRvUmVtb3ZlID0gKHZhbCkgPT4gIXZhbDtcbmNvbnN0IG5vdEVtcHR5ID0gKHJvdywgaWQsIF9maWx0ZXJWYWx1ZSkgPT4geyB2YXIgX2E7IHJldHVybiAhISgoX2EgPSByb3cuZ2V0VmFsdWUoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKS50cmltKCkpOyB9O1xubm90RW1wdHkuYXV0b1JlbW92ZSA9ICh2YWwpID0+ICF2YWw7XG5jb25zdCBNUlRfRmlsdGVyRm5zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJGbnMpLCB7IGJldHdlZW4sXG4gICAgYmV0d2VlbkluY2x1c2l2ZSxcbiAgICBjb250YWlucyxcbiAgICBlbXB0eSxcbiAgICBlbmRzV2l0aCxcbiAgICBlcXVhbHMsXG4gICAgZnV6enksXG4gICAgZ3JlYXRlclRoYW4sXG4gICAgZ3JlYXRlclRoYW5PckVxdWFsVG8sXG4gICAgbGVzc1RoYW4sXG4gICAgbGVzc1RoYW5PckVxdWFsVG8sXG4gICAgbm90RW1wdHksXG4gICAgbm90RXF1YWxzLFxuICAgIHN0YXJ0c1dpdGggfSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuY29uc3QgTVJUX0VkaXRBY3Rpb25CdXR0b25zID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgcm93LCB0YWJsZSwgdmFyaWFudCA9ICdpY29uJyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInJvd1wiLCBcInRhYmxlXCIsIFwidmFyaWFudFwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBpY29uczogeyBDYW5jZWxJY29uLCBTYXZlSWNvbiB9LCBsb2NhbGl6YXRpb24sIG9uQ3JlYXRpbmdSb3dDYW5jZWwsIG9uQ3JlYXRpbmdSb3dTYXZlLCBvbkVkaXRpbmdSb3dDYW5jZWwsIG9uRWRpdGluZ1Jvd1NhdmUsIH0sIHJlZnM6IHsgZWRpdElucHV0UmVmcyB9LCBzZXRDcmVhdGluZ1Jvdywgc2V0RWRpdGluZ1JvdywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIGVkaXRpbmdSb3csIGlzU2F2aW5nIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGlzQ3JlYXRpbmcgPSAoY3JlYXRpbmdSb3cgPT09IG51bGwgfHwgY3JlYXRpbmdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0aW5nUm93LmlkKSA9PT0gcm93LmlkO1xuICAgIGNvbnN0IGlzRWRpdGluZyA9IChlZGl0aW5nUm93ID09PSBudWxsIHx8IGVkaXRpbmdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRpbmdSb3cuaWQpID09PSByb3cuaWQ7XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNDcmVhdGluZykge1xuICAgICAgICAgICAgb25DcmVhdGluZ1Jvd0NhbmNlbCA9PT0gbnVsbCB8fCBvbkNyZWF0aW5nUm93Q2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNyZWF0aW5nUm93Q2FuY2VsKHsgcm93LCB0YWJsZSB9KTtcbiAgICAgICAgICAgIHNldENyZWF0aW5nUm93KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRWRpdGluZykge1xuICAgICAgICAgICAgb25FZGl0aW5nUm93Q2FuY2VsID09PSBudWxsIHx8IG9uRWRpdGluZ1Jvd0NhbmNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FZGl0aW5nUm93Q2FuY2VsKHsgcm93LCB0YWJsZSB9KTtcbiAgICAgICAgICAgIHNldEVkaXRpbmdSb3cobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcm93Ll92YWx1ZXNDYWNoZSA9IHt9OyAvL3Jlc2V0IHZhbHVlcyBjYWNoZVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU3VibWl0Um93ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvL2xvb2sgZm9yIGF1dG8tZmlsbGVkIGlucHV0IHZhbHVlc1xuICAgICAgICAoX2IgPSBPYmplY3QudmFsdWVzKChfYSA9IGVkaXRJbnB1dFJlZnMuY3VycmVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pXG4gICAgICAgICAgICAuZmlsdGVyKChpbnB1dFJlZikgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gcm93LmlkID09PSAoKF9iID0gKF9hID0gaW5wdXRSZWYgPT09IG51bGwgfHwgaW5wdXRSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0UmVmLm5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnXycpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pOyB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5oYXNPd24ocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93Ll92YWx1ZXNDYWNoZSwgaW5wdXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcm93Ll92YWx1ZXNDYWNoZVtpbnB1dC5uYW1lXSA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQ3JlYXRpbmcpXG4gICAgICAgICAgICBvbkNyZWF0aW5nUm93U2F2ZSA9PT0gbnVsbCB8fCBvbkNyZWF0aW5nUm93U2F2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DcmVhdGluZ1Jvd1NhdmUoe1xuICAgICAgICAgICAgICAgIGV4aXRDcmVhdGluZ01vZGU6ICgpID0+IHNldENyZWF0aW5nUm93KG51bGwpLFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHJvdy5fdmFsdWVzQ2FjaGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvbkVkaXRpbmdSb3dTYXZlID09PSBudWxsIHx8IG9uRWRpdGluZ1Jvd1NhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRWRpdGluZ1Jvd1NhdmUoe1xuICAgICAgICAgICAgICAgIGV4aXRFZGl0aW5nTW9kZTogKCkgPT4gc2V0RWRpdGluZ1JvdyhudWxsKSxcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiByb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuX3ZhbHVlc0NhY2hlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KEJveCwgeyBvbkNsaWNrOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBkaXNwbGF5OiAnZmxleCcsIGdhcDogJzAuNzVyZW0nIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhyZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3Quc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogdmFyaWFudCA9PT0gJ2ljb24nID8gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goVG9vbHRpcCwgeyB0aXRsZTogbG9jYWxpemF0aW9uLmNhbmNlbCwgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCB7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uY2FuY2VsLCBvbkNsaWNrOiBoYW5kbGVDYW5jZWwsIGNoaWxkcmVuOiBqc3goQ2FuY2VsSWNvbiwge30pIH0pIH0pLCAoKGlzQ3JlYXRpbmcgJiYgb25DcmVhdGluZ1Jvd1NhdmUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0VkaXRpbmcgJiYgb25FZGl0aW5nUm93U2F2ZSkpICYmIChqc3goVG9vbHRpcCwgeyB0aXRsZTogbG9jYWxpemF0aW9uLnNhdmUsIGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLnNhdmUsIGNvbG9yOiBcImluZm9cIiwgZGlzYWJsZWQ6IGlzU2F2aW5nLCBvbkNsaWNrOiBoYW5kbGVTdWJtaXRSb3csIGNoaWxkcmVuOiBpc1NhdmluZyA/IGpzeChDaXJjdWxhclByb2dyZXNzLCB7IHNpemU6IDE4IH0pIDoganN4KFNhdmVJY29uLCB7fSkgfSkgfSkpXSB9KSkgOiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChCdXR0b24sIHsgb25DbGljazogaGFuZGxlQ2FuY2VsLCBzeDogeyBtaW5XaWR0aDogJzEwMHB4JyB9LCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLmNhbmNlbCB9KSwganN4cyhCdXR0b24sIHsgZGlzYWJsZWQ6IGlzU2F2aW5nLCBvbkNsaWNrOiBoYW5kbGVTdWJtaXRSb3csIHN4OiB7IG1pbldpZHRoOiAnMTAwcHgnIH0sIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIGNoaWxkcmVuOiBbaXNTYXZpbmcgJiYganN4KENpcmN1bGFyUHJvZ3Jlc3MsIHsgY29sb3I6IFwiaW5oZXJpdFwiLCBzaXplOiAxOCB9KSwgbG9jYWxpemF0aW9uLnNhdmVdIH0pXSB9KSkgfSkpO1xufTtcblxuY29uc3QgcGFyc2VDU1NWYXJJZCA9IChpZCkgPT4gaWQucmVwbGFjZSgvW15hLXpBLVowLTldL2csICdfJyk7XG5jb25zdCBnZXRNUlRUaGVtZSA9IChtcnRUaGVtZSwgbXVpVGhlbWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbXJ0VGhlbWVPdmVycmlkZXMgPSBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXJ0VGhlbWUsIG11aVRoZW1lKTtcbiAgICBjb25zdCBiYXNlQmFja2dyb3VuZENvbG9yID0gKF9hID0gbXJ0VGhlbWVPdmVycmlkZXMgPT09IG51bGwgfHwgbXJ0VGhlbWVPdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ydFRoZW1lT3ZlcnJpZGVzLmJhc2VCYWNrZ3JvdW5kQ29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChtdWlUaGVtZS5wYWxldHRlLm1vZGUgPT09ICdkYXJrJ1xuICAgICAgICA/IGxpZ2h0ZW4obXVpVGhlbWUucGFsZXR0ZS5iYWNrZ3JvdW5kLmRlZmF1bHQsIDAuMDUpXG4gICAgICAgIDogbXVpVGhlbWUucGFsZXR0ZS5iYWNrZ3JvdW5kLmRlZmF1bHQpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgYmFzZUJhY2tncm91bmRDb2xvciwgY2VsbE5hdmlnYXRpb25PdXRsaW5lQ29sb3I6IG11aVRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLCBkcmFnZ2luZ0JvcmRlckNvbG9yOiBtdWlUaGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgbWF0Y2hIaWdobGlnaHRDb2xvcjogbXVpVGhlbWUucGFsZXR0ZS5tb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgID8gZGFya2VuKG11aVRoZW1lLnBhbGV0dGUud2FybmluZy5kYXJrLCAwLjI1KVxuICAgICAgICAgICAgOiBsaWdodGVuKG11aVRoZW1lLnBhbGV0dGUud2FybmluZy5saWdodCwgMC41KSwgbWVudUJhY2tncm91bmRDb2xvcjogbGlnaHRlbihiYXNlQmFja2dyb3VuZENvbG9yLCAwLjA3KSwgcGlubmVkUm93QmFja2dyb3VuZENvbG9yOiBhbHBoYShtdWlUaGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgMC4xKSwgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IGFscGhhKG11aVRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLCAwLjIpIH0sIG1ydFRoZW1lT3ZlcnJpZGVzKTtcbn07XG5jb25zdCBjb21tb25DZWxsQmVmb3JlQWZ0ZXJTdHlsZXMgPSB7XG4gICAgY29udGVudDogJ1wiXCInLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIGxlZnQ6IDAsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgekluZGV4OiAtMSxcbn07XG5jb25zdCBnZXRDb21tb25QaW5uZWRDZWxsU3R5bGVzID0gKHsgY29sdW1uLCB0YWJsZSwgdGhlbWUsIH0pID0+IHtcbiAgICBjb25zdCB7IGJhc2VCYWNrZ3JvdW5kQ29sb3IgfSA9IHRhYmxlLm9wdGlvbnMubXJ0VGhlbWU7XG4gICAgY29uc3QgaXNQaW5uZWQgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0SXNQaW5uZWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAnJltkYXRhLXBpbm5lZD1cInRydWVcIl0nOiB7XG4gICAgICAgICAgICAnJjpiZWZvcmUnOiBPYmplY3QuYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiBhbHBoYShkYXJrZW4oYmFzZUJhY2tncm91bmRDb2xvciwgdGhlbWUucGFsZXR0ZS5tb2RlID09PSAnZGFyaycgPyAwLjA1IDogMC4wMSksIDAuOTcpLCBib3hTaGFkb3c6IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICA/IGlzUGlubmVkID09PSAnbGVmdCcgJiYgY29sdW1uLmdldElzTGFzdENvbHVtbihpc1Bpbm5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYC00cHggMCA0cHggLTRweCAke2FscGhhKHRoZW1lLnBhbGV0dGUuZ3JleVs3MDBdLCAwLjUpfSBpbnNldGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXNQaW5uZWQgPT09ICdyaWdodCcgJiYgY29sdW1uLmdldElzRmlyc3RDb2x1bW4oaXNQaW5uZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgNHB4IDAgNHB4IC00cHggJHthbHBoYSh0aGVtZS5wYWxldHRlLmdyZXlbNzAwXSwgMC41KX0gaW5zZXRgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQgfSwgY29tbW9uQ2VsbEJlZm9yZUFmdGVyU3R5bGVzKSxcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbW1vbk1SVENlbGxTdHlsZXMgPSAoeyBjb2x1bW4sIGhlYWRlciwgdGFibGUsIHRhYmxlQ2VsbFByb3BzLCB0aGVtZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb24sIGxheW91dE1vZGUgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZHJhZ2dpbmdDb2x1bW4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZlR5cGUgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBpc0NvbHVtblBpbm5lZCA9IGNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlICE9PSAnZ3JvdXAnICYmIGNvbHVtbi5nZXRJc1Bpbm5lZCgpO1xuICAgIGNvbnN0IHdpZHRoU3R5bGVzID0ge1xuICAgICAgICBtaW5XaWR0aDogYG1heChjYWxjKHZhcigtLSR7aGVhZGVyID8gJ2hlYWRlcicgOiAnY29sJ30tJHtwYXJzZUNTU1ZhcklkKChfYSA9IGhlYWRlciA9PT0gbnVsbCB8fCBoZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhlYWRlci5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29sdW1uLmlkKX0tc2l6ZSkgKiAxcHgpLCAkeyhfYiA9IGNvbHVtbkRlZi5taW5TaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAzMH1weClgLFxuICAgICAgICB3aWR0aDogYGNhbGModmFyKC0tJHtoZWFkZXIgPyAnaGVhZGVyJyA6ICdjb2wnfS0ke3BhcnNlQ1NTVmFySWQoKF9jID0gaGVhZGVyID09PSBudWxsIHx8IGhlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVyLmlkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb2x1bW4uaWQpfS1zaXplKSAqIDFweClgLFxuICAgIH07XG4gICAgaWYgKGxheW91dE1vZGUgPT09ICdncmlkJykge1xuICAgICAgICB3aWR0aFN0eWxlcy5mbGV4ID0gYCR7WzAsIGZhbHNlXS5pbmNsdWRlcyhjb2x1bW5EZWYuZ3JvdylcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiBgdmFyKC0tJHtoZWFkZXIgPyAnaGVhZGVyJyA6ICdjb2wnfS0ke3BhcnNlQ1NTVmFySWQoKF9kID0gaGVhZGVyID09PSBudWxsIHx8IGhlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVyLmlkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb2x1bW4uaWQpfS1zaXplKWB9IDAgYXV0b2A7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxheW91dE1vZGUgPT09ICdncmlkLW5vLWdyb3cnKSB7XG4gICAgICAgIHdpZHRoU3R5bGVzLmZsZXggPSBgJHsrKGNvbHVtbkRlZi5ncm93IHx8IDApfSAwIGF1dG9gO1xuICAgIH1cbiAgICBjb25zdCBwaW5uZWRTdHlsZXMgPSBpc0NvbHVtblBpbm5lZFxuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uUGlubmVkQ2VsbFN0eWxlcyh7IGNvbHVtbiwgdGFibGUsIHRoZW1lIH0pKSwgeyBsZWZ0OiBpc0NvbHVtblBpbm5lZCA9PT0gJ2xlZnQnXG4gICAgICAgICAgICAgICAgPyBgJHtjb2x1bW4uZ2V0U3RhcnQoJ2xlZnQnKX1weGBcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb3BhY2l0eTogMC45NywgcG9zaXRpb246ICdzdGlja3knLCByaWdodDogaXNDb2x1bW5QaW5uZWQgPT09ICdyaWdodCdcbiAgICAgICAgICAgICAgICA/IGAke2NvbHVtbi5nZXRBZnRlcigncmlnaHQnKX1weGBcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCB9KSA6IHt9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGJhY2tncm91bmRDb2xvcjogJ2luaGVyaXQnLCBiYWNrZ3JvdW5kSW1hZ2U6ICdpbmhlcml0JywgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2ZsZXgnIDogdW5kZWZpbmVkLCBqdXN0aWZ5Q29udGVudDogY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgPyAnY2VudGVyJ1xuICAgICAgICAgICAgOiAobGF5b3V0TW9kZSA9PT0gbnVsbCB8fCBsYXlvdXRNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRNb2RlLnN0YXJ0c1dpdGgoJ2dyaWQnKSlcbiAgICAgICAgICAgICAgICA/IHRhYmxlQ2VsbFByb3BzLmFsaWduXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIG9wYWNpdHk6ICgoX2UgPSB0YWJsZS5nZXRTdGF0ZSgpLmRyYWdnaW5nQ29sdW1uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuaWQpID09PSBjb2x1bW4uaWQgfHxcbiAgICAgICAgICAgICgoX2YgPSB0YWJsZS5nZXRTdGF0ZSgpLmhvdmVyZWRDb2x1bW4pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5pZCkgPT09IGNvbHVtbi5pZFxuICAgICAgICAgICAgPyAwLjVcbiAgICAgICAgICAgIDogMSwgcG9zaXRpb246ICdyZWxhdGl2ZScsIHRyYW5zaXRpb246IGVuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uXG4gICAgICAgICAgICA/ICdub25lJ1xuICAgICAgICAgICAgOiBgcGFkZGluZyAxNTBtcyBlYXNlLWluLW91dGAsIHpJbmRleDogY29sdW1uLmdldElzUmVzaXppbmcoKSB8fCAoZHJhZ2dpbmdDb2x1bW4gPT09IG51bGwgfHwgZHJhZ2dpbmdDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdnaW5nQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkXG4gICAgICAgICAgICA/IDJcbiAgICAgICAgICAgIDogY29sdW1uRGVmVHlwZSAhPT0gJ2dyb3VwJyAmJiBpc0NvbHVtblBpbm5lZFxuICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgIDogMCwgJyY6Zm9jdXMtdmlzaWJsZSc6IHtcbiAgICAgICAgICAgIG91dGxpbmU6IGAycHggc29saWQgJHt0YWJsZS5vcHRpb25zLm1ydFRoZW1lLmNlbGxOYXZpZ2F0aW9uT3V0bGluZUNvbG9yfWAsXG4gICAgICAgICAgICBvdXRsaW5lT2Zmc2V0OiAnLTJweCcsXG4gICAgICAgIH0gfSwgcGlubmVkU3R5bGVzKSwgd2lkdGhTdHlsZXMpLCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLnN4LCB0aGVtZSkpO1xufTtcbmNvbnN0IGdldENvbW1vblRvb2xiYXJTdHlsZXMgPSAoeyB0YWJsZSwgfSkgPT4gKHtcbiAgICBhbGlnbkl0ZW1zOiAnZmxleC1zdGFydCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0YWJsZS5vcHRpb25zLm1ydFRoZW1lLmJhc2VCYWNrZ3JvdW5kQ29sb3IsXG4gICAgZGlzcGxheTogJ2dyaWQnLFxuICAgIGZsZXhXcmFwOiAnd3JhcC1yZXZlcnNlJyxcbiAgICBtaW5IZWlnaHQ6ICczLjVyZW0nLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB0cmFuc2l0aW9uOiAnYWxsIDE1MG1zIGVhc2UtaW4tb3V0JyxcbiAgICB6SW5kZXg6IDEsXG59KTtcbmNvbnN0IGZsaXBJY29uU3R5bGVzID0gKHRoZW1lKSA9PiB0aGVtZS5kaXJlY3Rpb24gPT09ICdydGwnXG4gICAgPyB7IHN0eWxlOiB7IHRyYW5zZm9ybTogJ3NjYWxlWCgtMSknIH0gfVxuICAgIDogdW5kZWZpbmVkO1xuY29uc3QgZ2V0Q29tbW9uVG9vbHRpcFByb3BzID0gKHBsYWNlbWVudCkgPT4gKHtcbiAgICBkaXNhYmxlSW50ZXJhY3RpdmU6IHRydWUsXG4gICAgZW50ZXJEZWxheTogMTAwMCxcbiAgICBlbnRlck5leHREZWxheTogMTAwMCxcbiAgICBwbGFjZW1lbnQsXG59KTtcblxuY29uc3QgTVJUX0FjdGlvbk1lbnVJdGVtID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgaWNvbiwgbGFiZWwsIG9uT3BlblN1Yk1lbnUsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiaWNvblwiLCBcImxhYmVsXCIsIFwib25PcGVuU3ViTWVudVwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWNvbnM6IHsgQXJyb3dSaWdodEljb24gfSwgfSwgfSA9IHRhYmxlO1xuICAgIHJldHVybiAoanN4cyhNZW51SXRlbSwgT2JqZWN0LmFzc2lnbih7IHN4OiB7XG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICBtaW5XaWR0aDogJzEyMHB4JyxcbiAgICAgICAgICAgIG15OiAwLFxuICAgICAgICAgICAgcHk6ICc2cHgnLFxuICAgICAgICB9LCB0YWJJbmRleDogMCB9LCByZXN0LCB7IGNoaWxkcmVuOiBbanN4cyhCb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2pzeChMaXN0SXRlbUljb24sIHsgY2hpbGRyZW46IGljb24gfSksIGxhYmVsXSB9KSwgb25PcGVuU3ViTWVudSAmJiAoanN4KEljb25CdXR0b24sIHsgb25DbGljazogb25PcGVuU3ViTWVudSwgb25Nb3VzZUVudGVyOiBvbk9wZW5TdWJNZW51LCBzaXplOiBcInNtYWxsXCIsIHN4OiB7IHA6IDAgfSwgY2hpbGRyZW46IGpzeChBcnJvd1JpZ2h0SWNvbiwge30pIH0pKV0gfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9Sb3dBY3Rpb25NZW51ID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgYW5jaG9yRWwsIGhhbmRsZUVkaXQsIHJvdywgc2V0QW5jaG9yRWwsIHN0YXRpY1Jvd0luZGV4LCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImFuY2hvckVsXCIsIFwiaGFuZGxlRWRpdFwiLCBcInJvd1wiLCBcInNldEFuY2hvckVsXCIsIFwic3RhdGljUm93SW5kZXhcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlZGl0RGlzcGxheU1vZGUsIGVuYWJsZUVkaXRpbmcsIGljb25zOiB7IEVkaXRJY29uIH0sIGxvY2FsaXphdGlvbiwgbXJ0VGhlbWU6IHsgbWVudUJhY2tncm91bmRDb2xvciB9LCByZW5kZXJSb3dBY3Rpb25NZW51SXRlbXMsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHkgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgbWVudUl0ZW1zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IGVkaXRJdGVtID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGVuYWJsZUVkaXRpbmcsIHJvdykgJiZcbiAgICAgICAgICAgIFsnbW9kYWwnLCAncm93J10uaW5jbHVkZXMoZWRpdERpc3BsYXlNb2RlKSAmJiAoanN4KE1SVF9BY3Rpb25NZW51SXRlbSwgeyBpY29uOiBqc3goRWRpdEljb24sIHt9KSwgbGFiZWw6IGxvY2FsaXphdGlvbi5lZGl0LCBvbkNsaWNrOiBoYW5kbGVFZGl0LCB0YWJsZTogdGFibGUgfSwgJ2VkaXQnKSk7XG4gICAgICAgIGlmIChlZGl0SXRlbSlcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goZWRpdEl0ZW0pO1xuICAgICAgICBjb25zdCByb3dBY3Rpb25NZW51SXRlbXMgPSByZW5kZXJSb3dBY3Rpb25NZW51SXRlbXMgPT09IG51bGwgfHwgcmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJSb3dBY3Rpb25NZW51SXRlbXMoe1xuICAgICAgICAgICAgY2xvc2VNZW51OiAoKSA9PiBzZXRBbmNob3JFbChudWxsKSxcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIHN0YXRpY1Jvd0luZGV4LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm93QWN0aW9uTWVudUl0ZW1zID09PSBudWxsIHx8IHJvd0FjdGlvbk1lbnVJdGVtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93QWN0aW9uTWVudUl0ZW1zLmxlbmd0aClcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goLi4ucm93QWN0aW9uTWVudUl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sIFtyZW5kZXJSb3dBY3Rpb25NZW51SXRlbXMsIHJvdywgc3RhdGljUm93SW5kZXgsIHRhYmxlXSk7XG4gICAgaWYgKCFtZW51SXRlbXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeChNZW51LCBPYmplY3QuYXNzaWduKHsgTWVudUxpc3RQcm9wczoge1xuICAgICAgICAgICAgZGVuc2U6IGRlbnNpdHkgPT09ICdjb21wYWN0JyxcbiAgICAgICAgICAgIHN4OiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtZW51QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgYW5jaG9yRWw6IGFuY2hvckVsLCBkaXNhYmxlU2Nyb2xsTG9jazogdHJ1ZSwgb25DbGljazogKGV2ZW50KSA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgb25DbG9zZTogKCkgPT4gc2V0QW5jaG9yRWwobnVsbCksIG9wZW46ICEhYW5jaG9yRWwgfSwgcmVzdCwgeyBjaGlsZHJlbjogbWVudUl0ZW1zIH0pKSk7XG59O1xuXG5jb25zdCBjb21tb25JY29uQnV0dG9uU3R5bGVzID0ge1xuICAgICcmOmhvdmVyJzoge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgIH0sXG4gICAgaGVpZ2h0OiAnMnJlbScsXG4gICAgbWw6ICcxMHB4JyxcbiAgICBvcGFjaXR5OiAwLjUsXG4gICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMTUwbXMnLFxuICAgIHdpZHRoOiAnMnJlbScsXG59O1xuY29uc3QgTVJUX1RvZ2dsZVJvd0FjdGlvbk1lbnVCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgY2VsbCwgcm93LCBzdGF0aWNSb3dJbmRleCwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjZWxsXCIsIFwicm93XCIsIFwic3RhdGljUm93SW5kZXhcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBjcmVhdGVEaXNwbGF5TW9kZSwgZWRpdERpc3BsYXlNb2RlLCBlbmFibGVFZGl0aW5nLCBpY29uczogeyBFZGl0SWNvbiwgTW9yZUhvcml6SWNvbiB9LCBsb2NhbGl6YXRpb24sIHJlbmRlclJvd0FjdGlvbk1lbnVJdGVtcywgcmVuZGVyUm93QWN0aW9ucywgfSwgc2V0RWRpdGluZ1JvdywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIGVkaXRpbmdSb3cgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNDcmVhdGluZyA9IChjcmVhdGluZ1JvdyA9PT0gbnVsbCB8fCBjcmVhdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlYXRpbmdSb3cuaWQpID09PSByb3cuaWQ7XG4gICAgY29uc3QgaXNFZGl0aW5nID0gKGVkaXRpbmdSb3cgPT09IG51bGwgfHwgZWRpdGluZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdGluZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCBzaG93RWRpdEFjdGlvbkJ1dHRvbnMgPSAoaXNDcmVhdGluZyAmJiBjcmVhdGVEaXNwbGF5TW9kZSA9PT0gJ3JvdycpIHx8XG4gICAgICAgIChpc0VkaXRpbmcgJiYgZWRpdERpc3BsYXlNb2RlID09PSAncm93Jyk7XG4gICAgY29uc3QgW2FuY2hvckVsLCBzZXRBbmNob3JFbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBoYW5kbGVPcGVuUm93QWN0aW9uTWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0QW5jaG9yRWwoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTdGFydEVkaXRNb2RlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzZXRFZGl0aW5nUm93KE9iamVjdC5hc3NpZ24oe30sIHJvdykpO1xuICAgICAgICBzZXRBbmNob3JFbChudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiByZW5kZXJSb3dBY3Rpb25zICYmICFzaG93RWRpdEFjdGlvbkJ1dHRvbnMgPyAocmVuZGVyUm93QWN0aW9ucyh7IGNlbGwsIHJvdywgc3RhdGljUm93SW5kZXgsIHRhYmxlIH0pKSA6IHNob3dFZGl0QWN0aW9uQnV0dG9ucyA/IChqc3goTVJUX0VkaXRBY3Rpb25CdXR0b25zLCB7IHJvdzogcm93LCB0YWJsZTogdGFibGUgfSkpIDogIXJlbmRlclJvd0FjdGlvbk1lbnVJdGVtcyAmJlxuICAgICAgICAgICAgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGVuYWJsZUVkaXRpbmcsIHJvdykgJiZcbiAgICAgICAgICAgIFsnbW9kYWwnLCAncm93J10uaW5jbHVkZXMoZWRpdERpc3BsYXlNb2RlKSA/IChqc3goVG9vbHRpcCwgeyBwbGFjZW1lbnQ6IFwicmlnaHRcIiwgdGl0bGU6IGxvY2FsaXphdGlvbi5lZGl0LCBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmVkaXQsIG9uQ2xpY2s6IGhhbmRsZVN0YXJ0RWRpdE1vZGUsIHN4OiBjb21tb25JY29uQnV0dG9uU3R5bGVzIH0sIHJlc3QsIHsgY2hpbGRyZW46IGpzeChFZGl0SWNvbiwge30pIH0pKSB9KSkgOiAoKF9iID0gcmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlclJvd0FjdGlvbk1lbnVJdGVtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyUm93QWN0aW9uTWVudUl0ZW1zKHtcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIHN0YXRpY1Jvd0luZGV4LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA/IChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFRvb2x0aXAsIE9iamVjdC5hc3NpZ24oe30sIGdldENvbW1vblRvb2x0aXBQcm9wcygpLCB7IHRpdGxlOiBsb2NhbGl6YXRpb24ucm93QWN0aW9ucywgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5yb3dBY3Rpb25zLCBvbkNsaWNrOiBoYW5kbGVPcGVuUm93QWN0aW9uTWVudSwgc2l6ZTogXCJzbWFsbFwiLCBzeDogY29tbW9uSWNvbkJ1dHRvblN0eWxlcyB9LCByZXN0LCB7IGNoaWxkcmVuOiBqc3goTW9yZUhvcml6SWNvbiwge30pIH0pKSB9KSksIGpzeChNUlRfUm93QWN0aW9uTWVudSwgeyBhbmNob3JFbDogYW5jaG9yRWwsIGhhbmRsZUVkaXQ6IGhhbmRsZVN0YXJ0RWRpdE1vZGUsIHJvdzogcm93LCBzZXRBbmNob3JFbDogc2V0QW5jaG9yRWwsIHN0YXRpY1Jvd0luZGV4OiBzdGF0aWNSb3dJbmRleCwgdGFibGU6IHRhYmxlIH0pXSB9KSkgOiBudWxsIH0pKTtcbn07XG5cbmNvbnN0IGdldE1SVF9Sb3dBY3Rpb25zQ29sdW1uRGVmID0gKHRhYmxlT3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgQ2VsbDogKHsgY2VsbCwgcm93LCBzdGF0aWNSb3dJbmRleCwgdGFibGUgfSkgPT4gKGpzeChNUlRfVG9nZ2xlUm93QWN0aW9uTWVudUJ1dHRvbiwgeyBjZWxsOiBjZWxsLCByb3c6IHJvdywgc3RhdGljUm93SW5kZXg6IHN0YXRpY1Jvd0luZGV4LCB0YWJsZTogdGFibGUgfSkpIH0sIGRlZmF1bHREaXNwbGF5Q29sdW1uUHJvcHMoe1xuICAgICAgICBoZWFkZXI6ICdhY3Rpb25zJyxcbiAgICAgICAgaWQ6ICdtcnQtcm93LWFjdGlvbnMnLFxuICAgICAgICBzaXplOiA3MCxcbiAgICAgICAgdGFibGVPcHRpb25zLFxuICAgIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9HcmFiSGFuZGxlQnV0dG9uID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iLCBfYztcbiAgICB2YXIgeyBsb2NhdGlvbiwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJsb2NhdGlvblwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWNvbnM6IHsgRHJhZ0hhbmRsZUljb24gfSwgbG9jYWxpemF0aW9uLCB9LCB9ID0gdGFibGU7XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCd0b3AnKSwgeyB0aXRsZTogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24ubW92ZSwgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IChfYyA9IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGxvY2FsaXphdGlvbi5tb3ZlLCBkaXNhYmxlUmlwcGxlOiB0cnVlLCBkcmFnZ2FibGU6IFwidHJ1ZVwiLCBzaXplOiBcInNtYWxsXCIgfSwgcmVzdCwgeyBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIChfYSA9IHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZXN0LCBlKTtcbiAgICAgICAgICAgIH0sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgJyY6YWN0aXZlJzoge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdncmFiYmluZycsXG4gICAgICAgICAgICAgICAgfSwgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB9LCBjdXJzb3I6ICdncmFiJywgbTogJzAgLTAuMXJlbScsIG9wYWNpdHk6IGxvY2F0aW9uID09PSAncm93JyA/IDEgOiAwLjUsIHA6ICcycHgnLCB0cmFuc2l0aW9uOiAnYWxsIDE1MG1zIGVhc2UtaW4tb3V0JyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMocmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnN4LCB0aGVtZSkpKSwgdGl0bGU6IHVuZGVmaW5lZCwgY2hpbGRyZW46IGpzeChEcmFnSGFuZGxlSWNvbiwge30pIH0pKSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlQm9keVJvd0dyYWJIYW5kbGUgPSAoX2EpID0+IHtcbiAgICB2YXIgeyByb3csIHJvd1JlZiwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJyb3dcIiwgXCJyb3dSZWZcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IG11aVJvd0RyYWdIYW5kbGVQcm9wcyB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgaWNvbkJ1dHRvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpUm93RHJhZ0hhbmRsZVByb3BzLCB7XG4gICAgICAgIHJvdyxcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBpY29uQnV0dG9uUHJvcHMgPT09IG51bGwgfHwgaWNvbkJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uQnV0dG9uUHJvcHMub25EcmFnU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGljb25CdXR0b25Qcm9wcywgZXZlbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShyb3dSZWYuY3VycmVudCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUuc2V0RHJhZ2dpbmdSb3cocm93KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZURyYWdFbmQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBpY29uQnV0dG9uUHJvcHMgPT09IG51bGwgfHwgaWNvbkJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uQnV0dG9uUHJvcHMub25EcmFnRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpY29uQnV0dG9uUHJvcHMsIGV2ZW50KTtcbiAgICAgICAgdGFibGUuc2V0RHJhZ2dpbmdSb3cobnVsbCk7XG4gICAgICAgIHRhYmxlLnNldEhvdmVyZWRSb3cobnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChNUlRfR3JhYkhhbmRsZUJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7fSwgaWNvbkJ1dHRvblByb3BzLCB7IGxvY2F0aW9uOiBcInJvd1wiLCBvbkRyYWdFbmQ6IGhhbmRsZURyYWdFbmQsIG9uRHJhZ1N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsIHRhYmxlOiB0YWJsZSB9KSkpO1xufTtcblxuY29uc3QgZ2V0TVJUX1Jvd0RyYWdDb2x1bW5EZWYgPSAodGFibGVPcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBDZWxsOiAoeyByb3csIHJvd1JlZiwgdGFibGUgfSkgPT4gKGpzeChNUlRfVGFibGVCb2R5Um93R3JhYkhhbmRsZSwgeyByb3c6IHJvdywgcm93UmVmOiByb3dSZWYsIHRhYmxlOiB0YWJsZSB9KSksIGdyb3c6IGZhbHNlIH0sIGRlZmF1bHREaXNwbGF5Q29sdW1uUHJvcHMoe1xuICAgICAgICBoZWFkZXI6ICdtb3ZlJyxcbiAgICAgICAgaWQ6ICdtcnQtcm93LWRyYWcnLFxuICAgICAgICBzaXplOiA2MCxcbiAgICAgICAgdGFibGVPcHRpb25zLFxuICAgIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9FeHBhbmRBbGxCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0Q2FuU29tZVJvd3NFeHBhbmQsIGdldElzQWxsUm93c0V4cGFuZGVkLCBnZXRJc1NvbWVSb3dzRXhwYW5kZWQsIGdldFN0YXRlLCBvcHRpb25zOiB7IGljb25zOiB7IEtleWJvYXJkRG91YmxlQXJyb3dEb3duSWNvbiB9LCBsb2NhbGl6YXRpb24sIG11aUV4cGFuZEFsbEJ1dHRvblByb3BzLCByZW5kZXJEZXRhaWxQYW5lbCwgfSwgdG9nZ2xlQWxsUm93c0V4cGFuZGVkLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5LCBpc0xvYWRpbmcgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaWNvbkJ1dHRvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpRXhwYW5kQWxsQnV0dG9uUHJvcHMsIHtcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICBjb25zdCBpc0FsbFJvd3NFeHBhbmRlZCA9IGdldElzQWxsUm93c0V4cGFuZGVkKCk7XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCksIHsgdGl0bGU6IChfYiA9IGljb25CdXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBpY29uQnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGljb25CdXR0b25Qcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKGlzQWxsUm93c0V4cGFuZGVkID8gbG9jYWxpemF0aW9uLmNvbGxhcHNlQWxsIDogbG9jYWxpemF0aW9uLmV4cGFuZEFsbCksIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHsgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5leHBhbmRBbGwsIGRpc2FibGVkOiBpc0xvYWRpbmcgfHwgKCFyZW5kZXJEZXRhaWxQYW5lbCAmJiAhZ2V0Q2FuU29tZVJvd3NFeHBhbmQoKSksIG9uQ2xpY2s6ICgpID0+IHRvZ2dsZUFsbFJvd3NFeHBhbmRlZCghaXNBbGxSb3dzRXhwYW5kZWQpIH0sIGljb25CdXR0b25Qcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGhlaWdodDogZGVuc2l0eSA9PT0gJ2NvbXBhY3QnID8gJzEuNzVyZW0nIDogJzIuMjVyZW0nLCBtdDogZGVuc2l0eSAhPT0gJ2NvbXBhY3QnID8gJy0wLjI1cmVtJyA6IHVuZGVmaW5lZCwgd2lkdGg6IGRlbnNpdHkgPT09ICdjb21wYWN0JyA/ICcxLjc1cmVtJyA6ICcyLjI1cmVtJyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoaWNvbkJ1dHRvblByb3BzID09PSBudWxsIHx8IGljb25CdXR0b25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWNvbkJ1dHRvblByb3BzLnN4LCB0aGVtZSkpKSwgdGl0bGU6IHVuZGVmaW5lZCwgY2hpbGRyZW46IChfYyA9IGljb25CdXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBpY29uQnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGljb25CdXR0b25Qcm9wcy5jaGlsZHJlbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKGpzeChLZXlib2FyZERvdWJsZUFycm93RG93bkljb24sIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgke2lzQWxsUm93c0V4cGFuZGVkID8gLTE4MCA6IGdldElzU29tZVJvd3NFeHBhbmRlZCgpID8gLTkwIDogMH1kZWcpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTUwbXMnLFxuICAgICAgICAgICAgICAgICAgICB9IH0pKSB9KSkgfSkgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9FeHBhbmRCdXR0b24gPSAoeyByb3csIHN0YXRpY1Jvd0luZGV4LCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgRXhwYW5kTW9yZUljb24gfSwgbG9jYWxpemF0aW9uLCBtdWlFeHBhbmRCdXR0b25Qcm9wcywgcG9zaXRpb25FeHBhbmRDb2x1bW4sIHJlbmRlckRldGFpbFBhbmVsLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGljb25CdXR0b25Qcm9wcyA9IHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlFeHBhbmRCdXR0b25Qcm9wcywge1xuICAgICAgICByb3csXG4gICAgICAgIHN0YXRpY1Jvd0luZGV4LFxuICAgICAgICB0YWJsZSxcbiAgICB9KTtcbiAgICBjb25zdCBjYW5FeHBhbmQgPSByb3cuZ2V0Q2FuRXhwYW5kKCk7XG4gICAgY29uc3QgaXNFeHBhbmRlZCA9IHJvdy5nZXRJc0V4cGFuZGVkKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlRXhwYW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgICAoX2EgPSBpY29uQnV0dG9uUHJvcHMgPT09IG51bGwgfHwgaWNvbkJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uQnV0dG9uUHJvcHMub25DbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaWNvbkJ1dHRvblByb3BzLCBldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBkZXRhaWxQYW5lbCA9ICEhKHJlbmRlckRldGFpbFBhbmVsID09PSBudWxsIHx8IHJlbmRlckRldGFpbFBhbmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJEZXRhaWxQYW5lbCh7IHJvdywgdGFibGUgfSkpO1xuICAgIHJldHVybiAoanN4KFRvb2x0aXAsIE9iamVjdC5hc3NpZ24oeyBkaXNhYmxlSG92ZXJMaXN0ZW5lcjogIWNhbkV4cGFuZCAmJiAhZGV0YWlsUGFuZWwgfSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCksIHsgdGl0bGU6IChfYSA9IGljb25CdXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBpY29uQnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGljb25CdXR0b25Qcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGlzRXhwYW5kZWQgPyBsb2NhbGl6YXRpb24uY29sbGFwc2UgOiBsb2NhbGl6YXRpb24uZXhwYW5kKSwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmV4cGFuZCwgZGlzYWJsZWQ6ICFjYW5FeHBhbmQgJiYgIWRldGFpbFBhbmVsIH0sIGljb25CdXR0b25Qcm9wcywgeyBvbkNsaWNrOiBoYW5kbGVUb2dnbGVFeHBhbmQsIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgaGVpZ2h0OiBkZW5zaXR5ID09PSAnY29tcGFjdCcgPyAnMS43NXJlbScgOiAnMi4yNXJlbScsIG9wYWNpdHk6ICFjYW5FeHBhbmQgJiYgIWRldGFpbFBhbmVsID8gMC4zIDogMSwgW3RoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCcgfHwgcG9zaXRpb25FeHBhbmRDb2x1bW4gPT09ICdsYXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnbXInXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdtbCddOiBgJHtyb3cuZGVwdGggKiAxNn1weGAsIHdpZHRoOiBkZW5zaXR5ID09PSAnY29tcGFjdCcgPyAnMS43NXJlbScgOiAnMi4yNXJlbScgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGljb25CdXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBpY29uQnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGljb25CdXR0b25Qcm9wcy5zeCwgdGhlbWUpKSksIHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiAoX2IgPSBpY29uQnV0dG9uUHJvcHMgPT09IG51bGwgfHwgaWNvbkJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uQnV0dG9uUHJvcHMuY2hpbGRyZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChqc3goRXhwYW5kTW9yZUljb24sIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgkeyFjYW5FeHBhbmQgJiYgIXJlbmRlckRldGFpbFBhbmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwb3NpdGlvbkV4cGFuZENvbHVtbiA9PT0gJ2xhc3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyA5MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC05MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXNFeHBhbmRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC0xODBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwfWRlZylgLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAxNTBtcycsXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpIH0pKSB9KSB9KSkpO1xufTtcblxuY29uc3QgZ2V0TVJUX1Jvd0V4cGFuZENvbHVtbkRlZiA9ICh0YWJsZU9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBkZWZhdWx0Q29sdW1uLCBlbmFibGVFeHBhbmRBbGwsIGdyb3VwZWRDb2x1bW5Nb2RlLCBwb3NpdGlvbkV4cGFuZENvbHVtbiwgcmVuZGVyRGV0YWlsUGFuZWwsIHN0YXRlOiB7IGdyb3VwaW5nIH0sIH0gPSB0YWJsZU9wdGlvbnM7XG4gICAgY29uc3QgYWxpZ25Qcm9wcyA9IHBvc2l0aW9uRXhwYW5kQ29sdW1uID09PSAnbGFzdCdcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBhbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IENlbGw6ICh7IGNlbGwsIGNvbHVtbiwgcm93LCBzdGF0aWNSb3dJbmRleCwgdGFibGUgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRCdXR0b25Qcm9wcyA9IHsgcm93LCBzdGF0aWNSb3dJbmRleCwgdGFibGUgfTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlJvd3NMZW5ndGggPSAoX2EgPSByb3cuc3ViUm93cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChncm91cGVkQ29sdW1uTW9kZSA9PT0gJ3JlbW92ZScgJiYgcm93Lmdyb3VwaW5nQ29sdW1uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeHMoU3RhY2ssIHsgYWxpZ25JdGVtczogXCJjZW50ZXJcIiwgZmxleERpcmVjdGlvbjogXCJyb3dcIiwgZ2FwOiBcIjAuMjVyZW1cIiwgY2hpbGRyZW46IFtqc3goTVJUX0V4cGFuZEJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7fSwgZXhwYW5kQnV0dG9uUHJvcHMpKSwganN4KFRvb2x0aXAsIE9iamVjdC5hc3NpZ24oe30sIGdldENvbW1vblRvb2x0aXBQcm9wcygncmlnaHQnKSwgeyB0aXRsZTogdGFibGUuZ2V0Q29sdW1uKHJvdy5ncm91cGluZ0NvbHVtbklkKS5jb2x1bW5EZWYuaGVhZGVyLCBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiByb3cuZ3JvdXBpbmdWYWx1ZSB9KSB9KSksICEhc3ViUm93c0xlbmd0aCAmJiBqc3hzKFwic3BhblwiLCB7IGNoaWxkcmVuOiBbXCIoXCIsIHN1YlJvd3NMZW5ndGgsIFwiKVwiXSB9KV0gfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KE1SVF9FeHBhbmRCdXR0b24sIE9iamVjdC5hc3NpZ24oe30sIGV4cGFuZEJ1dHRvblByb3BzKSksIChfYyA9IChfYiA9IGNvbHVtbi5jb2x1bW5EZWYpLkdyb3VwZWRDZWxsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgeyBjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUgfSldIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgSGVhZGVyOiBlbmFibGVFeHBhbmRBbGxcbiAgICAgICAgICAgID8gKHsgdGFibGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goTVJUX0V4cGFuZEFsbEJ1dHRvbiwgeyB0YWJsZTogdGFibGUgfSksIGdyb3VwZWRDb2x1bW5Nb2RlID09PSAncmVtb3ZlJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2EgPSBncm91cGluZyA9PT0gbnVsbCB8fCBncm91cGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBpbmcubWFwKChncm91cGVkQ29sdW1uSWQpID0+IHRhYmxlLmdldENvbHVtbihncm91cGVkQ29sdW1uSWQpLmNvbHVtbkRlZi5oZWFkZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignLCAnKSldIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBtdWlUYWJsZUJvZHlDZWxsUHJvcHM6IGFsaWduUHJvcHMsIG11aVRhYmxlSGVhZENlbGxQcm9wczogYWxpZ25Qcm9wcyB9LCBkZWZhdWx0RGlzcGxheUNvbHVtblByb3BzKHtcbiAgICAgICAgaGVhZGVyOiAnZXhwYW5kJyxcbiAgICAgICAgaWQ6ICdtcnQtcm93LWV4cGFuZCcsXG4gICAgICAgIHNpemU6IGdyb3VwZWRDb2x1bW5Nb2RlID09PSAncmVtb3ZlJ1xuICAgICAgICAgICAgPyAoKF9hID0gZGVmYXVsdENvbHVtbiA9PT0gbnVsbCB8fCBkZWZhdWx0Q29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0Q29sdW1uLnNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE4MClcbiAgICAgICAgICAgIDogcmVuZGVyRGV0YWlsUGFuZWxcbiAgICAgICAgICAgICAgICA/IGVuYWJsZUV4cGFuZEFsbFxuICAgICAgICAgICAgICAgICAgICA/IDYwXG4gICAgICAgICAgICAgICAgICAgIDogNzBcbiAgICAgICAgICAgICAgICA6IDEwMCxcbiAgICAgICAgdGFibGVPcHRpb25zLFxuICAgIH0pKTtcbn07XG5cbmNvbnN0IGdldE1SVF9Sb3dOdW1iZXJzQ29sdW1uRGVmID0gKHRhYmxlT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgbG9jYWxpemF0aW9uLCByb3dOdW1iZXJEaXNwbGF5TW9kZSB9ID0gdGFibGVPcHRpb25zO1xuICAgIGNvbnN0IHsgcGFnaW5hdGlvbjogeyBwYWdlSW5kZXgsIHBhZ2VTaXplIH0sIH0gPSB0YWJsZU9wdGlvbnMuc3RhdGU7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBDZWxsOiAoeyByb3csIHN0YXRpY1Jvd0luZGV4IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoKF9hID0gKHJvd051bWJlckRpc3BsYXlNb2RlID09PSAnc3RhdGljJ1xuICAgICAgICAgICAgICAgID8gKHN0YXRpY1Jvd0luZGV4IHx8IDApICsgKHBhZ2VTaXplIHx8IDApICogKHBhZ2VJbmRleCB8fCAwKVxuICAgICAgICAgICAgICAgIDogcm93LmluZGV4KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyAxO1xuICAgICAgICB9LCBIZWFkZXI6ICgpID0+IGxvY2FsaXphdGlvbi5yb3dOdW1iZXIsIGdyb3c6IGZhbHNlIH0sIGRlZmF1bHREaXNwbGF5Q29sdW1uUHJvcHMoe1xuICAgICAgICBoZWFkZXI6ICdyb3dOdW1iZXJzJyxcbiAgICAgICAgaWQ6ICdtcnQtcm93LW51bWJlcnMnLFxuICAgICAgICBzaXplOiA1MCxcbiAgICAgICAgdGFibGVPcHRpb25zLFxuICAgIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Sb3dQaW5CdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgeyBwaW5uaW5nUG9zaXRpb24sIHJvdywgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJwaW5uaW5nUG9zaXRpb25cIiwgXCJyb3dcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGljb25zOiB7IENsb3NlSWNvbiwgUHVzaFBpbkljb24gfSwgbG9jYWxpemF0aW9uLCByb3dQaW5uaW5nRGlzcGxheU1vZGUsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCBpc1Bpbm5lZCA9IHJvdy5nZXRJc1Bpbm5lZCgpO1xuICAgIGNvbnN0IFt0b29sdGlwT3BlbmVkLCBzZXRUb29sdGlwT3BlbmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBoYW5kbGVUb2dnbGVQaW4gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0VG9vbHRpcE9wZW5lZChmYWxzZSk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByb3cucGluKGlzUGlubmVkID8gZmFsc2UgOiBwaW5uaW5nUG9zaXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCksIHsgb3BlbjogdG9vbHRpcE9wZW5lZCwgdGl0bGU6IGlzUGlubmVkID8gbG9jYWxpemF0aW9uLnVucGluIDogbG9jYWxpemF0aW9uLnBpbiwgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5waW4sIG9uQmx1cjogKCkgPT4gc2V0VG9vbHRpcE9wZW5lZChmYWxzZSksIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZVBpbiwgb25Gb2N1czogKCkgPT4gc2V0VG9vbHRpcE9wZW5lZCh0cnVlKSwgb25Nb3VzZUVudGVyOiAoKSA9PiBzZXRUb29sdGlwT3BlbmVkKHRydWUpLCBvbk1vdXNlTGVhdmU6ICgpID0+IHNldFRvb2x0aXBPcGVuZWQoZmFsc2UpLCBzaXplOiBcInNtYWxsXCIgfSwgcmVzdCwgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGhlaWdodDogJzI0cHgnLCB3aWR0aDogJzI0cHgnIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhyZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3Quc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogaXNQaW5uZWQgPyAoanN4KENsb3NlSWNvbiwge30pKSA6IChqc3goUHVzaFBpbkljb24sIHsgZm9udFNpemU6IFwic21hbGxcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKCR7cm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSAnc3RpY2t5J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAxMzVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGlubmluZ1Bvc2l0aW9uID09PSAndG9wJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMTgwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwfWRlZylgLFxuICAgICAgICAgICAgICAgIH0gfSkpIH0pKSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlQm9keVJvd1BpbkJ1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciB7IHJvdywgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJyb3dcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVSb3dQaW5uaW5nLCByb3dQaW5uaW5nRGlzcGxheU1vZGUgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZGVuc2l0eSB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBjYW5QaW4gPSBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoZW5hYmxlUm93UGlubmluZywgcm93KTtcbiAgICBpZiAoIWNhblBpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgcm93UGluQnV0dG9uUHJvcHMgPSBPYmplY3QuYXNzaWduKHsgcm93LFxuICAgICAgICB0YWJsZSB9LCByZXN0KTtcbiAgICBpZiAocm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSAndG9wLWFuZC1ib3R0b20nICYmICFyb3cuZ2V0SXNQaW5uZWQoKSkge1xuICAgICAgICByZXR1cm4gKGpzeHMoQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IGRlbnNpdHkgPT09ICdjb21wYWN0JyA/ICdyb3cnIDogJ2NvbHVtbicsXG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogW2pzeChNUlRfUm93UGluQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgcGlubmluZ1Bvc2l0aW9uOiBcInRvcFwiIH0sIHJvd1BpbkJ1dHRvblByb3BzKSksIGpzeChNUlRfUm93UGluQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgcGlubmluZ1Bvc2l0aW9uOiBcImJvdHRvbVwiIH0sIHJvd1BpbkJ1dHRvblByb3BzKSldIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTVJUX1Jvd1BpbkJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7IHBpbm5pbmdQb3NpdGlvbjogcm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSAnYm90dG9tJyA/ICdib3R0b20nIDogJ3RvcCcgfSwgcm93UGluQnV0dG9uUHJvcHMpKSk7XG59O1xuXG5jb25zdCBnZXRNUlRfUm93UGlubmluZ0NvbHVtbkRlZiA9ICh0YWJsZU9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IENlbGw6ICh7IHJvdywgdGFibGUgfSkgPT4gKGpzeChNUlRfVGFibGVCb2R5Um93UGluQnV0dG9uLCB7IHJvdzogcm93LCB0YWJsZTogdGFibGUgfSkpLCBncm93OiBmYWxzZSB9LCBkZWZhdWx0RGlzcGxheUNvbHVtblByb3BzKHtcbiAgICAgICAgaGVhZGVyOiAncGluJyxcbiAgICAgICAgaWQ6ICdtcnQtcm93LXBpbicsXG4gICAgICAgIHNpemU6IDYwLFxuICAgICAgICB0YWJsZU9wdGlvbnMsXG4gICAgfSkpO1xufTtcblxuY29uc3QgTVJUX1NlbGVjdENoZWNrYm94ID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IHJvdywgc3RhdGljUm93SW5kZXgsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wicm93XCIsIFwic3RhdGljUm93SW5kZXhcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiwgbG9jYWxpemF0aW9uLCBtdWlTZWxlY3RBbGxDaGVja2JveFByb3BzLCBtdWlTZWxlY3RDaGVja2JveFByb3BzLCBzZWxlY3RBbGxNb2RlLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5LCBpc0xvYWRpbmcgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gIXJvdztcbiAgICBjb25zdCBhbGxSb3dzU2VsZWN0ZWQgPSBzZWxlY3RBbGxcbiAgICAgICAgPyBzZWxlY3RBbGxNb2RlID09PSAncGFnZSdcbiAgICAgICAgICAgID8gdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKClcbiAgICAgICAgICAgIDogdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQoKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc0NoZWNrZWQgPSBzZWxlY3RBbGxcbiAgICAgICAgPyBhbGxSb3dzU2VsZWN0ZWRcbiAgICAgICAgOiBnZXRJc1Jvd1NlbGVjdGVkKHsgcm93LCB0YWJsZSB9KTtcbiAgICBjb25zdCBjaGVja2JveFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoc2VsZWN0QWxsXG4gICAgICAgID8gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVNlbGVjdEFsbENoZWNrYm94UHJvcHMsIHsgdGFibGUgfSlcbiAgICAgICAgOiBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpU2VsZWN0Q2hlY2tib3hQcm9wcywge1xuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgc3RhdGljUm93SW5kZXgsXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgfSkpKSwgcmVzdCk7XG4gICAgY29uc3Qgb25TZWxlY3Rpb25DaGFuZ2UgPSByb3dcbiAgICAgICAgPyBnZXRNUlRfUm93U2VsZWN0aW9uSGFuZGxlcih7XG4gICAgICAgICAgICByb3csXG4gICAgICAgICAgICBzdGF0aWNSb3dJbmRleCxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblNlbGVjdEFsbENoYW5nZSA9IGdldE1SVF9TZWxlY3RBbGxIYW5kbGVyKHsgdGFibGUgfSk7XG4gICAgY29uc3QgY29tbW9uUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyAnYXJpYS1sYWJlbCc6IHNlbGVjdEFsbFxuICAgICAgICAgICAgPyBsb2NhbGl6YXRpb24udG9nZ2xlU2VsZWN0QWxsXG4gICAgICAgICAgICA6IGxvY2FsaXphdGlvbi50b2dnbGVTZWxlY3RSb3csIGNoZWNrZWQ6IGlzQ2hlY2tlZCwgZGlzYWJsZWQ6IGlzTG9hZGluZyB8fCAocm93ICYmICFyb3cuZ2V0Q2FuU2VsZWN0KCkpIHx8IChyb3cgPT09IG51bGwgfHwgcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3cuaWQpID09PSAnbXJ0LXJvdy1jcmVhdGUnLCBpbnB1dFByb3BzOiB7XG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHNlbGVjdEFsbFxuICAgICAgICAgICAgICAgID8gbG9jYWxpemF0aW9uLnRvZ2dsZVNlbGVjdEFsbFxuICAgICAgICAgICAgICAgIDogbG9jYWxpemF0aW9uLnRvZ2dsZVNlbGVjdFJvdyxcbiAgICAgICAgfSwgb25DaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBzZWxlY3RBbGwgPyBvblNlbGVjdEFsbENoYW5nZShldmVudCkgOiBvblNlbGVjdGlvbkNoYW5nZShldmVudCk7XG4gICAgICAgIH0sIHNpemU6IChkZW5zaXR5ID09PSAnY29tcGFjdCcgPyAnc21hbGwnIDogJ21lZGl1bScpIH0sIGNoZWNrYm94UHJvcHMpLCB7IG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgKF9hID0gY2hlY2tib3hQcm9wcyA9PT0gbnVsbCB8fCBjaGVja2JveFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja2JveFByb3BzLm9uQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoZWNrYm94UHJvcHMsIGUpO1xuICAgICAgICB9LCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGhlaWdodDogZGVuc2l0eSA9PT0gJ2NvbXBhY3QnID8gJzEuNzVyZW0nIDogJzIuNXJlbScsIG06IGRlbnNpdHkgIT09ICdjb21wYWN0JyA/ICctMC40cmVtJyA6IHVuZGVmaW5lZCwgd2lkdGg6IGRlbnNpdHkgPT09ICdjb21wYWN0JyA/ICcxLjc1cmVtJyA6ICcyLjVyZW0nLCB6SW5kZXg6IDAgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy5zeCwgdGhlbWUpKSksIHRpdGxlOiB1bmRlZmluZWQgfSk7XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCksIHsgdGl0bGU6IChfYiA9IGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHNlbGVjdEFsbFxuICAgICAgICAgICAgPyBsb2NhbGl6YXRpb24udG9nZ2xlU2VsZWN0QWxsXG4gICAgICAgICAgICA6IGxvY2FsaXphdGlvbi50b2dnbGVTZWxlY3RSb3cpLCBjaGlsZHJlbjogZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24gPT09IGZhbHNlID8gKGpzeChSYWRpbywgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uUHJvcHMpKSkgOiAoanN4KENoZWNrYm94LCBPYmplY3QuYXNzaWduKHsgaW5kZXRlcm1pbmF0ZTogIWlzQ2hlY2tlZCAmJiBzZWxlY3RBbGxcbiAgICAgICAgICAgICAgICA/IHRhYmxlLmdldElzU29tZVJvd3NTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgOiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93LmdldElzU29tZVNlbGVjdGVkKCkpICYmIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzKCkgfSwgY29tbW9uUHJvcHMpKSkgfSkpKTtcbn07XG5cbmNvbnN0IGdldE1SVF9Sb3dTZWxlY3RDb2x1bW5EZWYgPSAodGFibGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiwgZW5hYmxlU2VsZWN0QWxsIH0gPSB0YWJsZU9wdGlvbnM7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBDZWxsOiAoeyByb3csIHN0YXRpY1Jvd0luZGV4LCB0YWJsZSB9KSA9PiAoanN4KE1SVF9TZWxlY3RDaGVja2JveCwgeyByb3c6IHJvdywgc3RhdGljUm93SW5kZXg6IHN0YXRpY1Jvd0luZGV4LCB0YWJsZTogdGFibGUgfSkpLCBIZWFkZXI6IGVuYWJsZVNlbGVjdEFsbCAmJiBlbmFibGVNdWx0aVJvd1NlbGVjdGlvblxuICAgICAgICAgICAgPyAoeyB0YWJsZSB9KSA9PiBqc3goTVJUX1NlbGVjdENoZWNrYm94LCB7IHRhYmxlOiB0YWJsZSB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIGdyb3c6IGZhbHNlIH0sIGRlZmF1bHREaXNwbGF5Q29sdW1uUHJvcHMoe1xuICAgICAgICBoZWFkZXI6ICdzZWxlY3QnLFxuICAgICAgICBpZDogJ21ydC1yb3ctc2VsZWN0JyxcbiAgICAgICAgc2l6ZTogZW5hYmxlU2VsZWN0QWxsID8gNjAgOiA3MCxcbiAgICAgICAgdGFibGVPcHRpb25zLFxuICAgIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9EZWZhdWx0X0ljb25zID0ge1xuICAgIEFycm93RG93bndhcmRJY29uLFxuICAgIEFycm93UmlnaHRJY29uLFxuICAgIENhbmNlbEljb24sXG4gICAgQ2hldnJvbkxlZnRJY29uLFxuICAgIENoZXZyb25SaWdodEljb24sXG4gICAgQ2xlYXJBbGxJY29uLFxuICAgIENsb3NlSWNvbixcbiAgICBDb250ZW50Q29weSxcbiAgICBEZW5zaXR5TGFyZ2VJY29uLFxuICAgIERlbnNpdHlNZWRpdW1JY29uLFxuICAgIERlbnNpdHlTbWFsbEljb24sXG4gICAgRHJhZ0hhbmRsZUljb24sXG4gICAgRHluYW1pY0ZlZWRJY29uLFxuICAgIEVkaXRJY29uLFxuICAgIEV4cGFuZE1vcmVJY29uLFxuICAgIEZpbHRlckFsdEljb24sXG4gICAgRmlsdGVyTGlzdEljb24sXG4gICAgRmlsdGVyTGlzdE9mZkljb24sXG4gICAgRmlyc3RQYWdlSWNvbixcbiAgICBGdWxsc2NyZWVuRXhpdEljb24sXG4gICAgRnVsbHNjcmVlbkljb24sXG4gICAgS2V5Ym9hcmREb3VibGVBcnJvd0Rvd25JY29uLFxuICAgIExhc3RQYWdlSWNvbixcbiAgICBNb3JlSG9yaXpJY29uLFxuICAgIE1vcmVWZXJ0SWNvbixcbiAgICBQdXNoUGluSWNvbixcbiAgICBSZXN0YXJ0QWx0SWNvbixcbiAgICBTYXZlSWNvbixcbiAgICBTZWFyY2hJY29uLFxuICAgIFNlYXJjaE9mZkljb24sXG4gICAgU29ydEljb24sXG4gICAgU3luY0FsdEljb24sXG4gICAgVmlld0NvbHVtbkljb24sXG4gICAgVmlzaWJpbGl0eU9mZkljb24sXG59O1xuXG5jb25zdCBNUlRfTG9jYWxpemF0aW9uX0VOID0ge1xuICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgIGFjdGlvbnM6ICdBY3Rpb25zJyxcbiAgICBhbmQ6ICdhbmQnLFxuICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgY2hhbmdlRmlsdGVyTW9kZTogJ0NoYW5nZSBmaWx0ZXIgbW9kZScsXG4gICAgY2hhbmdlU2VhcmNoTW9kZTogJ0NoYW5nZSBzZWFyY2ggbW9kZScsXG4gICAgY2xlYXJGaWx0ZXI6ICdDbGVhciBmaWx0ZXInLFxuICAgIGNsZWFyU2VhcmNoOiAnQ2xlYXIgc2VhcmNoJyxcbiAgICBjbGVhclNlbGVjdGlvbjogJ0NsZWFyIHNlbGVjdGlvbicsXG4gICAgY2xlYXJTb3J0OiAnQ2xlYXIgc29ydCcsXG4gICAgY2xpY2tUb0NvcHk6ICdDbGljayB0byBjb3B5JyxcbiAgICBjb3B5OiAnQ29weScsXG4gICAgY29sbGFwc2U6ICdDb2xsYXBzZScsXG4gICAgY29sbGFwc2VBbGw6ICdDb2xsYXBzZSBhbGwnLFxuICAgIGNvbHVtbkFjdGlvbnM6ICdDb2x1bW4gQWN0aW9ucycsXG4gICAgY29waWVkVG9DbGlwYm9hcmQ6ICdDb3BpZWQgdG8gY2xpcGJvYXJkJyxcbiAgICBkcm9wVG9Hcm91cEJ5OiAnRHJvcCB0byBncm91cCBieSB7Y29sdW1ufScsXG4gICAgZWRpdDogJ0VkaXQnLFxuICAgIGV4cGFuZDogJ0V4cGFuZCcsXG4gICAgZXhwYW5kQWxsOiAnRXhwYW5kIGFsbCcsXG4gICAgZmlsdGVyQXJySW5jbHVkZXM6ICdJbmNsdWRlcycsXG4gICAgZmlsdGVyQXJySW5jbHVkZXNBbGw6ICdJbmNsdWRlcyBhbGwnLFxuICAgIGZpbHRlckFyckluY2x1ZGVzU29tZTogJ0luY2x1ZGVzJyxcbiAgICBmaWx0ZXJCZXR3ZWVuOiAnQmV0d2VlbicsXG4gICAgZmlsdGVyQmV0d2VlbkluY2x1c2l2ZTogJ0JldHdlZW4gSW5jbHVzaXZlJyxcbiAgICBmaWx0ZXJCeUNvbHVtbjogJ0ZpbHRlciBieSB7Y29sdW1ufScsXG4gICAgZmlsdGVyQ29udGFpbnM6ICdDb250YWlucycsXG4gICAgZmlsdGVyRW1wdHk6ICdFbXB0eScsXG4gICAgZmlsdGVyRW5kc1dpdGg6ICdFbmRzIFdpdGgnLFxuICAgIGZpbHRlckVxdWFsczogJ0VxdWFscycsXG4gICAgZmlsdGVyRXF1YWxzU3RyaW5nOiAnRXF1YWxzJyxcbiAgICBmaWx0ZXJGdXp6eTogJ0Z1enp5JyxcbiAgICBmaWx0ZXJHcmVhdGVyVGhhbjogJ0dyZWF0ZXIgVGhhbicsXG4gICAgZmlsdGVyR3JlYXRlclRoYW5PckVxdWFsVG86ICdHcmVhdGVyIFRoYW4gT3IgRXF1YWwgVG8nLFxuICAgIGZpbHRlckluTnVtYmVyUmFuZ2U6ICdCZXR3ZWVuJyxcbiAgICBmaWx0ZXJJbmNsdWRlc1N0cmluZzogJ0NvbnRhaW5zJyxcbiAgICBmaWx0ZXJJbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZTogJ0NvbnRhaW5zJyxcbiAgICBmaWx0ZXJMZXNzVGhhbjogJ0xlc3MgVGhhbicsXG4gICAgZmlsdGVyTGVzc1RoYW5PckVxdWFsVG86ICdMZXNzIFRoYW4gT3IgRXF1YWwgVG8nLFxuICAgIGZpbHRlck1vZGU6ICdGaWx0ZXIgTW9kZToge2ZpbHRlclR5cGV9JyxcbiAgICBmaWx0ZXJOb3RFbXB0eTogJ05vdCBFbXB0eScsXG4gICAgZmlsdGVyTm90RXF1YWxzOiAnTm90IEVxdWFscycsXG4gICAgZmlsdGVyU3RhcnRzV2l0aDogJ1N0YXJ0cyBXaXRoJyxcbiAgICBmaWx0ZXJXZWFrRXF1YWxzOiAnRXF1YWxzJyxcbiAgICBmaWx0ZXJpbmdCeUNvbHVtbjogJ0ZpbHRlcmluZyBieSB7Y29sdW1ufSAtIHtmaWx0ZXJUeXBlfSB7ZmlsdGVyVmFsdWV9JyxcbiAgICBnb1RvRmlyc3RQYWdlOiAnR28gdG8gZmlyc3QgcGFnZScsXG4gICAgZ29Ub0xhc3RQYWdlOiAnR28gdG8gbGFzdCBwYWdlJyxcbiAgICBnb1RvTmV4dFBhZ2U6ICdHbyB0byBuZXh0IHBhZ2UnLFxuICAgIGdvVG9QcmV2aW91c1BhZ2U6ICdHbyB0byBwcmV2aW91cyBwYWdlJyxcbiAgICBncmFiOiAnR3JhYicsXG4gICAgZ3JvdXBCeUNvbHVtbjogJ0dyb3VwIGJ5IHtjb2x1bW59JyxcbiAgICBncm91cGVkQnk6ICdHcm91cGVkIGJ5ICcsXG4gICAgaGlkZUFsbDogJ0hpZGUgYWxsJyxcbiAgICBoaWRlQ29sdW1uOiAnSGlkZSB7Y29sdW1ufSBjb2x1bW4nLFxuICAgIG1heDogJ01heCcsXG4gICAgbWluOiAnTWluJyxcbiAgICBtb3ZlOiAnTW92ZScsXG4gICAgbm9SZWNvcmRzVG9EaXNwbGF5OiAnTm8gcmVjb3JkcyB0byBkaXNwbGF5JyxcbiAgICBub1Jlc3VsdHNGb3VuZDogJ05vIHJlc3VsdHMgZm91bmQnLFxuICAgIG9mOiAnb2YnLFxuICAgIG9yOiAnb3InLFxuICAgIHBpbjogJ1BpbicsXG4gICAgcGluVG9MZWZ0OiAnUGluIHRvIGxlZnQnLFxuICAgIHBpblRvUmlnaHQ6ICdQaW4gdG8gcmlnaHQnLFxuICAgIHJlc2V0Q29sdW1uU2l6ZTogJ1Jlc2V0IGNvbHVtbiBzaXplJyxcbiAgICByZXNldE9yZGVyOiAnUmVzZXQgb3JkZXInLFxuICAgIHJvd0FjdGlvbnM6ICdSb3cgQWN0aW9ucycsXG4gICAgcm93TnVtYmVyOiAnIycsXG4gICAgcm93TnVtYmVyczogJ1JvdyBOdW1iZXJzJyxcbiAgICByb3dzUGVyUGFnZTogJ1Jvd3MgcGVyIHBhZ2UnLFxuICAgIHNhdmU6ICdTYXZlJyxcbiAgICBzZWFyY2g6ICdTZWFyY2gnLFxuICAgIHNlbGVjdGVkQ291bnRPZlJvd0NvdW50Um93c1NlbGVjdGVkOiAne3NlbGVjdGVkQ291bnR9IG9mIHtyb3dDb3VudH0gcm93KHMpIHNlbGVjdGVkJyxcbiAgICBzZWxlY3Q6ICdTZWxlY3QnLFxuICAgIHNob3dBbGw6ICdTaG93IGFsbCcsXG4gICAgc2hvd0FsbENvbHVtbnM6ICdTaG93IGFsbCBjb2x1bW5zJyxcbiAgICBzaG93SGlkZUNvbHVtbnM6ICdTaG93L0hpZGUgY29sdW1ucycsXG4gICAgc2hvd0hpZGVGaWx0ZXJzOiAnU2hvdy9IaWRlIGZpbHRlcnMnLFxuICAgIHNob3dIaWRlU2VhcmNoOiAnU2hvdy9IaWRlIHNlYXJjaCcsXG4gICAgc29ydEJ5Q29sdW1uQXNjOiAnU29ydCBieSB7Y29sdW1ufSBhc2NlbmRpbmcnLFxuICAgIHNvcnRCeUNvbHVtbkRlc2M6ICdTb3J0IGJ5IHtjb2x1bW59IGRlc2NlbmRpbmcnLFxuICAgIHNvcnRlZEJ5Q29sdW1uQXNjOiAnU29ydGVkIGJ5IHtjb2x1bW59IGFzY2VuZGluZycsXG4gICAgc29ydGVkQnlDb2x1bW5EZXNjOiAnU29ydGVkIGJ5IHtjb2x1bW59IGRlc2NlbmRpbmcnLFxuICAgIHRoZW5CeTogJywgdGhlbiBieSAnLFxuICAgIHRvZ2dsZURlbnNpdHk6ICdUb2dnbGUgZGVuc2l0eScsXG4gICAgdG9nZ2xlRnVsbFNjcmVlbjogJ1RvZ2dsZSBmdWxsIHNjcmVlbicsXG4gICAgdG9nZ2xlU2VsZWN0QWxsOiAnVG9nZ2xlIHNlbGVjdCBhbGwnLFxuICAgIHRvZ2dsZVNlbGVjdFJvdzogJ1RvZ2dsZSBzZWxlY3Qgcm93JyxcbiAgICB0b2dnbGVWaXNpYmlsaXR5OiAnVG9nZ2xlIHZpc2liaWxpdHknLFxuICAgIHVuZ3JvdXBCeUNvbHVtbjogJ1VuZ3JvdXAgYnkge2NvbHVtbn0nLFxuICAgIHVucGluOiAnVW5waW4nLFxuICAgIHVucGluQWxsOiAnVW5waW4gYWxsJyxcbn07XG5cbmNvbnN0IE1SVF9EZWZhdWx0Q29sdW1uID0ge1xuICAgIGZpbHRlclZhcmlhbnQ6ICd0ZXh0JyxcbiAgICBtYXhTaXplOiAxMDAwLFxuICAgIG1pblNpemU6IDQwLFxuICAgIHNpemU6IDE4MCxcbn07XG5jb25zdCBNUlRfRGVmYXVsdERpc3BsYXlDb2x1bW4gPSB7XG4gICAgY29sdW1uRGVmVHlwZTogJ2Rpc3BsYXknLFxuICAgIGVuYWJsZUNsaWNrVG9Db3B5OiBmYWxzZSxcbiAgICBlbmFibGVDb2x1bW5BY3Rpb25zOiBmYWxzZSxcbiAgICBlbmFibGVDb2x1bW5EcmFnZ2luZzogZmFsc2UsXG4gICAgZW5hYmxlQ29sdW1uRmlsdGVyOiBmYWxzZSxcbiAgICBlbmFibGVDb2x1bW5PcmRlcmluZzogZmFsc2UsXG4gICAgZW5hYmxlRWRpdGluZzogZmFsc2UsXG4gICAgZW5hYmxlR2xvYmFsRmlsdGVyOiBmYWxzZSxcbiAgICBlbmFibGVHcm91cGluZzogZmFsc2UsXG4gICAgZW5hYmxlSGlkaW5nOiBmYWxzZSxcbiAgICBlbmFibGVSZXNpemluZzogZmFsc2UsXG4gICAgZW5hYmxlU29ydGluZzogZmFsc2UsXG59O1xuY29uc3QgdXNlTVJUX1RhYmxlT3B0aW9ucyA9IChfYSkgPT4ge1xuICAgIHZhciBfYjtcbiAgICB2YXIgeyBhZ2dyZWdhdGlvbkZucywgYXV0b1Jlc2V0RXhwYW5kZWQgPSBmYWxzZSwgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgPSAnc3ViaGVhZGVyJywgY29sdW1uUmVzaXplRGlyZWN0aW9uLCBjb2x1bW5SZXNpemVNb2RlID0gJ29uQ2hhbmdlJywgY3JlYXRlRGlzcGxheU1vZGUgPSAnbW9kYWwnLCBkZWZhdWx0Q29sdW1uLCBkZWZhdWx0RGlzcGxheUNvbHVtbiwgZWRpdERpc3BsYXlNb2RlID0gJ21vZGFsJywgZW5hYmxlQmF0Y2hSb3dTZWxlY3Rpb24gPSB0cnVlLCBlbmFibGVCb3R0b21Ub29sYmFyID0gdHJ1ZSwgZW5hYmxlQ29sdW1uQWN0aW9ucyA9IHRydWUsIGVuYWJsZUNvbHVtbkZpbHRlcnMgPSB0cnVlLCBlbmFibGVDb2x1bW5PcmRlcmluZyA9IGZhbHNlLCBlbmFibGVDb2x1bW5QaW5uaW5nID0gZmFsc2UsIGVuYWJsZUNvbHVtblJlc2l6aW5nID0gZmFsc2UsIGVuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uLCBlbmFibGVEZW5zaXR5VG9nZ2xlID0gdHJ1ZSwgZW5hYmxlRXhwYW5kQWxsID0gdHJ1ZSwgZW5hYmxlRXhwYW5kaW5nLCBlbmFibGVGYWNldGVkVmFsdWVzID0gZmFsc2UsIGVuYWJsZUZpbHRlck1hdGNoSGlnaGxpZ2h0aW5nID0gdHJ1ZSwgZW5hYmxlRmlsdGVycyA9IHRydWUsIGVuYWJsZUZ1bGxTY3JlZW5Ub2dnbGUgPSB0cnVlLCBlbmFibGVHbG9iYWxGaWx0ZXIgPSB0cnVlLCBlbmFibGVHbG9iYWxGaWx0ZXJSYW5rZWRSZXN1bHRzID0gdHJ1ZSwgZW5hYmxlR3JvdXBpbmcgPSBmYWxzZSwgZW5hYmxlSGlkaW5nID0gdHJ1ZSwgZW5hYmxlS2V5Ym9hcmRTaG9ydGN1dHMgPSB0cnVlLCBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiA9IHRydWUsIGVuYWJsZU11bHRpU29ydCA9IHRydWUsIGVuYWJsZVBhZ2luYXRpb24gPSB0cnVlLCBlbmFibGVSb3dQaW5uaW5nID0gZmFsc2UsIGVuYWJsZVJvd1NlbGVjdGlvbiA9IGZhbHNlLCBlbmFibGVSb3dWaXJ0dWFsaXphdGlvbiwgZW5hYmxlU2VsZWN0QWxsID0gdHJ1ZSwgZW5hYmxlU29ydGluZyA9IHRydWUsIGVuYWJsZVN0aWNreUhlYWRlciA9IGZhbHNlLCBlbmFibGVUYWJsZUZvb3RlciA9IHRydWUsIGVuYWJsZVRhYmxlSGVhZCA9IHRydWUsIGVuYWJsZVRvb2xiYXJJbnRlcm5hbEFjdGlvbnMgPSB0cnVlLCBlbmFibGVUb3BUb29sYmFyID0gdHJ1ZSwgZmlsdGVyRm5zLCBpY29ucywgaWQgPSB1c2VJZCgpLCBsYXlvdXRNb2RlLCBsb2NhbGl6YXRpb24sIG1hbnVhbEZpbHRlcmluZywgbWFudWFsR3JvdXBpbmcsIG1hbnVhbFBhZ2luYXRpb24sIG1hbnVhbFNvcnRpbmcsIG1ydFRoZW1lLCBwYWdpbmF0aW9uRGlzcGxheU1vZGUgPSAnZGVmYXVsdCcsIHBvc2l0aW9uQWN0aW9uc0NvbHVtbiA9ICdmaXJzdCcsIHBvc2l0aW9uQ3JlYXRpbmdSb3cgPSAndG9wJywgcG9zaXRpb25FeHBhbmRDb2x1bW4gPSAnZmlyc3QnLCBwb3NpdGlvbkdsb2JhbEZpbHRlciA9ICdyaWdodCcsIHBvc2l0aW9uUGFnaW5hdGlvbiA9ICdib3R0b20nLCBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciA9ICd0b3AnLCBwb3NpdGlvblRvb2xiYXJEcm9wWm9uZSA9ICd0b3AnLCByb3dOdW1iZXJEaXNwbGF5TW9kZSA9ICdzdGF0aWMnLCByb3dQaW5uaW5nRGlzcGxheU1vZGUgPSAnc3RpY2t5Jywgc2VsZWN0QWxsTW9kZSA9ICdwYWdlJywgc29ydGluZ0ZucyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImFnZ3JlZ2F0aW9uRm5zXCIsIFwiYXV0b1Jlc2V0RXhwYW5kZWRcIiwgXCJjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZVwiLCBcImNvbHVtblJlc2l6ZURpcmVjdGlvblwiLCBcImNvbHVtblJlc2l6ZU1vZGVcIiwgXCJjcmVhdGVEaXNwbGF5TW9kZVwiLCBcImRlZmF1bHRDb2x1bW5cIiwgXCJkZWZhdWx0RGlzcGxheUNvbHVtblwiLCBcImVkaXREaXNwbGF5TW9kZVwiLCBcImVuYWJsZUJhdGNoUm93U2VsZWN0aW9uXCIsIFwiZW5hYmxlQm90dG9tVG9vbGJhclwiLCBcImVuYWJsZUNvbHVtbkFjdGlvbnNcIiwgXCJlbmFibGVDb2x1bW5GaWx0ZXJzXCIsIFwiZW5hYmxlQ29sdW1uT3JkZXJpbmdcIiwgXCJlbmFibGVDb2x1bW5QaW5uaW5nXCIsIFwiZW5hYmxlQ29sdW1uUmVzaXppbmdcIiwgXCJlbmFibGVDb2x1bW5WaXJ0dWFsaXphdGlvblwiLCBcImVuYWJsZURlbnNpdHlUb2dnbGVcIiwgXCJlbmFibGVFeHBhbmRBbGxcIiwgXCJlbmFibGVFeHBhbmRpbmdcIiwgXCJlbmFibGVGYWNldGVkVmFsdWVzXCIsIFwiZW5hYmxlRmlsdGVyTWF0Y2hIaWdobGlnaHRpbmdcIiwgXCJlbmFibGVGaWx0ZXJzXCIsIFwiZW5hYmxlRnVsbFNjcmVlblRvZ2dsZVwiLCBcImVuYWJsZUdsb2JhbEZpbHRlclwiLCBcImVuYWJsZUdsb2JhbEZpbHRlclJhbmtlZFJlc3VsdHNcIiwgXCJlbmFibGVHcm91cGluZ1wiLCBcImVuYWJsZUhpZGluZ1wiLCBcImVuYWJsZUtleWJvYXJkU2hvcnRjdXRzXCIsIFwiZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb25cIiwgXCJlbmFibGVNdWx0aVNvcnRcIiwgXCJlbmFibGVQYWdpbmF0aW9uXCIsIFwiZW5hYmxlUm93UGlubmluZ1wiLCBcImVuYWJsZVJvd1NlbGVjdGlvblwiLCBcImVuYWJsZVJvd1ZpcnR1YWxpemF0aW9uXCIsIFwiZW5hYmxlU2VsZWN0QWxsXCIsIFwiZW5hYmxlU29ydGluZ1wiLCBcImVuYWJsZVN0aWNreUhlYWRlclwiLCBcImVuYWJsZVRhYmxlRm9vdGVyXCIsIFwiZW5hYmxlVGFibGVIZWFkXCIsIFwiZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9uc1wiLCBcImVuYWJsZVRvcFRvb2xiYXJcIiwgXCJmaWx0ZXJGbnNcIiwgXCJpY29uc1wiLCBcImlkXCIsIFwibGF5b3V0TW9kZVwiLCBcImxvY2FsaXphdGlvblwiLCBcIm1hbnVhbEZpbHRlcmluZ1wiLCBcIm1hbnVhbEdyb3VwaW5nXCIsIFwibWFudWFsUGFnaW5hdGlvblwiLCBcIm1hbnVhbFNvcnRpbmdcIiwgXCJtcnRUaGVtZVwiLCBcInBhZ2luYXRpb25EaXNwbGF5TW9kZVwiLCBcInBvc2l0aW9uQWN0aW9uc0NvbHVtblwiLCBcInBvc2l0aW9uQ3JlYXRpbmdSb3dcIiwgXCJwb3NpdGlvbkV4cGFuZENvbHVtblwiLCBcInBvc2l0aW9uR2xvYmFsRmlsdGVyXCIsIFwicG9zaXRpb25QYWdpbmF0aW9uXCIsIFwicG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXJcIiwgXCJwb3NpdGlvblRvb2xiYXJEcm9wWm9uZVwiLCBcInJvd051bWJlckRpc3BsYXlNb2RlXCIsIFwicm93UGlubmluZ0Rpc3BsYXlNb2RlXCIsIFwic2VsZWN0QWxsTW9kZVwiLCBcInNvcnRpbmdGbnNcIl0pO1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgICBpY29ucyA9IHVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTVJUX0RlZmF1bHRfSWNvbnMpLCBpY29ucykpLCBbaWNvbnNdKTtcbiAgICBsb2NhbGl6YXRpb24gPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1SVF9Mb2NhbGl6YXRpb25fRU4pLCBsb2NhbGl6YXRpb24pKSwgW2xvY2FsaXphdGlvbl0pO1xuICAgIG1ydFRoZW1lID0gdXNlTWVtbygoKSA9PiBnZXRNUlRUaGVtZShtcnRUaGVtZSwgdGhlbWUpLCBbbXJ0VGhlbWUsIHRoZW1lXSk7XG4gICAgYWdncmVnYXRpb25GbnMgPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1SVF9BZ2dyZWdhdGlvbkZucyksIGFnZ3JlZ2F0aW9uRm5zKSksIFtdKTtcbiAgICBmaWx0ZXJGbnMgPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1SVF9GaWx0ZXJGbnMpLCBmaWx0ZXJGbnMpKSwgW10pO1xuICAgIHNvcnRpbmdGbnMgPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1SVF9Tb3J0aW5nRm5zKSwgc29ydGluZ0ZucykpLCBbXSk7XG4gICAgZGVmYXVsdENvbHVtbiA9IHVzZU1lbW8oKCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTVJUX0RlZmF1bHRDb2x1bW4pLCBkZWZhdWx0Q29sdW1uKSksIFtkZWZhdWx0Q29sdW1uXSk7XG4gICAgZGVmYXVsdERpc3BsYXlDb2x1bW4gPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1SVF9EZWZhdWx0RGlzcGxheUNvbHVtbiksIGRlZmF1bHREaXNwbGF5Q29sdW1uKSksIFtkZWZhdWx0RGlzcGxheUNvbHVtbl0pO1xuICAgIC8vY2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cbiAgICBbZW5hYmxlQ29sdW1uVmlydHVhbGl6YXRpb24sIGVuYWJsZVJvd1ZpcnR1YWxpemF0aW9uXSA9IHVzZU1lbW8oKCkgPT4gW2VuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uLCBlbmFibGVSb3dWaXJ0dWFsaXphdGlvbl0sIFtdKTtcbiAgICBpZiAoIWNvbHVtblJlc2l6ZURpcmVjdGlvbikge1xuICAgICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb24gPSB0aGVtZS5kaXJlY3Rpb24gfHwgJ2x0cic7XG4gICAgfVxuICAgIGxheW91dE1vZGUgPVxuICAgICAgICBsYXlvdXRNb2RlIHx8IChlbmFibGVDb2x1bW5SZXNpemluZyA/ICdncmlkLW5vLWdyb3cnIDogJ3NlbWFudGljJyk7XG4gICAgaWYgKGxheW91dE1vZGUgPT09ICdzZW1hbnRpYycgJiZcbiAgICAgICAgKGVuYWJsZVJvd1ZpcnR1YWxpemF0aW9uIHx8IGVuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uKSkge1xuICAgICAgICBsYXlvdXRNb2RlID0gJ2dyaWQnO1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUm93VmlydHVhbGl6YXRpb24pIHtcbiAgICAgICAgZW5hYmxlU3RpY2t5SGVhZGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVuYWJsZVBhZ2luYXRpb24gPT09IGZhbHNlICYmIG1hbnVhbFBhZ2luYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYW51YWxQYWdpbmF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEoKF9iID0gcmVzdC5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSkge1xuICAgICAgICBtYW51YWxGaWx0ZXJpbmcgPSB0cnVlO1xuICAgICAgICBtYW51YWxHcm91cGluZyA9IHRydWU7XG4gICAgICAgIG1hbnVhbFBhZ2luYXRpb24gPSB0cnVlO1xuICAgICAgICBtYW51YWxTb3J0aW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBhZ2dyZWdhdGlvbkZucyxcbiAgICAgICAgYXV0b1Jlc2V0RXhwYW5kZWQsXG4gICAgICAgIGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlLFxuICAgICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb24sXG4gICAgICAgIGNvbHVtblJlc2l6ZU1vZGUsXG4gICAgICAgIGNyZWF0ZURpc3BsYXlNb2RlLFxuICAgICAgICBkZWZhdWx0Q29sdW1uLFxuICAgICAgICBkZWZhdWx0RGlzcGxheUNvbHVtbixcbiAgICAgICAgZWRpdERpc3BsYXlNb2RlLFxuICAgICAgICBlbmFibGVCYXRjaFJvd1NlbGVjdGlvbixcbiAgICAgICAgZW5hYmxlQm90dG9tVG9vbGJhcixcbiAgICAgICAgZW5hYmxlQ29sdW1uQWN0aW9ucyxcbiAgICAgICAgZW5hYmxlQ29sdW1uRmlsdGVycyxcbiAgICAgICAgZW5hYmxlQ29sdW1uT3JkZXJpbmcsXG4gICAgICAgIGVuYWJsZUNvbHVtblBpbm5pbmcsXG4gICAgICAgIGVuYWJsZUNvbHVtblJlc2l6aW5nLFxuICAgICAgICBlbmFibGVDb2x1bW5WaXJ0dWFsaXphdGlvbixcbiAgICAgICAgZW5hYmxlRGVuc2l0eVRvZ2dsZSxcbiAgICAgICAgZW5hYmxlRXhwYW5kQWxsLFxuICAgICAgICBlbmFibGVFeHBhbmRpbmcsXG4gICAgICAgIGVuYWJsZUZhY2V0ZWRWYWx1ZXMsXG4gICAgICAgIGVuYWJsZUZpbHRlck1hdGNoSGlnaGxpZ2h0aW5nLFxuICAgICAgICBlbmFibGVGaWx0ZXJzLFxuICAgICAgICBlbmFibGVGdWxsU2NyZWVuVG9nZ2xlLFxuICAgICAgICBlbmFibGVHbG9iYWxGaWx0ZXIsXG4gICAgICAgIGVuYWJsZUdsb2JhbEZpbHRlclJhbmtlZFJlc3VsdHMsXG4gICAgICAgIGVuYWJsZUdyb3VwaW5nLFxuICAgICAgICBlbmFibGVIaWRpbmcsXG4gICAgICAgIGVuYWJsZUtleWJvYXJkU2hvcnRjdXRzLFxuICAgICAgICBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbixcbiAgICAgICAgZW5hYmxlTXVsdGlTb3J0LFxuICAgICAgICBlbmFibGVQYWdpbmF0aW9uLFxuICAgICAgICBlbmFibGVSb3dQaW5uaW5nLFxuICAgICAgICBlbmFibGVSb3dTZWxlY3Rpb24sXG4gICAgICAgIGVuYWJsZVJvd1ZpcnR1YWxpemF0aW9uLFxuICAgICAgICBlbmFibGVTZWxlY3RBbGwsXG4gICAgICAgIGVuYWJsZVNvcnRpbmcsXG4gICAgICAgIGVuYWJsZVN0aWNreUhlYWRlcixcbiAgICAgICAgZW5hYmxlVGFibGVGb290ZXIsXG4gICAgICAgIGVuYWJsZVRhYmxlSGVhZCxcbiAgICAgICAgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9ucyxcbiAgICAgICAgZW5hYmxlVG9wVG9vbGJhcixcbiAgICAgICAgZmlsdGVyRm5zLCBnZXRDb3JlUm93TW9kZWw6IGdldENvcmVSb3dNb2RlbCgpLCBnZXRFeHBhbmRlZFJvd01vZGVsOiBlbmFibGVFeHBhbmRpbmcgfHwgZW5hYmxlR3JvdXBpbmcgPyBnZXRFeHBhbmRlZFJvd01vZGVsKCkgOiB1bmRlZmluZWQsIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXM6IGVuYWJsZUZhY2V0ZWRWYWx1ZXNcbiAgICAgICAgICAgID8gZ2V0RmFjZXRlZE1pbk1heFZhbHVlcygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgZ2V0RmFjZXRlZFJvd01vZGVsOiBlbmFibGVGYWNldGVkVmFsdWVzID8gZ2V0RmFjZXRlZFJvd01vZGVsKCkgOiB1bmRlZmluZWQsIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXM6IGVuYWJsZUZhY2V0ZWRWYWx1ZXNcbiAgICAgICAgICAgID8gZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgZ2V0RmlsdGVyZWRSb3dNb2RlbDogKGVuYWJsZUNvbHVtbkZpbHRlcnMgfHwgZW5hYmxlR2xvYmFsRmlsdGVyIHx8IGVuYWJsZUZpbHRlcnMpICYmXG4gICAgICAgICAgICAhbWFudWFsRmlsdGVyaW5nXG4gICAgICAgICAgICA/IGdldEZpbHRlcmVkUm93TW9kZWwoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIGdldEdyb3VwZWRSb3dNb2RlbDogZW5hYmxlR3JvdXBpbmcgJiYgIW1hbnVhbEdyb3VwaW5nID8gZ2V0R3JvdXBlZFJvd01vZGVsKCkgOiB1bmRlZmluZWQsIGdldFBhZ2luYXRpb25Sb3dNb2RlbDogZW5hYmxlUGFnaW5hdGlvbiAmJiAhbWFudWFsUGFnaW5hdGlvblxuICAgICAgICAgICAgPyBnZXRQYWdpbmF0aW9uUm93TW9kZWwoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsIGdldFNvcnRlZFJvd01vZGVsOiBlbmFibGVTb3J0aW5nICYmICFtYW51YWxTb3J0aW5nID8gZ2V0U29ydGVkUm93TW9kZWwoKSA6IHVuZGVmaW5lZCwgZ2V0U3ViUm93czogKHJvdykgPT4gcm93ID09PSBudWxsIHx8IHJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93LnN1YlJvd3MsIGljb25zLFxuICAgICAgICBpZCxcbiAgICAgICAgbGF5b3V0TW9kZSxcbiAgICAgICAgbG9jYWxpemF0aW9uLFxuICAgICAgICBtYW51YWxGaWx0ZXJpbmcsXG4gICAgICAgIG1hbnVhbEdyb3VwaW5nLFxuICAgICAgICBtYW51YWxQYWdpbmF0aW9uLFxuICAgICAgICBtYW51YWxTb3J0aW5nLFxuICAgICAgICBtcnRUaGVtZSxcbiAgICAgICAgcGFnaW5hdGlvbkRpc3BsYXlNb2RlLFxuICAgICAgICBwb3NpdGlvbkFjdGlvbnNDb2x1bW4sXG4gICAgICAgIHBvc2l0aW9uQ3JlYXRpbmdSb3csXG4gICAgICAgIHBvc2l0aW9uRXhwYW5kQ29sdW1uLFxuICAgICAgICBwb3NpdGlvbkdsb2JhbEZpbHRlcixcbiAgICAgICAgcG9zaXRpb25QYWdpbmF0aW9uLFxuICAgICAgICBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lcixcbiAgICAgICAgcG9zaXRpb25Ub29sYmFyRHJvcFpvbmUsXG4gICAgICAgIHJvd051bWJlckRpc3BsYXlNb2RlLFxuICAgICAgICByb3dQaW5uaW5nRGlzcGxheU1vZGUsXG4gICAgICAgIHNlbGVjdEFsbE1vZGUsXG4gICAgICAgIHNvcnRpbmdGbnMgfSwgcmVzdCk7XG59O1xuXG5jb25zdCBibGFua0NvbFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiBudWxsLFxuICAgIHN4OiB7XG4gICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICBwOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICB9LFxufTtcbmNvbnN0IGdldE1SVF9Sb3dTcGFjZXJDb2x1bW5EZWYgPSAodGFibGVPcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREaXNwbGF5Q29sdW1uUHJvcHMoe1xuICAgICAgICBpZDogJ21ydC1yb3ctc3BhY2VyJyxcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdGFibGVPcHRpb25zLFxuICAgIH0pKSwgeyBncm93OiB0cnVlIH0pLCBNUlRfRGVmYXVsdERpc3BsYXlDb2x1bW4pLCB7IG11aVRhYmxlQm9keUNlbGxQcm9wczogYmxhbmtDb2xQcm9wcywgbXVpVGFibGVGb290ZXJDZWxsUHJvcHM6IGJsYW5rQ29sUHJvcHMsIG11aVRhYmxlSGVhZENlbGxQcm9wczogYmxhbmtDb2xQcm9wcyB9KTtcbn07XG5cbmNvbnN0IHVzZU1SVF9FZmZlY3RzID0gKHRhYmxlKSA9PiB7XG4gICAgY29uc3QgeyBnZXRJc1NvbWVSb3dzUGlubmVkLCBnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwsIGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVBhZ2luYXRpb24sIGVuYWJsZVJvd1Bpbm5pbmcsIHJvd0NvdW50IH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbk9yZGVyLCBkZW5zaXR5LCBnbG9iYWxGaWx0ZXIsIGlzRnVsbFNjcmVlbiwgaXNMb2FkaW5nLCBwYWdpbmF0aW9uLCBzaG93U2tlbGV0b25zLCBzb3J0aW5nLCB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0b3RhbENvbHVtbkNvdW50ID0gdGFibGUub3B0aW9ucy5jb2x1bW5zLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbFJvd0NvdW50ID0gcm93Q291bnQgIT09IG51bGwgJiYgcm93Q291bnQgIT09IHZvaWQgMCA/IHJvd0NvdW50IDogZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGg7XG4gICAgY29uc3QgcmVyZW5kZXIgPSB1c2VSZWR1Y2VyKCgpID0+ICh7fSksIHt9KVsxXTtcbiAgICBjb25zdCBpbml0aWFsQm9keUhlaWdodCA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcmV2aW91c1RvcCA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGluaXRpYWxCb2R5SGVpZ2h0LmN1cnJlbnQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICAvL2hpZGUgc2Nyb2xsYmFycyB3aGVuIHRhYmxlIGlzIGluIGZ1bGwgc2NyZWVuIG1vZGUsIHByZXNlcnZlIGJvZHkgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGZ1bGwgc2NyZWVuIGV4aXRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1RvcC5jdXJyZW50ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7IC8vc2F2ZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9ICcxMDBkdmgnOyAvL2hpZGUgcGFnZSBzY3JvbGxiYXJzIHdoZW4gdGFibGUgaXMgaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQgPSBpbml0aWFsQm9keUhlaWdodC5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNUb3AuY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ2luc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IC0xICogcHJldmlvdXNUb3AuY3VycmVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtpc0Z1bGxTY3JlZW5dKTtcbiAgICAvL3JlY2FsY3VsYXRlIGNvbHVtbiBvcmRlciB3aGVuIGNvbHVtbnMgY2hhbmdlIG9yIGZlYXR1cmVzIGFyZSB0b2dnbGVkIG9uL29mZlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0b3RhbENvbHVtbkNvdW50ICE9PSBjb2x1bW5PcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtbk9yZGVyKGdldERlZmF1bHRDb2x1bW5PcmRlcklkcyh0YWJsZS5vcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdG90YWxDb2x1bW5Db3VudF0pO1xuICAgIC8vaWYgcGFnZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLCBzZXQgaXQgdG8gdGhlIGxhc3QgcGFnZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZW5hYmxlUGFnaW5hdGlvbiB8fCBpc0xvYWRpbmcgfHwgc2hvd1NrZWxldG9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBwYWdlSW5kZXgsIHBhZ2VTaXplIH0gPSBwYWdpbmF0aW9uO1xuICAgICAgICBjb25zdCB0b3RhbFBhZ2VzID0gdG90YWxSb3dDb3VudCA+IDAgPyBNYXRoLmNlaWwodG90YWxSb3dDb3VudCAvIHBhZ2VTaXplKSA6IDE7XG4gICAgICAgIGNvbnN0IGlzT3V0T2ZCb3VuZHMgPSBwYWdlSW5kZXggPCAwIHx8IHBhZ2VJbmRleCA+PSB0b3RhbFBhZ2VzO1xuICAgICAgICBpZiAoaXNPdXRPZkJvdW5kcykge1xuICAgICAgICAgICAgdGFibGUuc2V0UGFnZUluZGV4KHRvdGFsUGFnZXMgLSAxKTtcbiAgICAgICAgfVxuICAgIH0sIFt0b3RhbFJvd0NvdW50LCBlbmFibGVQYWdpbmF0aW9uLCBpc0xvYWRpbmcsIHNob3dTa2VsZXRvbnNdKTtcbiAgICAvL3R1cm4gb2ZmIHNvcnQgd2hlbiBnbG9iYWwgZmlsdGVyIGlzIGxvb2tpbmcgZm9yIHJhbmtlZCByZXN1bHRzXG4gICAgY29uc3QgYXBwbGllZFNvcnQgPSB1c2VSZWYoc29ydGluZyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNvcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcHBsaWVkU29ydC5jdXJyZW50ID0gc29ydGluZztcbiAgICAgICAgfVxuICAgIH0sIFtzb3J0aW5nXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFnZXRDYW5SYW5rUm93cyh0YWJsZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChnbG9iYWxGaWx0ZXIpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldFNvcnRpbmcoW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFibGUuc2V0U29ydGluZygoKSA9PiBhcHBsaWVkU29ydC5jdXJyZW50IHx8IFtdKTtcbiAgICAgICAgfVxuICAgIH0sIFtnbG9iYWxGaWx0ZXJdKTtcbiAgICAvL2ZpeCBwaW5uZWQgcm93IHRvcCBzdHlsZSB3aGVuIGRlbnNpdHkgY2hhbmdlc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbmFibGVSb3dQaW5uaW5nICYmIGdldElzU29tZVJvd3NQaW5uZWQoKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH1cbiAgICB9LCBbZGVuc2l0eV0pO1xufTtcblxuLyoqXG4gKiBUaGUgTVJUIGhvb2sgdGhhdCB3cmFwcyB0aGUgVGFuU3RhY2sgdXNlUmVhY3RUYWJsZSBob29rIGFuZCBhZGRzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eVxuICogQHBhcmFtIGRlZmluZWRUYWJsZU9wdGlvbnMgLSB0YWJsZSBvcHRpb25zIHdpdGggcHJvcGVyIGRlZmF1bHRzIHNldFxuICogQHJldHVybnMgdGhlIE1SVCB0YWJsZSBpbnN0YW5jZVxuICovXG5jb25zdCB1c2VNUlRfVGFibGVJbnN0YW5jZSA9IChkZWZpbmVkVGFibGVPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94LCBfeSwgX3osIF8wLCBfMSwgXzIsIF8zLCBfNCwgXzUsIF82LCBfNywgXzgsIF85LCBfMTA7XG4gICAgY29uc3QgbGFzdFNlbGVjdGVkUm93SWQgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYWN0aW9uQ2VsbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBib3R0b21Ub29sYmFyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGVkaXRJbnB1dFJlZnMgPSB1c2VSZWYoe30pO1xuICAgIGNvbnN0IGZpbHRlcklucHV0UmVmcyA9IHVzZVJlZih7fSk7XG4gICAgY29uc3Qgc2VhcmNoSW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdGFibGVDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdGFibGVIZWFkQ2VsbFJlZnMgPSB1c2VSZWYoe30pO1xuICAgIGNvbnN0IHRhYmxlUGFwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdG9wVG9vbGJhclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB0YWJsZUhlYWRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdGFibGVGb290ZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgLy90cmFuc2Zvcm0gaW5pdGlhbCBzdGF0ZSB3aXRoIHByb3BlciBjb2x1bW4gb3JkZXJcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGluaXRTdGF0ZSA9IChfYSA9IGRlZmluZWRUYWJsZU9wdGlvbnMuaW5pdGlhbFN0YXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgaW5pdFN0YXRlLmNvbHVtbk9yZGVyID1cbiAgICAgICAgICAgIChfYiA9IGluaXRTdGF0ZS5jb2x1bW5PcmRlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZ2V0RGVmYXVsdENvbHVtbk9yZGVySWRzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5lZFRhYmxlT3B0aW9ucyksIHsgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5lZFRhYmxlT3B0aW9ucy5pbml0aWFsU3RhdGUpLCBkZWZpbmVkVGFibGVPcHRpb25zLnN0YXRlKSB9KSk7XG4gICAgICAgIGluaXRTdGF0ZS5nbG9iYWxGaWx0ZXJGbiA9IChfYyA9IGRlZmluZWRUYWJsZU9wdGlvbnMuZ2xvYmFsRmlsdGVyRm4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdmdXp6eSc7XG4gICAgICAgIHJldHVybiBpbml0U3RhdGU7XG4gICAgfSwgW10pO1xuICAgIGRlZmluZWRUYWJsZU9wdGlvbnMuaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIGNvbnN0IFthY3Rpb25DZWxsLCBzZXRBY3Rpb25DZWxsXSA9IHVzZVN0YXRlKChfYSA9IGluaXRpYWxTdGF0ZS5hY3Rpb25DZWxsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKTtcbiAgICBjb25zdCBbY3JlYXRpbmdSb3csIF9zZXRDcmVhdGluZ1Jvd10gPSB1c2VTdGF0ZSgoX2IgPSBpbml0aWFsU3RhdGUuY3JlYXRpbmdSb3cpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwpO1xuICAgIGNvbnN0IFtjb2x1bW5GaWx0ZXJGbnMsIHNldENvbHVtbkZpbHRlckZuc10gPSB1c2VTdGF0ZSgoKSA9PiBPYmplY3QuYXNzaWduKHt9LCAuLi5nZXRBbGxMZWFmQ29sdW1uRGVmcyhkZWZpbmVkVGFibGVPcHRpb25zLmNvbHVtbnMpLm1hcCgoY29sKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBbZ2V0Q29sdW1uSWQoY29sKV06IGNvbC5maWx0ZXJGbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyAoKF9hID0gY29sLmZpbHRlckZuLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdjdXN0b20nKVxuICAgICAgICAgICAgICAgIDogKChfZCA9IChfYiA9IGNvbC5maWx0ZXJGbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLmNvbHVtbkZpbHRlckZucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2dldENvbHVtbklkKGNvbCldKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBnZXREZWZhdWx0Q29sdW1uRmlsdGVyRm4oY29sKSksXG4gICAgICAgIH0pO1xuICAgIH0pKSk7XG4gICAgY29uc3QgW2NvbHVtbk9yZGVyLCBvbkNvbHVtbk9yZGVyQ2hhbmdlXSA9IHVzZVN0YXRlKChfYyA9IGluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pO1xuICAgIGNvbnN0IFtjb2x1bW5TaXppbmdJbmZvLCBvbkNvbHVtblNpemluZ0luZm9DaGFuZ2VdID0gdXNlU3RhdGUoKF9kID0gaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9KTtcbiAgICBjb25zdCBbZGVuc2l0eSwgc2V0RGVuc2l0eV0gPSB1c2VTdGF0ZSgoX2UgPSBpbml0aWFsU3RhdGUgPT09IG51bGwgfHwgaW5pdGlhbFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsU3RhdGUuZGVuc2l0eSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ2NvbWZvcnRhYmxlJyk7XG4gICAgY29uc3QgW2RyYWdnaW5nQ29sdW1uLCBzZXREcmFnZ2luZ0NvbHVtbl0gPSB1c2VTdGF0ZSgoX2YgPSBpbml0aWFsU3RhdGUuZHJhZ2dpbmdDb2x1bW4pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG51bGwpO1xuICAgIGNvbnN0IFtkcmFnZ2luZ1Jvdywgc2V0RHJhZ2dpbmdSb3ddID0gdXNlU3RhdGUoKF9nID0gaW5pdGlhbFN0YXRlLmRyYWdnaW5nUm93KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBudWxsKTtcbiAgICBjb25zdCBbZWRpdGluZ0NlbGwsIHNldEVkaXRpbmdDZWxsXSA9IHVzZVN0YXRlKChfaCA9IGluaXRpYWxTdGF0ZS5lZGl0aW5nQ2VsbCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogbnVsbCk7XG4gICAgY29uc3QgW2VkaXRpbmdSb3csIHNldEVkaXRpbmdSb3ddID0gdXNlU3RhdGUoKF9qID0gaW5pdGlhbFN0YXRlLmVkaXRpbmdSb3cpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IG51bGwpO1xuICAgIGNvbnN0IFtnbG9iYWxGaWx0ZXJGbiwgc2V0R2xvYmFsRmlsdGVyRm5dID0gdXNlU3RhdGUoKF9rID0gaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlckZuKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAnZnV6enknKTtcbiAgICBjb25zdCBbZ3JvdXBpbmcsIG9uR3JvdXBpbmdDaGFuZ2VdID0gdXNlU3RhdGUoKF9sID0gaW5pdGlhbFN0YXRlLmdyb3VwaW5nKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBbXSk7XG4gICAgY29uc3QgW2hvdmVyZWRDb2x1bW4sIHNldEhvdmVyZWRDb2x1bW5dID0gdXNlU3RhdGUoKF9tID0gaW5pdGlhbFN0YXRlLmhvdmVyZWRDb2x1bW4pICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IG51bGwpO1xuICAgIGNvbnN0IFtob3ZlcmVkUm93LCBzZXRIb3ZlcmVkUm93XSA9IHVzZVN0YXRlKChfbyA9IGluaXRpYWxTdGF0ZS5ob3ZlcmVkUm93KSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiBudWxsKTtcbiAgICBjb25zdCBbaXNGdWxsU2NyZWVuLCBzZXRJc0Z1bGxTY3JlZW5dID0gdXNlU3RhdGUoKF9wID0gaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLmlzRnVsbFNjcmVlbikgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UpO1xuICAgIGNvbnN0IFtwYWdpbmF0aW9uLCBvblBhZ2luYXRpb25DaGFuZ2VdID0gdXNlU3RhdGUoKF9xID0gaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IHsgcGFnZUluZGV4OiAwLCBwYWdlU2l6ZTogMTAgfSk7XG4gICAgY29uc3QgW3Nob3dBbGVydEJhbm5lciwgc2V0U2hvd0FsZXJ0QmFubmVyXSA9IHVzZVN0YXRlKChfciA9IGluaXRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxTdGF0ZS5zaG93QWxlcnRCYW5uZXIpICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IGZhbHNlKTtcbiAgICBjb25zdCBbc2hvd0NvbHVtbkZpbHRlcnMsIHNldFNob3dDb2x1bW5GaWx0ZXJzXSA9IHVzZVN0YXRlKChfcyA9IGluaXRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxTdGF0ZS5zaG93Q29sdW1uRmlsdGVycykgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93R2xvYmFsRmlsdGVyLCBzZXRTaG93R2xvYmFsRmlsdGVyXSA9IHVzZVN0YXRlKChfdCA9IGluaXRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxTdGF0ZS5zaG93R2xvYmFsRmlsdGVyKSAhPT0gbnVsbCAmJiBfdCAhPT0gdm9pZCAwID8gX3QgOiBmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dUb29sYmFyRHJvcFpvbmUsIHNldFNob3dUb29sYmFyRHJvcFpvbmVdID0gdXNlU3RhdGUoKF91ID0gaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLnNob3dUb29sYmFyRHJvcFpvbmUpICE9PSBudWxsICYmIF91ICE9PSB2b2lkIDAgPyBfdSA6IGZhbHNlKTtcbiAgICBkZWZpbmVkVGFibGVPcHRpb25zLnN0YXRlID0gT2JqZWN0LmFzc2lnbih7IGFjdGlvbkNlbGwsXG4gICAgICAgIGNvbHVtbkZpbHRlckZucyxcbiAgICAgICAgY29sdW1uT3JkZXIsXG4gICAgICAgIGNvbHVtblNpemluZ0luZm8sXG4gICAgICAgIGNyZWF0aW5nUm93LFxuICAgICAgICBkZW5zaXR5LFxuICAgICAgICBkcmFnZ2luZ0NvbHVtbixcbiAgICAgICAgZHJhZ2dpbmdSb3csXG4gICAgICAgIGVkaXRpbmdDZWxsLFxuICAgICAgICBlZGl0aW5nUm93LFxuICAgICAgICBnbG9iYWxGaWx0ZXJGbixcbiAgICAgICAgZ3JvdXBpbmcsXG4gICAgICAgIGhvdmVyZWRDb2x1bW4sXG4gICAgICAgIGhvdmVyZWRSb3csXG4gICAgICAgIGlzRnVsbFNjcmVlbixcbiAgICAgICAgcGFnaW5hdGlvbixcbiAgICAgICAgc2hvd0FsZXJ0QmFubmVyLFxuICAgICAgICBzaG93Q29sdW1uRmlsdGVycyxcbiAgICAgICAgc2hvd0dsb2JhbEZpbHRlcixcbiAgICAgICAgc2hvd1Rvb2xiYXJEcm9wWm9uZSB9LCBkZWZpbmVkVGFibGVPcHRpb25zLnN0YXRlKTtcbiAgICAvL1RoZSB0YWJsZSBvcHRpb25zIG5vdyBpbmNsdWRlIGFsbCBzdGF0ZSBuZWVkZWQgdG8gaGVscCBkZXRlcm1pbmUgY29sdW1uIHZpc2liaWxpdHkgYW5kIG9yZGVyIGxvZ2ljXG4gICAgY29uc3Qgc3RhdGVmdWxUYWJsZU9wdGlvbnMgPSBkZWZpbmVkVGFibGVPcHRpb25zO1xuICAgIC8vZG9uJ3QgcmVjb21wdXRlIGNvbHVtbkRlZnMgd2hpbGUgcmVzaXppbmcgY29sdW1uIG9yIGRyYWdnaW5nIGNvbHVtbi9yb3dcbiAgICBjb25zdCBjb2x1bW5EZWZzUmVmID0gdXNlUmVmKFtdKTtcbiAgICBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5jb2x1bW5zID1cbiAgICAgICAgc3RhdGVmdWxUYWJsZU9wdGlvbnMuc3RhdGUuY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uIHx8XG4gICAgICAgICAgICBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5zdGF0ZS5kcmFnZ2luZ0NvbHVtbiB8fFxuICAgICAgICAgICAgc3RhdGVmdWxUYWJsZU9wdGlvbnMuc3RhdGUuZHJhZ2dpbmdSb3dcbiAgICAgICAgICAgID8gY29sdW1uRGVmc1JlZi5jdXJyZW50XG4gICAgICAgICAgICA6IHByZXBhcmVDb2x1bW5zKHtcbiAgICAgICAgICAgICAgICBjb2x1bW5EZWZzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLltcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dSb3dQaW5uaW5nQ29sdW1uKHN0YXRlZnVsVGFibGVPcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldE1SVF9Sb3dQaW5uaW5nQ29sdW1uRGVmKHN0YXRlZnVsVGFibGVPcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dSb3dEcmFnQ29sdW1uKHN0YXRlZnVsVGFibGVPcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldE1SVF9Sb3dEcmFnQ29sdW1uRGVmKHN0YXRlZnVsVGFibGVPcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dSb3dBY3Rpb25zQ29sdW1uKHN0YXRlZnVsVGFibGVPcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldE1SVF9Sb3dBY3Rpb25zQ29sdW1uRGVmKHN0YXRlZnVsVGFibGVPcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dSb3dFeHBhbmRDb2x1bW4oc3RhdGVmdWxUYWJsZU9wdGlvbnMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TVJUX1Jvd0V4cGFuZENvbHVtbkRlZihzdGF0ZWZ1bFRhYmxlT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93Um93U2VsZWN0aW9uQ29sdW1uKHN0YXRlZnVsVGFibGVPcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldE1SVF9Sb3dTZWxlY3RDb2x1bW5EZWYoc3RhdGVmdWxUYWJsZU9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Jvd051bWJlcnNDb2x1bW4oc3RhdGVmdWxUYWJsZU9wdGlvbnMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TVJUX1Jvd051bWJlcnNDb2x1bW5EZWYoc3RhdGVmdWxUYWJsZU9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGVmdWxUYWJsZU9wdGlvbnMuY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgLi4uW1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Jvd1NwYWNlckNvbHVtbihzdGF0ZWZ1bFRhYmxlT3B0aW9ucykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRNUlRfUm93U3BhY2VyQ29sdW1uRGVmKHN0YXRlZnVsVGFibGVPcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0YWJsZU9wdGlvbnM6IHN0YXRlZnVsVGFibGVPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgY29sdW1uRGVmc1JlZi5jdXJyZW50ID0gc3RhdGVmdWxUYWJsZU9wdGlvbnMuY29sdW1ucztcbiAgICAvL2lmIGxvYWRpbmcsIGdlbmVyYXRlIGJsYW5rIHJvd3MgdG8gc2hvdyBza2VsZXRvbiBsb2FkZXJzXG4gICAgc3RhdGVmdWxUYWJsZU9wdGlvbnMuZGF0YSA9IHVzZU1lbW8oKCkgPT4gKHN0YXRlZnVsVGFibGVPcHRpb25zLnN0YXRlLmlzTG9hZGluZyB8fFxuICAgICAgICBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5zdGF0ZS5zaG93U2tlbGV0b25zKSAmJlxuICAgICAgICAhc3RhdGVmdWxUYWJsZU9wdGlvbnMuZGF0YS5sZW5ndGhcbiAgICAgICAgPyBbXG4gICAgICAgICAgICAuLi5BcnJheShNYXRoLm1pbihzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5zdGF0ZS5wYWdpbmF0aW9uLnBhZ2VTaXplLCAyMCkpLmZpbGwobnVsbCksXG4gICAgICAgIF0ubWFwKCgpID0+IE9iamVjdC5hc3NpZ24oe30sIC4uLmdldEFsbExlYWZDb2x1bW5EZWZzKHN0YXRlZnVsVGFibGVPcHRpb25zLmNvbHVtbnMpLm1hcCgoY29sKSA9PiAoe1xuICAgICAgICAgICAgW2dldENvbHVtbklkKGNvbCldOiBudWxsLFxuICAgICAgICB9KSkpKVxuICAgICAgICA6IHN0YXRlZnVsVGFibGVPcHRpb25zLmRhdGEsIFtcbiAgICAgICAgc3RhdGVmdWxUYWJsZU9wdGlvbnMuZGF0YSxcbiAgICAgICAgc3RhdGVmdWxUYWJsZU9wdGlvbnMuc3RhdGUuaXNMb2FkaW5nLFxuICAgICAgICBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5zdGF0ZS5zaG93U2tlbGV0b25zLFxuICAgIF0pO1xuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHRhYmxlID0gdXNlUmVhY3RUYWJsZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBvbkNvbHVtbk9yZGVyQ2hhbmdlLFxuICAgICAgICBvbkNvbHVtblNpemluZ0luZm9DaGFuZ2UsXG4gICAgICAgIG9uR3JvdXBpbmdDaGFuZ2UsXG4gICAgICAgIG9uUGFnaW5hdGlvbkNoYW5nZSB9LCBzdGF0ZWZ1bFRhYmxlT3B0aW9ucyksIHsgZ2xvYmFsRmlsdGVyRm46IChfdiA9IHN0YXRlZnVsVGFibGVPcHRpb25zLmZpbHRlckZucykgPT09IG51bGwgfHwgX3YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92W2dsb2JhbEZpbHRlckZuICE9PSBudWxsICYmIGdsb2JhbEZpbHRlckZuICE9PSB2b2lkIDAgPyBnbG9iYWxGaWx0ZXJGbiA6ICdmdXp6eSddIH0pKTtcbiAgICB0YWJsZS5yZWZzID0ge1xuICAgICAgICBhY3Rpb25DZWxsUmVmLFxuICAgICAgICBib3R0b21Ub29sYmFyUmVmLFxuICAgICAgICBlZGl0SW5wdXRSZWZzLFxuICAgICAgICBmaWx0ZXJJbnB1dFJlZnMsXG4gICAgICAgIGxhc3RTZWxlY3RlZFJvd0lkLFxuICAgICAgICBzZWFyY2hJbnB1dFJlZixcbiAgICAgICAgdGFibGVDb250YWluZXJSZWYsXG4gICAgICAgIHRhYmxlRm9vdGVyUmVmLFxuICAgICAgICB0YWJsZUhlYWRDZWxsUmVmcyxcbiAgICAgICAgdGFibGVIZWFkUmVmLFxuICAgICAgICB0YWJsZVBhcGVyUmVmLFxuICAgICAgICB0b3BUb29sYmFyUmVmLFxuICAgIH07XG4gICAgdGFibGUuc2V0QWN0aW9uQ2VsbCA9XG4gICAgICAgIChfdyA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uQWN0aW9uQ2VsbENoYW5nZSkgIT09IG51bGwgJiYgX3cgIT09IHZvaWQgMCA/IF93IDogc2V0QWN0aW9uQ2VsbDtcbiAgICB0YWJsZS5zZXRDcmVhdGluZ1JvdyA9IChyb3cpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IF9yb3cgPSByb3c7XG4gICAgICAgIGlmIChyb3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF9yb3cgPSBjcmVhdGVSb3codGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IChfYSA9IHN0YXRlZnVsVGFibGVPcHRpb25zID09PSBudWxsIHx8IHN0YXRlZnVsVGFibGVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5vbkNyZWF0aW5nUm93Q2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdGF0ZWZ1bFRhYmxlT3B0aW9ucywgX3JvdykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF9zZXRDcmVhdGluZ1Jvdyhfcm93KTtcbiAgICB9O1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlckZucyA9XG4gICAgICAgIChfeCA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uQ29sdW1uRmlsdGVyRm5zQ2hhbmdlKSAhPT0gbnVsbCAmJiBfeCAhPT0gdm9pZCAwID8gX3ggOiBzZXRDb2x1bW5GaWx0ZXJGbnM7XG4gICAgdGFibGUuc2V0RGVuc2l0eSA9IChfeSA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uRGVuc2l0eUNoYW5nZSkgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogc2V0RGVuc2l0eTtcbiAgICB0YWJsZS5zZXREcmFnZ2luZ0NvbHVtbiA9XG4gICAgICAgIChfeiA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uRHJhZ2dpbmdDb2x1bW5DaGFuZ2UpICE9PSBudWxsICYmIF96ICE9PSB2b2lkIDAgPyBfeiA6IHNldERyYWdnaW5nQ29sdW1uO1xuICAgIHRhYmxlLnNldERyYWdnaW5nUm93ID1cbiAgICAgICAgKF8wID0gc3RhdGVmdWxUYWJsZU9wdGlvbnMub25EcmFnZ2luZ1Jvd0NoYW5nZSkgIT09IG51bGwgJiYgXzAgIT09IHZvaWQgMCA/IF8wIDogc2V0RHJhZ2dpbmdSb3c7XG4gICAgdGFibGUuc2V0RWRpdGluZ0NlbGwgPVxuICAgICAgICAoXzEgPSBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5vbkVkaXRpbmdDZWxsQ2hhbmdlKSAhPT0gbnVsbCAmJiBfMSAhPT0gdm9pZCAwID8gXzEgOiBzZXRFZGl0aW5nQ2VsbDtcbiAgICB0YWJsZS5zZXRFZGl0aW5nUm93ID1cbiAgICAgICAgKF8yID0gc3RhdGVmdWxUYWJsZU9wdGlvbnMub25FZGl0aW5nUm93Q2hhbmdlKSAhPT0gbnVsbCAmJiBfMiAhPT0gdm9pZCAwID8gXzIgOiBzZXRFZGl0aW5nUm93O1xuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlckZuID1cbiAgICAgICAgKF8zID0gc3RhdGVmdWxUYWJsZU9wdGlvbnMub25HbG9iYWxGaWx0ZXJGbkNoYW5nZSkgIT09IG51bGwgJiYgXzMgIT09IHZvaWQgMCA/IF8zIDogc2V0R2xvYmFsRmlsdGVyRm47XG4gICAgdGFibGUuc2V0SG92ZXJlZENvbHVtbiA9XG4gICAgICAgIChfNCA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uSG92ZXJlZENvbHVtbkNoYW5nZSkgIT09IG51bGwgJiYgXzQgIT09IHZvaWQgMCA/IF80IDogc2V0SG92ZXJlZENvbHVtbjtcbiAgICB0YWJsZS5zZXRIb3ZlcmVkUm93ID1cbiAgICAgICAgKF81ID0gc3RhdGVmdWxUYWJsZU9wdGlvbnMub25Ib3ZlcmVkUm93Q2hhbmdlKSAhPT0gbnVsbCAmJiBfNSAhPT0gdm9pZCAwID8gXzUgOiBzZXRIb3ZlcmVkUm93O1xuICAgIHRhYmxlLnNldElzRnVsbFNjcmVlbiA9XG4gICAgICAgIChfNiA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uSXNGdWxsU2NyZWVuQ2hhbmdlKSAhPT0gbnVsbCAmJiBfNiAhPT0gdm9pZCAwID8gXzYgOiBzZXRJc0Z1bGxTY3JlZW47XG4gICAgdGFibGUuc2V0U2hvd0FsZXJ0QmFubmVyID1cbiAgICAgICAgKF83ID0gc3RhdGVmdWxUYWJsZU9wdGlvbnMub25TaG93QWxlcnRCYW5uZXJDaGFuZ2UpICE9PSBudWxsICYmIF83ICE9PSB2b2lkIDAgPyBfNyA6IHNldFNob3dBbGVydEJhbm5lcjtcbiAgICB0YWJsZS5zZXRTaG93Q29sdW1uRmlsdGVycyA9XG4gICAgICAgIChfOCA9IHN0YXRlZnVsVGFibGVPcHRpb25zLm9uU2hvd0NvbHVtbkZpbHRlcnNDaGFuZ2UpICE9PSBudWxsICYmIF84ICE9PSB2b2lkIDAgPyBfOCA6IHNldFNob3dDb2x1bW5GaWx0ZXJzO1xuICAgIHRhYmxlLnNldFNob3dHbG9iYWxGaWx0ZXIgPVxuICAgICAgICAoXzkgPSBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5vblNob3dHbG9iYWxGaWx0ZXJDaGFuZ2UpICE9PSBudWxsICYmIF85ICE9PSB2b2lkIDAgPyBfOSA6IHNldFNob3dHbG9iYWxGaWx0ZXI7XG4gICAgdGFibGUuc2V0U2hvd1Rvb2xiYXJEcm9wWm9uZSA9XG4gICAgICAgIChfMTAgPSBzdGF0ZWZ1bFRhYmxlT3B0aW9ucy5vblNob3dUb29sYmFyRHJvcFpvbmVDaGFuZ2UpICE9PSBudWxsICYmIF8xMCAhPT0gdm9pZCAwID8gXzEwIDogc2V0U2hvd1Rvb2xiYXJEcm9wWm9uZTtcbiAgICB1c2VNUlRfRWZmZWN0cyh0YWJsZSk7XG4gICAgcmV0dXJuIHRhYmxlO1xufTtcblxuY29uc3QgdXNlTWF0ZXJpYWxSZWFjdFRhYmxlID0gKHRhYmxlT3B0aW9ucykgPT4gdXNlTVJUX1RhYmxlSW5zdGFuY2UodXNlTVJUX1RhYmxlT3B0aW9ucyh0YWJsZU9wdGlvbnMpKTtcblxuLyoqXG4gKiBXaGVuIHNjcm9sbCwgdGhlIGBkcmFnZ2luZ1Jvd2Agb3IgYGRyYWdnaW5nQ29sdW1uYCBjYW4gYmUgcmVtb3ZlZCBmcm9tIGRvY3VtZW50IGJlY2F1c2Ugb2YgdmlydHVhbGl6YXRpb24sXG4gKiB0aGVuLCB0aGUgYGRyYWdFbmRgIGV2ZW50IG9uIGBNUlRfVGFibGVCb2R5Um93R3JhYkhhbmRsZWAgb3IgYE1SVF9UYWJsZUhlYWRDZWxsR3JhYkhhbmRsZWAgd2lsbCBub3QgZmlyZS5cbiAqIFdlIHNob3VsZCBrZWVwIHRoZSBgZHJhZ2dpbmdSb3dgIG9yIGBkcmFnZ2luZ0NvbHVtbmAgaW4gYGdldFZpcnR1YWxJdGVtcygpYCB0byBhdm9pZCB0aGlzIHRoaW5nLlxuICovXG5jb25zdCBleHRyYUluZGV4UmFuZ2VFeHRyYWN0b3IgPSAocmFuZ2UsIGRyYWdnaW5nSW5kZXgpID0+IHtcbiAgICBjb25zdCBuZXdJbmRleGVzID0gZGVmYXVsdFJhbmdlRXh0cmFjdG9yKHJhbmdlKTtcbiAgICBpZiAoZHJhZ2dpbmdJbmRleCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3SW5kZXhlcztcbiAgICBpZiAoZHJhZ2dpbmdJbmRleCA+PSAwICYmXG4gICAgICAgIGRyYWdnaW5nSW5kZXggPCBNYXRoLm1heChyYW5nZS5zdGFydEluZGV4IC0gcmFuZ2Uub3ZlcnNjYW4sIDApKSB7XG4gICAgICAgIG5ld0luZGV4ZXMudW5zaGlmdChkcmFnZ2luZ0luZGV4KTtcbiAgICB9XG4gICAgaWYgKGRyYWdnaW5nSW5kZXggPj0gMCAmJiBkcmFnZ2luZ0luZGV4ID4gcmFuZ2UuZW5kSW5kZXggKyByYW5nZS5vdmVyc2Nhbikge1xuICAgICAgICBuZXdJbmRleGVzLnB1c2goZHJhZ2dpbmdJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdJbmRleGVzO1xufTtcblxuY29uc3QgdXNlTVJUX0NvbHVtblZpcnR1YWxpemVyID0gKHRhYmxlKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uVmlydHVhbGl6ZXJJbnN0YW5jZVJlZiwgY29sdW1uVmlydHVhbGl6ZXJPcHRpb25zLCBlbmFibGVDb2x1bW5QaW5uaW5nLCBlbmFibGVDb2x1bW5WaXJ0dWFsaXphdGlvbiwgfSwgcmVmczogeyB0YWJsZUNvbnRhaW5lclJlZiB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW5QaW5uaW5nLCBjb2x1bW5WaXNpYmlsaXR5LCBkcmFnZ2luZ0NvbHVtbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBpZiAoIWVuYWJsZUNvbHVtblZpcnR1YWxpemF0aW9uKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNvbHVtblZpcnR1YWxpemVyUHJvcHMgPSBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uVmlydHVhbGl6ZXJPcHRpb25zLCB7XG4gICAgICAgIHRhYmxlLFxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVDb2x1bW5zID0gdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCk7XG4gICAgY29uc3QgW2xlZnRQaW5uZWRJbmRleGVzLCByaWdodFBpbm5lZEluZGV4ZXNdID0gdXNlTWVtbygoKSA9PiBlbmFibGVDb2x1bW5QaW5uaW5nXG4gICAgICAgID8gW1xuICAgICAgICAgICAgdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucygpLm1hcCgoYykgPT4gYy5nZXRQaW5uZWRJbmRleCgpKSxcbiAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgICAgICAgLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zKClcbiAgICAgICAgICAgICAgICAubWFwKChjb2x1bW4pID0+IHZpc2libGVDb2x1bW5zLmxlbmd0aCAtIGNvbHVtbi5nZXRQaW5uZWRJbmRleCgpIC0gMSlcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpLFxuICAgICAgICBdXG4gICAgICAgIDogW1tdLCBbXV0sIFtjb2x1bW5QaW5uaW5nLCBjb2x1bW5WaXNpYmlsaXR5LCBlbmFibGVDb2x1bW5QaW5uaW5nXSk7XG4gICAgY29uc3QgbnVtUGlubmVkTGVmdCA9IGxlZnRQaW5uZWRJbmRleGVzLmxlbmd0aDtcbiAgICBjb25zdCBudW1QaW5uZWRSaWdodCA9IHJpZ2h0UGlubmVkSW5kZXhlcy5sZW5ndGg7XG4gICAgY29uc3QgZHJhZ2dpbmdDb2x1bW5JbmRleCA9IHVzZU1lbW8oKCkgPT4gKGRyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5pZClcbiAgICAgICAgPyB2aXNpYmxlQ29sdW1ucy5maW5kSW5kZXgoKGMpID0+IGMuaWQgPT09IChkcmFnZ2luZ0NvbHVtbiA9PT0gbnVsbCB8fCBkcmFnZ2luZ0NvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ2dpbmdDb2x1bW4uaWQpKVxuICAgICAgICA6IHVuZGVmaW5lZCwgW2RyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5pZF0pO1xuICAgIGNvbnN0IGNvbHVtblZpcnR1YWxpemVyID0gdXNlVmlydHVhbGl6ZXIoT2JqZWN0LmFzc2lnbih7IGNvdW50OiB2aXNpYmxlQ29sdW1ucy5sZW5ndGgsIGVzdGltYXRlU2l6ZTogKGluZGV4KSA9PiB2aXNpYmxlQ29sdW1uc1tpbmRleF0uZ2V0U2l6ZSgpLCBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiB0YWJsZUNvbnRhaW5lclJlZi5jdXJyZW50LCBob3Jpem9udGFsOiB0cnVlLCBvdmVyc2NhbjogMywgcmFuZ2VFeHRyYWN0b3I6IHVzZUNhbGxiYWNrKChyYW5nZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IGV4dHJhSW5kZXhSYW5nZUV4dHJhY3RvcihyYW5nZSwgZHJhZ2dpbmdDb2x1bW5JbmRleCk7XG4gICAgICAgICAgICBpZiAoIW51bVBpbm5lZExlZnQgJiYgIW51bVBpbm5lZFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0luZGV4ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAuLi5sZWZ0UGlubmVkSW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3SW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucmlnaHRQaW5uZWRJbmRleGVzLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSwgW2xlZnRQaW5uZWRJbmRleGVzLCByaWdodFBpbm5lZEluZGV4ZXMsIGRyYWdnaW5nQ29sdW1uSW5kZXhdKSB9LCBjb2x1bW5WaXJ0dWFsaXplclByb3BzKSk7XG4gICAgY29uc3QgdmlydHVhbENvbHVtbnMgPSBjb2x1bW5WaXJ0dWFsaXplci5nZXRWaXJ0dWFsSXRlbXMoKTtcbiAgICBjb2x1bW5WaXJ0dWFsaXplci52aXJ0dWFsQ29sdW1ucyA9IHZpcnR1YWxDb2x1bW5zO1xuICAgIGNvbnN0IG51bUNvbHVtbnMgPSB2aXJ0dWFsQ29sdW1ucy5sZW5ndGg7XG4gICAgaWYgKG51bUNvbHVtbnMpIHtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gY29sdW1uVmlydHVhbGl6ZXIuZ2V0VG90YWxTaXplKCk7XG4gICAgICAgIGNvbnN0IGxlZnROb25QaW5uZWRTdGFydCA9ICgoX2EgPSB2aXJ0dWFsQ29sdW1uc1tudW1QaW5uZWRMZWZ0XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0KSB8fCAwO1xuICAgICAgICBjb25zdCBsZWZ0Tm9uUGlubmVkRW5kID0gKChfYiA9IHZpcnR1YWxDb2x1bW5zW2xlZnRQaW5uZWRJbmRleGVzLmxlbmd0aCAtIDFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW5kKSB8fCAwO1xuICAgICAgICBjb25zdCByaWdodE5vblBpbm5lZFN0YXJ0ID0gKChfYyA9IHZpcnR1YWxDb2x1bW5zW251bUNvbHVtbnMgLSBudW1QaW5uZWRSaWdodF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdGFydCkgfHwgMDtcbiAgICAgICAgY29uc3QgcmlnaHROb25QaW5uZWRFbmQgPSAoKF9kID0gdmlydHVhbENvbHVtbnNbbnVtQ29sdW1ucyAtIG51bVBpbm5lZFJpZ2h0IC0gMV0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5lbmQpIHx8IDA7XG4gICAgICAgIGNvbHVtblZpcnR1YWxpemVyLnZpcnR1YWxQYWRkaW5nTGVmdCA9XG4gICAgICAgICAgICBsZWZ0Tm9uUGlubmVkU3RhcnQgLSBsZWZ0Tm9uUGlubmVkRW5kO1xuICAgICAgICBjb2x1bW5WaXJ0dWFsaXplci52aXJ0dWFsUGFkZGluZ1JpZ2h0ID1cbiAgICAgICAgICAgIHRvdGFsU2l6ZSAtXG4gICAgICAgICAgICAgICAgcmlnaHROb25QaW5uZWRFbmQgLVxuICAgICAgICAgICAgICAgIChudW1QaW5uZWRSaWdodCA/IHRvdGFsU2l6ZSAtIHJpZ2h0Tm9uUGlubmVkU3RhcnQgOiAwKTtcbiAgICB9XG4gICAgaWYgKGNvbHVtblZpcnR1YWxpemVySW5zdGFuY2VSZWYpIHtcbiAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbHVtblZpcnR1YWxpemVySW5zdGFuY2VSZWYuY3VycmVudCA9IGNvbHVtblZpcnR1YWxpemVyO1xuICAgIH1cbiAgICByZXR1cm4gY29sdW1uVmlydHVhbGl6ZXI7XG59O1xuXG5jb25zdCB1c2VNUlRfUm93VmlydHVhbGl6ZXIgPSAodGFibGUsIHJvd3MpID0+IHtcbiAgICBjb25zdCB7IGdldFJvd01vZGVsLCBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVSb3dWaXJ0dWFsaXphdGlvbiwgcmVuZGVyRGV0YWlsUGFuZWwsIHJvd1ZpcnR1YWxpemVySW5zdGFuY2VSZWYsIHJvd1ZpcnR1YWxpemVyT3B0aW9ucywgfSwgcmVmczogeyB0YWJsZUNvbnRhaW5lclJlZiB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5LCBkcmFnZ2luZ1JvdywgZXhwYW5kZWQgfSA9IGdldFN0YXRlKCk7XG4gICAgaWYgKCFlbmFibGVSb3dWaXJ0dWFsaXphdGlvbilcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCByb3dWaXJ0dWFsaXplclByb3BzID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHJvd1ZpcnR1YWxpemVyT3B0aW9ucywge1xuICAgICAgICB0YWJsZSxcbiAgICB9KTtcbiAgICBjb25zdCByZWFsUm93cyA9IHJvd3MgIT09IG51bGwgJiYgcm93cyAhPT0gdm9pZCAwID8gcm93cyA6IGdldFJvd01vZGVsKCkucm93cztcbiAgICAvKipcbiAgICAgKiB3aGVuIGZpbHRlcmluZywgc2hvdWxkIGZpbmQgdGhlIGNvcnJlY3QgaW5kZXggaW4gZmlsdGVyZWQgcm93c1xuICAgICAqL1xuICAgIGNvbnN0IGRyYWdnaW5nUm93SW5kZXggPSB1c2VNZW1vKCgpID0+IChkcmFnZ2luZ1JvdyA9PT0gbnVsbCB8fCBkcmFnZ2luZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ2dpbmdSb3cuaWQpXG4gICAgICAgID8gcmVhbFJvd3MuZmluZEluZGV4KChyKSA9PiByLmlkID09PSAoZHJhZ2dpbmdSb3cgPT09IG51bGwgfHwgZHJhZ2dpbmdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdnaW5nUm93LmlkKSlcbiAgICAgICAgOiB1bmRlZmluZWQsIFtyZWFsUm93cywgZHJhZ2dpbmdSb3cgPT09IG51bGwgfHwgZHJhZ2dpbmdSb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdnaW5nUm93LmlkXSk7XG4gICAgY29uc3Qgcm93Q291bnQgPSByZWFsUm93cy5sZW5ndGg7XG4gICAgY29uc3Qgbm9ybWFsUm93SGVpZ2h0ID0gZGVuc2l0eSA9PT0gJ2NvbXBhY3QnID8gMzcgOiBkZW5zaXR5ID09PSAnY29tZm9ydGFibGUnID8gNTggOiA3MztcbiAgICBjb25zdCByb3dWaXJ0dWFsaXplciA9IHVzZVZpcnR1YWxpemVyKE9iamVjdC5hc3NpZ24oeyBjb3VudDogcmVuZGVyRGV0YWlsUGFuZWwgPyByb3dDb3VudCAqIDIgOiByb3dDb3VudCwgZXN0aW1hdGVTaXplOiAoaW5kZXgpID0+IHJlbmRlckRldGFpbFBhbmVsICYmIGluZGV4ICUgMiA9PT0gMVxuICAgICAgICAgICAgPyBleHBhbmRlZCA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgID8gMTAwXG4gICAgICAgICAgICAgICAgOiAwXG4gICAgICAgICAgICA6IG5vcm1hbFJvd0hlaWdodCwgZ2V0U2Nyb2xsRWxlbWVudDogKCkgPT4gdGFibGVDb250YWluZXJSZWYuY3VycmVudCwgbWVhc3VyZUVsZW1lbnQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTFcbiAgICAgICAgICAgID8gKGVsZW1lbnQpID0+IGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvdmVyc2NhbjogNCwgcmFuZ2VFeHRyYWN0b3I6IHVzZUNhbGxiYWNrKChyYW5nZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhSW5kZXhSYW5nZUV4dHJhY3RvcihyYW5nZSwgZHJhZ2dpbmdSb3dJbmRleCk7XG4gICAgICAgIH0sIFtkcmFnZ2luZ1Jvd0luZGV4XSkgfSwgcm93VmlydHVhbGl6ZXJQcm9wcykpO1xuICAgIHJvd1ZpcnR1YWxpemVyLnZpcnR1YWxSb3dzID0gcm93VmlydHVhbGl6ZXIuZ2V0VmlydHVhbEl0ZW1zKCk7XG4gICAgaWYgKHJvd1ZpcnR1YWxpemVySW5zdGFuY2VSZWYpIHtcbiAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvd1ZpcnR1YWxpemVySW5zdGFuY2VSZWYuY3VycmVudCA9IHJvd1ZpcnR1YWxpemVyO1xuICAgIH1cbiAgICByZXR1cm4gcm93VmlydHVhbGl6ZXI7XG59O1xuXG5jb25zdCB1c2VNUlRfUm93cyA9ICh0YWJsZSkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0Um93TW9kZWwsIGdldFN0YXRlLCBvcHRpb25zOiB7IGRhdGEsIGVuYWJsZUdsb2JhbEZpbHRlclJhbmtlZFJlc3VsdHMsIHBvc2l0aW9uQ3JlYXRpbmdSb3cgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIGV4cGFuZGVkLCBnbG9iYWxGaWx0ZXIsIHBhZ2luYXRpb24sIHJvd1Bpbm5pbmcsIHNvcnRpbmcsIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHJvd3MgPSB1c2VNZW1vKCgpID0+IGdldE1SVF9Sb3dzKHRhYmxlKSwgW1xuICAgICAgICBjcmVhdGluZ1JvdyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZW5hYmxlR2xvYmFsRmlsdGVyUmFua2VkUmVzdWx0cyxcbiAgICAgICAgZXhwYW5kZWQsXG4gICAgICAgIGdldFJvd01vZGVsKCkucm93cyxcbiAgICAgICAgZ2xvYmFsRmlsdGVyLFxuICAgICAgICBwYWdpbmF0aW9uLnBhZ2VJbmRleCxcbiAgICAgICAgcGFnaW5hdGlvbi5wYWdlU2l6ZSxcbiAgICAgICAgcG9zaXRpb25DcmVhdGluZ1JvdyxcbiAgICAgICAgcm93UGlubmluZyxcbiAgICAgICAgc29ydGluZyxcbiAgICBdKTtcbiAgICByZXR1cm4gcm93cztcbn07XG5cbmNvbnN0IGFsbG93ZWRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlciddO1xuY29uc3QgTVJUX1RhYmxlQm9keUNlbGxWYWx1ZSA9ICh7IGNlbGwsIHJvd1JlZiwgc3RhdGljQ29sdW1uSW5kZXgsIHN0YXRpY1Jvd0luZGV4LCB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlRmlsdGVyTWF0Y2hIaWdobGlnaHRpbmcsIG1ydFRoZW1lOiB7IG1hdGNoSGlnaGxpZ2h0Q29sb3IgfSwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uLCByb3cgfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGdsb2JhbEZpbHRlciwgZ2xvYmFsRmlsdGVyRm4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKTtcbiAgICBsZXQgcmVuZGVyZWRDZWxsVmFsdWUgPSBjZWxsLmdldElzQWdncmVnYXRlZCgpICYmIGNvbHVtbkRlZi5BZ2dyZWdhdGVkQ2VsbFxuICAgICAgICA/IGNvbHVtbkRlZi5BZ2dyZWdhdGVkQ2VsbCh7XG4gICAgICAgICAgICBjZWxsLFxuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICBzdGF0aWNDb2x1bW5JbmRleCxcbiAgICAgICAgICAgIHN0YXRpY1Jvd0luZGV4LFxuICAgICAgICB9KVxuICAgICAgICA6IHJvdy5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc0dyb3VwZWQoKVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uRGVmLkdyb3VwZWRDZWxsXG4gICAgICAgICAgICAgICAgPyBjb2x1bW5EZWYuR3JvdXBlZENlbGwoe1xuICAgICAgICAgICAgICAgICAgICBjZWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNSb3dJbmRleCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzR3JvdXBlZFZhbHVlID0gcmVuZGVyZWRDZWxsVmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoIWlzR3JvdXBlZFZhbHVlKSB7XG4gICAgICAgIHJlbmRlcmVkQ2VsbFZhbHVlID0gY2VsbC5yZW5kZXJWYWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoZW5hYmxlRmlsdGVyTWF0Y2hIaWdobGlnaHRpbmcgJiZcbiAgICAgICAgY29sdW1uRGVmLmVuYWJsZUZpbHRlck1hdGNoSGlnaGxpZ2h0aW5nICE9PSBmYWxzZSAmJlxuICAgICAgICBTdHJpbmcocmVuZGVyZWRDZWxsVmFsdWUpICYmXG4gICAgICAgIGFsbG93ZWRUeXBlcy5pbmNsdWRlcyh0eXBlb2YgcmVuZGVyZWRDZWxsVmFsdWUpICYmXG4gICAgICAgICgoZmlsdGVyVmFsdWUgJiZcbiAgICAgICAgICAgIGFsbG93ZWRUeXBlcy5pbmNsdWRlcyh0eXBlb2YgZmlsdGVyVmFsdWUpICYmXG4gICAgICAgICAgICBbJ2F1dG9jb21wbGV0ZScsICd0ZXh0J10uaW5jbHVkZXMoY29sdW1uRGVmLmZpbHRlclZhcmlhbnQpKSB8fFxuICAgICAgICAgICAgKGdsb2JhbEZpbHRlciAmJlxuICAgICAgICAgICAgICAgIGFsbG93ZWRUeXBlcy5pbmNsdWRlcyh0eXBlb2YgZ2xvYmFsRmlsdGVyKSAmJlxuICAgICAgICAgICAgICAgIGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSkpKSB7XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IGhpZ2hsaWdodFdvcmRzID09PSBudWxsIHx8IGhpZ2hsaWdodFdvcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoaWdobGlnaHRXb3Jkcyh7XG4gICAgICAgICAgICBtYXRjaEV4YWN0bHk6IChmaWx0ZXJWYWx1ZSA/IGNvbHVtbkRlZi5fZmlsdGVyRm4gOiBnbG9iYWxGaWx0ZXJGbikgIT09ICdmdXp6eScsXG4gICAgICAgICAgICBxdWVyeTogKChfYSA9IGZpbHRlclZhbHVlICE9PSBudWxsICYmIGZpbHRlclZhbHVlICE9PSB2b2lkIDAgPyBmaWx0ZXJWYWx1ZSA6IGdsb2JhbEZpbHRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0ZXh0OiByZW5kZXJlZENlbGxWYWx1ZSA9PT0gbnVsbCB8fCByZW5kZXJlZENlbGxWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZWRDZWxsVmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoY2h1bmtzID09PSBudWxsIHx8IGNodW5rcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2h1bmtzLmxlbmd0aCkgPiAxIHx8ICgoX2IgPSBjaHVua3MgPT09IG51bGwgfHwgY2h1bmtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaHVua3NbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXRjaCkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkQ2VsbFZhbHVlID0gKGpzeChcInNwYW5cIiwgeyBcImFyaWEtbGFiZWxcIjogcmVuZGVyZWRDZWxsVmFsdWUsIHJvbGU6IFwibm90ZVwiLCBjaGlsZHJlbjogKF9jID0gY2h1bmtzID09PSBudWxsIHx8IGNodW5rcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2h1bmtzLm1hcCgoeyBrZXksIG1hdGNoLCB0ZXh0IH0pID0+IChqc3goQm94LCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNvbXBvbmVudDogXCJzcGFuXCIsIHN4OiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtYXRjaEhpZ2hsaWdodENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICh0aGVtZSkgPT4gdGhlbWUucGFsZXR0ZS5tb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGVtZS5wYWxldHRlLmNvbW1vbi53aGl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoZW1lLnBhbGV0dGUuY29tbW9uLmJsYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcycHggMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBjaGlsZHJlbjogdGV4dCB9LCBrZXkpKSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHJlbmRlcmVkQ2VsbFZhbHVlIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sdW1uRGVmLkNlbGwgJiYgIWlzR3JvdXBlZFZhbHVlKSB7XG4gICAgICAgIHJlbmRlcmVkQ2VsbFZhbHVlID0gY29sdW1uRGVmLkNlbGwoe1xuICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHJlbmRlcmVkQ2VsbFZhbHVlLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgcm93UmVmLFxuICAgICAgICAgICAgc3RhdGljQ29sdW1uSW5kZXgsXG4gICAgICAgICAgICBzdGF0aWNSb3dJbmRleCxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVkQ2VsbFZhbHVlO1xufTtcblxuY29uc3QgTVJUX0NvcHlCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgY2VsbCwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjZWxsXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBsb2NhbGl6YXRpb24sIG11aUNvcHlCdXR0b25Qcm9wcyB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW4sIHJvdyB9ID0gY2VsbDtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IFtjb3BpZWQsIHNldENvcGllZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlQ29weSA9IChldmVudCwgdGV4dCkgPT4ge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCk7XG4gICAgICAgIHNldENvcGllZCh0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDb3BpZWQoZmFsc2UpLCA0MDAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGJ1dHRvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlDb3B5QnV0dG9uUHJvcHMsIHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNvbHVtbkRlZi5tdWlDb3B5QnV0dG9uUHJvcHMsIHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcmVzdCk7XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCd0b3AnKSwgeyB0aXRsZTogKF9iID0gYnV0dG9uUHJvcHMgPT09IG51bGwgfHwgYnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1dHRvblByb3BzLnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoY29waWVkID8gbG9jYWxpemF0aW9uLmNvcGllZFRvQ2xpcGJvYXJkIDogbG9jYWxpemF0aW9uLmNsaWNrVG9Db3B5KSwgY2hpbGRyZW46IGpzeChCdXR0b24sIE9iamVjdC5hc3NpZ24oeyBvbkNsaWNrOiAoZSkgPT4gaGFuZGxlQ29weShlLCBjZWxsLmdldFZhbHVlKCkpLCBzaXplOiBcInNtYWxsXCIsIHR5cGU6IFwiYnV0dG9uXCIsIHZhcmlhbnQ6IFwidGV4dFwiIH0sIGJ1dHRvblByb3BzLCB7IHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLCBib3JkZXI6ICdub25lJywgY29sb3I6ICdpbmhlcml0JywgY3Vyc29yOiAnY29weScsIGZvbnRGYW1pbHk6ICdpbmhlcml0JywgZm9udFNpemU6ICdpbmhlcml0JywgbGV0dGVyU3BhY2luZzogJ2luaGVyaXQnLCBtOiAnLTAuMjVyZW0nLCBtaW5XaWR0aDogJ3Vuc2V0JywgcHk6IDAsIHRleHRBbGlnbjogJ2luaGVyaXQnLCB0ZXh0VHJhbnNmb3JtOiAnaW5oZXJpdCcgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGJ1dHRvblByb3BzID09PSBudWxsIHx8IGJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidXR0b25Qcm9wcy5zeCwgdGhlbWUpKSksIHRpdGxlOiB1bmRlZmluZWQgfSkpIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfRWRpdENlbGxUZXh0RmllbGQgPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IGNlbGwsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2VsbFwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGNyZWF0ZURpc3BsYXlNb2RlLCBlZGl0RGlzcGxheU1vZGUsIG11aUVkaXRUZXh0RmllbGRQcm9wcyB9LCByZWZzOiB7IGVkaXRJbnB1dFJlZnMgfSwgc2V0Q3JlYXRpbmdSb3csIHNldEVkaXRpbmdDZWxsLCBzZXRFZGl0aW5nUm93LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW4sIHJvdyB9ID0gY2VsbDtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIGVkaXRpbmdSb3cgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBlZGl0U2VsZWN0T3B0aW9ucywgZWRpdFZhcmlhbnQgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBpc0NyZWF0aW5nID0gKGNyZWF0aW5nUm93ID09PSBudWxsIHx8IGNyZWF0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGluZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCBpc0VkaXRpbmcgPSAoZWRpdGluZ1JvdyA9PT0gbnVsbCB8fCBlZGl0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0aW5nUm93LmlkKSA9PT0gcm93LmlkO1xuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoKCkgPT4gY2VsbC5nZXRWYWx1ZSgpKTtcbiAgICBjb25zdCBbY29tcGxldGVzQ29tcG9zaXRpb24sIHNldENvbXBsZXRlc0NvbXBvc2l0aW9uXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IHRleHRGaWVsZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlFZGl0VGV4dEZpZWxkUHJvcHMsIHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNvbHVtbkRlZi5tdWlFZGl0VGV4dEZpZWxkUHJvcHMsIHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcmVzdCk7XG4gICAgY29uc3Qgc2VsZWN0T3B0aW9ucyA9IHBhcnNlRnJvbVZhbHVlc09yRnVuYyhlZGl0U2VsZWN0T3B0aW9ucywge1xuICAgICAgICBjZWxsLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHJvdyxcbiAgICAgICAgdGFibGUsXG4gICAgfSk7XG4gICAgY29uc3QgaXNTZWxlY3RFZGl0ID0gZWRpdFZhcmlhbnQgPT09ICdzZWxlY3QnIHx8ICh0ZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEZpZWxkUHJvcHMuc2VsZWN0KTtcbiAgICBjb25zdCBzYXZlSW5wdXRWYWx1ZVRvUm93Q2FjaGUgPSAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uLmlkXSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAoaXNDcmVhdGluZykge1xuICAgICAgICAgICAgc2V0Q3JlYXRpbmdSb3cocm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHNldEVkaXRpbmdSb3cocm93KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGV4dEZpZWxkUHJvcHMub25DaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRleHRGaWVsZFByb3BzLCBldmVudCk7XG4gICAgICAgIHNldFZhbHVlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgIGlmIChpc1NlbGVjdEVkaXQpIHtcbiAgICAgICAgICAgIHNhdmVJbnB1dFZhbHVlVG9Sb3dDYWNoZShldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVCbHVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGV4dEZpZWxkUHJvcHMub25CbHVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0ZXh0RmllbGRQcm9wcywgZXZlbnQpO1xuICAgICAgICBzYXZlSW5wdXRWYWx1ZVRvUm93Q2FjaGUodmFsdWUpO1xuICAgICAgICBzZXRFZGl0aW5nQ2VsbChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUVudGVyS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgKF9hID0gdGV4dEZpZWxkUHJvcHMub25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0ZXh0RmllbGRQcm9wcywgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInICYmICFldmVudC5zaGlmdEtleSAmJiBjb21wbGV0ZXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgKF9jID0gKF9iID0gZWRpdElucHV0UmVmcy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbY29sdW1uLmlkXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNvbHVtbkRlZi5FZGl0KSB7XG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IChfYiA9IGNvbHVtbkRlZi5FZGl0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjb2x1bW5EZWYsIHsgY2VsbCwgY29sdW1uLCByb3csIHRhYmxlIH0pIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChUZXh0RmllbGQsIE9iamVjdC5hc3NpZ24oeyBkaXNhYmxlZDogcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNvbHVtbkRlZi5lbmFibGVFZGl0aW5nLCByb3cpID09PSBmYWxzZSwgZnVsbFdpZHRoOiB0cnVlLCBpbnB1dFJlZjogKGlucHV0UmVmKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5wdXRSZWYpIHtcbiAgICAgICAgICAgICAgICBlZGl0SW5wdXRSZWZzLmN1cnJlbnRbY29sdW1uLmlkXSA9IGlzU2VsZWN0RWRpdFxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0UmVmLm5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dFJlZjtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEZpZWxkUHJvcHMuaW5wdXRSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpZWxkUHJvcHMuaW5wdXRSZWYgPSBpbnB1dFJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGxhYmVsOiBbJ2N1c3RvbScsICdtb2RhbCddLmluY2x1ZGVzKChpc0NyZWF0aW5nID8gY3JlYXRlRGlzcGxheU1vZGUgOiBlZGl0RGlzcGxheU1vZGUpKVxuICAgICAgICAgICAgPyBjb2x1bW5EZWYuaGVhZGVyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgbWFyZ2luOiBcIm5vbmVcIiwgbmFtZTogY29sdW1uLmlkLCBwbGFjZWhvbGRlcjogIVsnY3VzdG9tJywgJ21vZGFsJ10uaW5jbHVkZXMoKGlzQ3JlYXRpbmcgPyBjcmVhdGVEaXNwbGF5TW9kZSA6IGVkaXREaXNwbGF5TW9kZSkpXG4gICAgICAgICAgICA/IGNvbHVtbkRlZi5oZWFkZXJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBzZWxlY3Q6IGlzU2VsZWN0RWRpdCwgc2l6ZTogXCJzbWFsbFwiLCB2YWx1ZTogdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogJycsIHZhcmlhbnQ6IFwic3RhbmRhcmRcIiB9LCB0ZXh0RmllbGRQcm9wcywgeyBJbnB1dFByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHRleHRGaWVsZFByb3BzLnZhcmlhbnQgIT09ICdvdXRsaW5lZCdcbiAgICAgICAgICAgID8geyBkaXNhYmxlVW5kZXJsaW5lOiBlZGl0RGlzcGxheU1vZGUgPT09ICd0YWJsZScgfVxuICAgICAgICAgICAgOiB7fSkpLCB0ZXh0RmllbGRQcm9wcy5JbnB1dFByb3BzKSwgeyBzeDogKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbih7IG1iOiAwIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYygoX2EgPSB0ZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEZpZWxkUHJvcHMuSW5wdXRQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN4LCB0aGVtZSkpKTtcbiAgICAgICAgICAgIH0gfSksIFNlbGVjdFByb3BzOiBPYmplY3QuYXNzaWduKHsgTWVudVByb3BzOiB7IGRpc2FibGVTY3JvbGxMb2NrOiB0cnVlIH0gfSwgdGV4dEZpZWxkUHJvcHMuU2VsZWN0UHJvcHMpLCBpbnB1dFByb3BzOiBPYmplY3QuYXNzaWduKHsgYXV0b0NvbXBsZXRlOiAnb2ZmJyB9LCB0ZXh0RmllbGRQcm9wcy5pbnB1dFByb3BzKSwgb25CbHVyOiBoYW5kbGVCbHVyLCBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLCBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIChfYSA9IHRleHRGaWVsZFByb3BzID09PSBudWxsIHx8IHRleHRGaWVsZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RmllbGRQcm9wcy5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0ZXh0RmllbGRQcm9wcywgZSk7XG4gICAgICAgIH0sIG9uS2V5RG93bjogaGFuZGxlRW50ZXJLZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQ6ICgpID0+IHNldENvbXBsZXRlc0NvbXBvc2l0aW9uKGZhbHNlKSwgb25Db21wb3NpdGlvbkVuZDogKCkgPT4gc2V0Q29tcGxldGVzQ29tcG9zaXRpb24odHJ1ZSksIGNoaWxkcmVuOiAoX2MgPSB0ZXh0RmllbGRQcm9wcy5jaGlsZHJlbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc2VsZWN0T3B0aW9ucyA9PT0gbnVsbCB8fCBzZWxlY3RPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RPcHRpb25zLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsLCB2YWx1ZSB9ID0gZ2V0VmFsdWVBbmRMYWJlbChvcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIChqc3goTWVudUl0ZW0sIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgbTogMCxcbiAgICAgICAgICAgICAgICB9LCB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBsYWJlbCB9LCB2YWx1ZSkpO1xuICAgICAgICB9KSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlQm9keUNlbGwgPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHZhciB7IGNlbGwsIG51bVJvd3MsIHJvd1JlZiwgc3RhdGljQ29sdW1uSW5kZXgsIHN0YXRpY1Jvd0luZGV4LCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNlbGxcIiwgXCJudW1Sb3dzXCIsIFwicm93UmVmXCIsIFwic3RhdGljQ29sdW1uSW5kZXhcIiwgXCJzdGF0aWNSb3dJbmRleFwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBjb2x1bW5SZXNpemVEaXJlY3Rpb24sIGNvbHVtblJlc2l6ZU1vZGUsIGNyZWF0ZURpc3BsYXlNb2RlLCBlZGl0RGlzcGxheU1vZGUsIGVuYWJsZUNlbGxBY3Rpb25zLCBlbmFibGVDbGlja1RvQ29weSwgZW5hYmxlQ29sdW1uT3JkZXJpbmcsIGVuYWJsZUNvbHVtblBpbm5pbmcsIGVuYWJsZUdyb3VwaW5nLCBlbmFibGVLZXlib2FyZFNob3J0Y3V0cywgbGF5b3V0TW9kZSwgbXJ0VGhlbWU6IHsgZHJhZ2dpbmdCb3JkZXJDb2xvciB9LCBtdWlTa2VsZXRvblByb3BzLCBtdWlUYWJsZUJvZHlDZWxsUHJvcHMsIH0sIHNldEhvdmVyZWRDb2x1bW4sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGFjdGlvbkNlbGwsIGNvbHVtblNpemluZ0luZm8sIGNyZWF0aW5nUm93LCBkZW5zaXR5LCBkcmFnZ2luZ0NvbHVtbiwgZHJhZ2dpbmdSb3csIGVkaXRpbmdDZWxsLCBlZGl0aW5nUm93LCBob3ZlcmVkQ29sdW1uLCBob3ZlcmVkUm93LCBpc0xvYWRpbmcsIHNob3dTa2VsZXRvbnMsIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgY29sdW1uLCByb3cgfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZlR5cGUgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBhcmdzID0geyBjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUgfTtcbiAgICBjb25zdCB0YWJsZUNlbGxQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpVGFibGVCb2R5Q2VsbFByb3BzLCBhcmdzKSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpVGFibGVCb2R5Q2VsbFByb3BzLCBhcmdzKSksIHJlc3QpO1xuICAgIGNvbnN0IHNrZWxldG9uUHJvcHMgPSBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpU2tlbGV0b25Qcm9wcywge1xuICAgICAgICBjZWxsLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHJvdyxcbiAgICAgICAgdGFibGUsXG4gICAgfSk7XG4gICAgY29uc3QgW3NrZWxldG9uV2lkdGgsIHNldFNrZWxldG9uV2lkdGhdID0gdXNlU3RhdGUoMTAwKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoKCFpc0xvYWRpbmcgJiYgIXNob3dTa2VsZXRvbnMpIHx8IHNrZWxldG9uV2lkdGggIT09IDEwMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNvbHVtbi5nZXRTaXplKCk7XG4gICAgICAgIHNldFNrZWxldG9uV2lkdGgoY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICA/IHNpemUgLyAyXG4gICAgICAgICAgICA6IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChzaXplIC0gc2l6ZSAvIDMpICsgc2l6ZSAvIDMpKTtcbiAgICB9LCBbaXNMb2FkaW5nLCBzaG93U2tlbGV0b25zXSk7XG4gICAgY29uc3QgZHJhZ2dpbmdCb3JkZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dpbmdDb2x1bW4gPSAoZHJhZ2dpbmdDb2x1bW4gPT09IG51bGwgfHwgZHJhZ2dpbmdDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdnaW5nQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkO1xuICAgICAgICBjb25zdCBpc0hvdmVyZWRDb2x1bW4gPSAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkO1xuICAgICAgICBjb25zdCBpc0RyYWdnaW5nUm93ID0gKGRyYWdnaW5nUm93ID09PSBudWxsIHx8IGRyYWdnaW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkUm93ID0gKGhvdmVyZWRSb3cgPT09IG51bGwgfHwgaG92ZXJlZFJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJlZFJvdy5pZCkgPT09IHJvdy5pZDtcbiAgICAgICAgY29uc3QgaXNGaXJzdENvbHVtbiA9IGNvbHVtbi5nZXRJc0ZpcnN0Q29sdW1uKCk7XG4gICAgICAgIGNvbnN0IGlzTGFzdENvbHVtbiA9IGNvbHVtbi5nZXRJc0xhc3RDb2x1bW4oKTtcbiAgICAgICAgY29uc3QgaXNMYXN0Um93ID0gbnVtUm93cyAmJiBzdGF0aWNSb3dJbmRleCA9PT0gbnVtUm93cyAtIDE7XG4gICAgICAgIGNvbnN0IGlzUmVzaXppbmdDb2x1bW4gPSBjb2x1bW5TaXppbmdJbmZvLmlzUmVzaXppbmdDb2x1bW4gPT09IGNvbHVtbi5pZDtcbiAgICAgICAgY29uc3Qgc2hvd1Jlc2l6ZUJvcmRlciA9IGlzUmVzaXppbmdDb2x1bW4gJiYgY29sdW1uUmVzaXplTW9kZSA9PT0gJ29uQ2hhbmdlJztcbiAgICAgICAgY29uc3QgYm9yZGVyU3R5bGUgPSBzaG93UmVzaXplQm9yZGVyXG4gICAgICAgICAgICA/IGAycHggc29saWQgJHtkcmFnZ2luZ0JvcmRlckNvbG9yfSAhaW1wb3J0YW50YFxuICAgICAgICAgICAgOiBpc0RyYWdnaW5nQ29sdW1uIHx8IGlzRHJhZ2dpbmdSb3dcbiAgICAgICAgICAgICAgICA/IGAxcHggZGFzaGVkICR7dGhlbWUucGFsZXR0ZS5ncmV5WzUwMF19ICFpbXBvcnRhbnRgXG4gICAgICAgICAgICAgICAgOiBpc0hvdmVyZWRDb2x1bW4gfHwgaXNIb3ZlcmVkUm93IHx8IGlzUmVzaXppbmdDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgPyBgMnB4IGRhc2hlZCAke2RyYWdnaW5nQm9yZGVyQ29sb3J9ICFpbXBvcnRhbnRgXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2hvd1Jlc2l6ZUJvcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtblJlc2l6ZURpcmVjdGlvbiA9PT0gJ2x0cidcbiAgICAgICAgICAgICAgICA/IHsgYm9yZGVyUmlnaHQ6IGJvcmRlclN0eWxlIH1cbiAgICAgICAgICAgICAgICA6IHsgYm9yZGVyTGVmdDogYm9yZGVyU3R5bGUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9yZGVyU3R5bGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogaXNEcmFnZ2luZ1JvdyB8fCBpc0hvdmVyZWRSb3cgfHwgKGlzTGFzdFJvdyAmJiAhaXNSZXNpemluZ0NvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgPyBib3JkZXJTdHlsZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBpc0RyYWdnaW5nQ29sdW1uIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzSG92ZXJlZENvbHVtbiB8fFxuICAgICAgICAgICAgICAgICAgICAoKGlzRHJhZ2dpbmdSb3cgfHwgaXNIb3ZlcmVkUm93KSAmJiBpc0ZpcnN0Q29sdW1uKVxuICAgICAgICAgICAgICAgICAgICA/IGJvcmRlclN0eWxlXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBpc0RyYWdnaW5nQ29sdW1uIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzSG92ZXJlZENvbHVtbiB8fFxuICAgICAgICAgICAgICAgICAgICAoKGlzRHJhZ2dpbmdSb3cgfHwgaXNIb3ZlcmVkUm93KSAmJiBpc0xhc3RDb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgID8gYm9yZGVyU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBpc0RyYWdnaW5nUm93IHx8IGlzSG92ZXJlZFJvdyA/IGJvcmRlclN0eWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfSwgW1xuICAgICAgICBjb2x1bW5TaXppbmdJbmZvLmlzUmVzaXppbmdDb2x1bW4sXG4gICAgICAgIGRyYWdnaW5nQ29sdW1uLFxuICAgICAgICBkcmFnZ2luZ1JvdyxcbiAgICAgICAgaG92ZXJlZENvbHVtbixcbiAgICAgICAgaG92ZXJlZFJvdyxcbiAgICAgICAgc3RhdGljUm93SW5kZXgsXG4gICAgXSk7XG4gICAgY29uc3QgaXNDb2x1bW5QaW5uZWQgPSBlbmFibGVDb2x1bW5QaW5uaW5nICYmXG4gICAgICAgIGNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlICE9PSAnZ3JvdXAnICYmXG4gICAgICAgIGNvbHVtbi5nZXRJc1Bpbm5lZCgpO1xuICAgIGNvbnN0IGlzRWRpdGFibGUgPSBpc0NlbGxFZGl0YWJsZSh7IGNlbGwsIHRhYmxlIH0pO1xuICAgIGNvbnN0IGlzRWRpdGluZyA9IGlzRWRpdGFibGUgJiZcbiAgICAgICAgIVsnY3VzdG9tJywgJ21vZGFsJ10uaW5jbHVkZXMoZWRpdERpc3BsYXlNb2RlKSAmJlxuICAgICAgICAoZWRpdERpc3BsYXlNb2RlID09PSAndGFibGUnIHx8XG4gICAgICAgICAgICAoZWRpdGluZ1JvdyA9PT0gbnVsbCB8fCBlZGl0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0aW5nUm93LmlkKSA9PT0gcm93LmlkIHx8XG4gICAgICAgICAgICAoZWRpdGluZ0NlbGwgPT09IG51bGwgfHwgZWRpdGluZ0NlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRpbmdDZWxsLmlkKSA9PT0gY2VsbC5pZCkgJiZcbiAgICAgICAgIXJvdy5nZXRJc0dyb3VwZWQoKTtcbiAgICBjb25zdCBpc0NyZWF0aW5nID0gaXNFZGl0YWJsZSAmJiBjcmVhdGVEaXNwbGF5TW9kZSA9PT0gJ3JvdycgJiYgKGNyZWF0aW5nUm93ID09PSBudWxsIHx8IGNyZWF0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGluZ1Jvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCBzaG93Q2xpY2tUb0NvcHlCdXR0b24gPSAocGFyc2VGcm9tVmFsdWVzT3JGdW5jKGVuYWJsZUNsaWNrVG9Db3B5LCBjZWxsKSA9PT0gdHJ1ZSB8fFxuICAgICAgICBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLmVuYWJsZUNsaWNrVG9Db3B5LCBjZWxsKSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgIVsnY29udGV4dC1tZW51JywgZmFsc2VdLmluY2x1ZGVzKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYuZW5hYmxlQ2xpY2tUb0NvcHksIGNlbGwpKTtcbiAgICBjb25zdCBpc1JpZ2h0Q2xpY2thYmxlID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGVuYWJsZUNlbGxBY3Rpb25zLCBjZWxsKTtcbiAgICBjb25zdCBjZWxsVmFsdWVQcm9wcyA9IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHN0YXRpY0NvbHVtbkluZGV4LFxuICAgICAgICBzdGF0aWNSb3dJbmRleCxcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZURvdWJsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLm9uRG91YmxlQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRhYmxlQ2VsbFByb3BzLCBldmVudCk7XG4gICAgICAgIG9wZW5FZGl0aW5nQ2VsbCh7IGNlbGwsIHRhYmxlIH0pO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKGUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMub25EcmFnRW50ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRhYmxlQ2VsbFByb3BzLCBlKTtcbiAgICAgICAgaWYgKGVuYWJsZUdyb3VwaW5nICYmIChob3ZlcmVkQ29sdW1uID09PSBudWxsIHx8IGhvdmVyZWRDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvdmVyZWRDb2x1bW4uaWQpID09PSAnZHJvcC16b25lJykge1xuICAgICAgICAgICAgc2V0SG92ZXJlZENvbHVtbihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlQ29sdW1uT3JkZXJpbmcgJiYgZHJhZ2dpbmdDb2x1bW4pIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRDb2x1bW4oY29sdW1uRGVmLmVuYWJsZUNvbHVtbk9yZGVyaW5nICE9PSBmYWxzZSA/IGNvbHVtbiA6IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IChlKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5EZWYuZW5hYmxlQ29sdW1uT3JkZXJpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNvbnRleHRNZW51ID0gKGUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMub25Db250ZXh0TWVudSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFibGVDZWxsUHJvcHMsIGUpO1xuICAgICAgICBpZiAoaXNSaWdodENsaWNrYWJsZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGFibGUuc2V0QWN0aW9uQ2VsbChjZWxsKTtcbiAgICAgICAgICAgIHRhYmxlLnJlZnMuYWN0aW9uQ2VsbFJlZi5jdXJyZW50ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLm9uS2V5RG93bikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFibGVDZWxsUHJvcHMsIGV2ZW50KTtcbiAgICAgICAgY2VsbEtleWJvYXJkU2hvcnRjdXRzKHtcbiAgICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgICBjZWxsVmFsdWU6IGNlbGwuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3goVGFibGVDZWxsLCBPYmplY3QuYXNzaWduKHsgYWxpZ246IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnLCBcImRhdGEtaW5kZXhcIjogc3RhdGljQ29sdW1uSW5kZXgsIFwiZGF0YS1waW5uZWRcIjogISFpc0NvbHVtblBpbm5lZCB8fCB1bmRlZmluZWQsIHRhYkluZGV4OiBlbmFibGVLZXlib2FyZFNob3J0Y3V0cyA/IDAgOiB1bmRlZmluZWQgfSwgdGFibGVDZWxsUHJvcHMsIHsgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLCBvbkNvbnRleHRNZW51OiBoYW5kbGVDb250ZXh0TWVudSwgb25Eb3VibGVDbGljazogaGFuZGxlRG91YmxlQ2xpY2ssIG9uRHJhZ0VudGVyOiBoYW5kbGVEcmFnRW50ZXIsIG9uRHJhZ092ZXI6IGhhbmRsZURyYWdPdmVyLCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogKGFjdGlvbkNlbGwgPT09IG51bGwgfHwgYWN0aW9uQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uQ2VsbC5pZCkgPT09IGNlbGwuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgKGVkaXREaXNwbGF5TW9kZSA9PT0gJ2NlbGwnICYmIGlzRWRpdGFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChlZGl0RGlzcGxheU1vZGUgPT09ICd0YWJsZScgJiYgKGlzQ3JlYXRpbmcgfHwgaXNFZGl0aW5nKSlcbiAgICAgICAgICAgICAgICAgICAgPyBgMXB4IHNvbGlkICR7dGhlbWUucGFsZXR0ZS5ncmV5WzUwMF19YFxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdjbGlwJyxcbiAgICAgICAgICAgIH0sIGFsaWduSXRlbXM6IChsYXlvdXRNb2RlID09PSBudWxsIHx8IGxheW91dE1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dE1vZGUuc3RhcnRzV2l0aCgnZ3JpZCcpKSA/ICdjZW50ZXInIDogdW5kZWZpbmVkLCBjdXJzb3I6IGlzUmlnaHRDbGlja2FibGVcbiAgICAgICAgICAgICAgICA/ICdjb250ZXh0LW1lbnUnXG4gICAgICAgICAgICAgICAgOiBpc0VkaXRhYmxlICYmIGVkaXREaXNwbGF5TW9kZSA9PT0gJ2NlbGwnXG4gICAgICAgICAgICAgICAgICAgID8gJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICAgIDogJ2luaGVyaXQnLCBvdXRsaW5lOiAoYWN0aW9uQ2VsbCA9PT0gbnVsbCB8fCBhY3Rpb25DZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25DZWxsLmlkKSA9PT0gY2VsbC5pZFxuICAgICAgICAgICAgICAgID8gYDFweCBzb2xpZCAke3RoZW1lLnBhbGV0dGUuZ3JleVs1MDBdfWBcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb3V0bGluZU9mZnNldDogJy0xcHgnLCBvdmVyZmxvdzogJ2hpZGRlbicsIHA6IGRlbnNpdHkgPT09ICdjb21wYWN0J1xuICAgICAgICAgICAgICAgID8gY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICAgICAgICAgID8gJzAgMC41cmVtJ1xuICAgICAgICAgICAgICAgICAgICA6ICcwLjVyZW0nXG4gICAgICAgICAgICAgICAgOiBkZW5zaXR5ID09PSAnY29tZm9ydGFibGUnXG4gICAgICAgICAgICAgICAgICAgID8gY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcwLjVyZW0gMC43NXJlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJzFyZW0nXG4gICAgICAgICAgICAgICAgICAgIDogY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcxcmVtIDEuMjVyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcxLjVyZW0nLCB0ZXh0T3ZlcmZsb3c6IGNvbHVtbkRlZlR5cGUgIT09ICdkaXNwbGF5JyA/ICdlbGxpcHNpcycgOiB1bmRlZmluZWQsIHdoaXRlU3BhY2U6IHJvdy5nZXRJc1Bpbm5lZCgpIHx8IGRlbnNpdHkgPT09ICdjb21wYWN0JyA/ICdub3dyYXAnIDogJ25vcm1hbCcgfSwgZ2V0Q29tbW9uTVJUQ2VsbFN0eWxlcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHRhYmxlQ2VsbFByb3BzLFxuICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgIH0pKSwgZHJhZ2dpbmdCb3JkZXJzKSksIGNoaWxkcmVuOiAoX2IgPSB0YWJsZUNlbGxQcm9wcy5jaGlsZHJlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtjZWxsLmdldElzUGxhY2Vob2xkZXIoKSA/ICgoKF9kID0gKF9jID0gY29sdW1uRGVmLlBsYWNlaG9sZGVyQ2VsbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoY29sdW1uRGVmLCB7IGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSB9KSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbCkpIDogc2hvd1NrZWxldG9ucyAhPT0gZmFsc2UgJiYgKGlzTG9hZGluZyB8fCBzaG93U2tlbGV0b25zKSA/IChqc3goU2tlbGV0b24sIE9iamVjdC5hc3NpZ24oeyBhbmltYXRpb246IFwid2F2ZVwiLCBoZWlnaHQ6IDIwLCB3aWR0aDogc2tlbGV0b25XaWR0aCB9LCBza2VsZXRvblByb3BzKSkpIDogY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknICYmXG4gICAgICAgICAgICAgICAgICAgIChbJ21ydC1yb3ctZXhwYW5kJywgJ21ydC1yb3ctbnVtYmVycycsICdtcnQtcm93LXNlbGVjdCddLmluY2x1ZGVzKGNvbHVtbi5pZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFyb3cuZ2V0SXNHcm91cGVkKCkpID8gKChfZSA9IGNvbHVtbkRlZi5DZWxsKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChjb2x1bW5EZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENlbGxWYWx1ZTogY2VsbC5yZW5kZXJWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgIHJvd1JlZixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1Jvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgICAgICB9KSkgOiBpc0NyZWF0aW5nIHx8IGlzRWRpdGluZyA/IChqc3goTVJUX0VkaXRDZWxsVGV4dEZpZWxkLCB7IGNlbGw6IGNlbGwsIHRhYmxlOiB0YWJsZSB9KSkgOiBzaG93Q2xpY2tUb0NvcHlCdXR0b24gJiYgY29sdW1uRGVmLmVuYWJsZUNsaWNrVG9Db3B5ICE9PSBmYWxzZSA/IChqc3goTVJUX0NvcHlCdXR0b24sIHsgY2VsbDogY2VsbCwgdGFibGU6IHRhYmxlLCBjaGlsZHJlbjoganN4KE1SVF9UYWJsZUJvZHlDZWxsVmFsdWUsIE9iamVjdC5hc3NpZ24oe30sIGNlbGxWYWx1ZVByb3BzKSkgfSkpIDogKGpzeChNUlRfVGFibGVCb2R5Q2VsbFZhbHVlLCBPYmplY3QuYXNzaWduKHt9LCBjZWxsVmFsdWVQcm9wcykpKSwgY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY29sdW1uRGVmLkdyb3VwZWRDZWxsICYmIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXCIgKFwiLCAoX2YgPSByb3cuc3ViUm93cykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmxlbmd0aCwgXCIpXCJdIH0pKV0gfSkpIH0pKSk7XG59O1xuY29uc3QgTWVtb19NUlRfVGFibGVCb2R5Q2VsbCA9IG1lbW8oTVJUX1RhYmxlQm9keUNlbGwsIChwcmV2LCBuZXh0KSA9PiBuZXh0LmNlbGwgPT09IHByZXYuY2VsbCk7XG5cbmNvbnN0IE1SVF9UYWJsZURldGFpbFBhbmVsID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgcGFyZW50Um93UmVmLCByb3csIHJvd1ZpcnR1YWxpemVyLCBzdGF0aWNSb3dJbmRleCwgdGFibGUsIHZpcnR1YWxSb3cgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJwYXJlbnRSb3dSZWZcIiwgXCJyb3dcIiwgXCJyb3dWaXJ0dWFsaXplclwiLCBcInN0YXRpY1Jvd0luZGV4XCIsIFwidGFibGVcIiwgXCJ2aXJ0dWFsUm93XCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBnZXRWaXNpYmxlTGVhZkNvbHVtbnMsIG9wdGlvbnM6IHsgbGF5b3V0TW9kZSwgbXJ0VGhlbWU6IHsgYmFzZUJhY2tncm91bmRDb2xvciB9LCBtdWlEZXRhaWxQYW5lbFByb3BzLCBtdWlUYWJsZUJvZHlSb3dQcm9wcywgcmVuZGVyRGV0YWlsUGFuZWwsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzTG9hZGluZyB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZVJvd1Byb3BzID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRhYmxlQm9keVJvd1Byb3BzLCB7XG4gICAgICAgIGlzRGV0YWlsUGFuZWw6IHRydWUsXG4gICAgICAgIHJvdyxcbiAgICAgICAgc3RhdGljUm93SW5kZXgsXG4gICAgICAgIHRhYmxlLFxuICAgIH0pO1xuICAgIGNvbnN0IHRhYmxlQ2VsbFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpRGV0YWlsUGFuZWxQcm9wcywge1xuICAgICAgICByb3csXG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcmVzdCk7XG4gICAgY29uc3QgRGV0YWlsUGFuZWwgPSAhaXNMb2FkaW5nICYmIChyZW5kZXJEZXRhaWxQYW5lbCA9PT0gbnVsbCB8fCByZW5kZXJEZXRhaWxQYW5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyRGV0YWlsUGFuZWwoeyByb3csIHRhYmxlIH0pKTtcbiAgICByZXR1cm4gKGpzeChUYWJsZVJvdywgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogXCJNdWktVGFibGVCb2R5Q2VsbC1EZXRhaWxQYW5lbFwiLCBcImRhdGEtaW5kZXhcIjogcmVuZGVyRGV0YWlsUGFuZWwgPyBzdGF0aWNSb3dJbmRleCAqIDIgKyAxIDogc3RhdGljUm93SW5kZXgsIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gcm93VmlydHVhbGl6ZXIgPT09IG51bGwgfHwgcm93VmlydHVhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd1ZpcnR1YWxpemVyLm1lYXN1cmVFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyb3dWaXJ0dWFsaXplciwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gfSwgdGFibGVSb3dQcm9wcywgeyBzeDogKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKHsgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2ZsZXgnIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogdmlydHVhbFJvdyA/ICdhYnNvbHV0ZScgOiB1bmRlZmluZWQsIHRvcDogdmlydHVhbFJvd1xuICAgICAgICAgICAgICAgICAgICA/IGAkeyhfYiA9IChfYSA9IHBhcmVudFJvd1JlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHR9cHhgXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCB0cmFuc2Zvcm06IHZpcnR1YWxSb3dcbiAgICAgICAgICAgICAgICAgICAgPyBgdHJhbnNsYXRlWSgke3ZpcnR1YWxSb3cgPT09IG51bGwgfHwgdmlydHVhbFJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlydHVhbFJvdy5zdGFydH1weClgXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCB3aWR0aDogJzEwMCUnIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuc3gsIHRoZW1lKSkpO1xuICAgICAgICB9LCBjaGlsZHJlbjoganN4KFRhYmxlQ2VsbCwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogXCJNdWktVGFibGVCb2R5Q2VsbC1EZXRhaWxQYW5lbFwiLCBjb2xTcGFuOiBnZXRWaXNpYmxlTGVhZkNvbHVtbnMoKS5sZW5ndGggfSwgdGFibGVDZWxsUHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBiYWNrZ3JvdW5kQ29sb3I6IHZpcnR1YWxSb3cgPyBiYXNlQmFja2dyb3VuZENvbG9yIDogdW5kZWZpbmVkLCBib3JkZXJCb3R0b206ICFyb3cuZ2V0SXNFeHBhbmRlZCgpID8gJ25vbmUnIDogdW5kZWZpbmVkLCBkaXNwbGF5OiAobGF5b3V0TW9kZSA9PT0gbnVsbCB8fCBsYXlvdXRNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRNb2RlLnN0YXJ0c1dpdGgoJ2dyaWQnKSkgPyAnZmxleCcgOiB1bmRlZmluZWQsIHB5OiAhIURldGFpbFBhbmVsICYmIHJvdy5nZXRJc0V4cGFuZGVkKCkgPyAnMXJlbScgOiAwLCB0cmFuc2l0aW9uOiAhdmlydHVhbFJvdyA/ICdhbGwgMTUwbXMgZWFzZS1pbi1vdXQnIDogdW5kZWZpbmVkLCB3aWR0aDogYDEwMCVgIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMuc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogdmlydHVhbFJvdyA/IChyb3cuZ2V0SXNFeHBhbmRlZCgpICYmIERldGFpbFBhbmVsKSA6IChqc3goQ29sbGFwc2UsIHsgaW46IHJvdy5nZXRJc0V4cGFuZGVkKCksIG1vdW50T25FbnRlcjogdHJ1ZSwgdW5tb3VudE9uRXhpdDogdHJ1ZSwgY2hpbGRyZW46IERldGFpbFBhbmVsIH0pKSB9KSkgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUJvZHlSb3cgPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jLCBfZCwgX2Y7XG4gICAgdmFyIHsgY29sdW1uVmlydHVhbGl6ZXIsIG51bVJvd3MsIHBpbm5lZFJvd0lkcywgcm93LCByb3dWaXJ0dWFsaXplciwgc3RhdGljUm93SW5kZXgsIHRhYmxlLCB2aXJ0dWFsUm93IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY29sdW1uVmlydHVhbGl6ZXJcIiwgXCJudW1Sb3dzXCIsIFwicGlubmVkUm93SWRzXCIsIFwicm93XCIsIFwicm93VmlydHVhbGl6ZXJcIiwgXCJzdGF0aWNSb3dJbmRleFwiLCBcInRhYmxlXCIsIFwidmlydHVhbFJvd1wiXSk7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlUm93T3JkZXJpbmcsIGVuYWJsZVJvd1Bpbm5pbmcsIGVuYWJsZVN0aWNreUZvb3RlciwgZW5hYmxlU3RpY2t5SGVhZGVyLCBsYXlvdXRNb2RlLCBtZW1vTW9kZSwgbXJ0VGhlbWU6IHsgYmFzZUJhY2tncm91bmRDb2xvciwgcGlubmVkUm93QmFja2dyb3VuZENvbG9yLCBzZWxlY3RlZFJvd0JhY2tncm91bmRDb2xvciwgfSwgbXVpVGFibGVCb2R5Um93UHJvcHMsIHJlbmRlckRldGFpbFBhbmVsLCByb3dQaW5uaW5nRGlzcGxheU1vZGUsIH0sIHJlZnM6IHsgdGFibGVGb290ZXJSZWYsIHRhYmxlSGVhZFJlZiB9LCBzZXRIb3ZlcmVkUm93LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5LCBkcmFnZ2luZ0NvbHVtbiwgZHJhZ2dpbmdSb3csIGVkaXRpbmdDZWxsLCBlZGl0aW5nUm93LCBob3ZlcmVkUm93LCBpc0Z1bGxTY3JlZW4sIHJvd1Bpbm5pbmcsIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHZpc2libGVDZWxscyA9IHJvdy5nZXRWaXNpYmxlQ2VsbHMoKTtcbiAgICBjb25zdCB7IHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQgfSA9IGNvbHVtblZpcnR1YWxpemVyICE9PSBudWxsICYmIGNvbHVtblZpcnR1YWxpemVyICE9PSB2b2lkIDAgPyBjb2x1bW5WaXJ0dWFsaXplciA6IHt9O1xuICAgIGNvbnN0IGlzUm93U2VsZWN0ZWQgPSBnZXRJc1Jvd1NlbGVjdGVkKHsgcm93LCB0YWJsZSB9KTtcbiAgICBjb25zdCBpc1Jvd1Bpbm5lZCA9IGVuYWJsZVJvd1Bpbm5pbmcgJiYgcm93LmdldElzUGlubmVkKCk7XG4gICAgY29uc3QgaXNEcmFnZ2luZ1JvdyA9IChkcmFnZ2luZ1JvdyA9PT0gbnVsbCB8fCBkcmFnZ2luZ1JvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ2dpbmdSb3cuaWQpID09PSByb3cuaWQ7XG4gICAgY29uc3QgaXNIb3ZlcmVkUm93ID0gKGhvdmVyZWRSb3cgPT09IG51bGwgfHwgaG92ZXJlZFJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJlZFJvdy5pZCkgPT09IHJvdy5pZDtcbiAgICBjb25zdCB0YWJsZVJvd1Byb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpVGFibGVCb2R5Um93UHJvcHMsIHtcbiAgICAgICAgcm93LFxuICAgICAgICBzdGF0aWNSb3dJbmRleCxcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICBjb25zdCBbYm90dG9tUGlubmVkSW5kZXgsIHRvcFBpbm5lZEluZGV4XSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWVuYWJsZVJvd1Bpbm5pbmcgfHxcbiAgICAgICAgICAgICEocm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSBudWxsIHx8IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93UGlubmluZ0Rpc3BsYXlNb2RlLmluY2x1ZGVzKCdzdGlja3knKSkgfHxcbiAgICAgICAgICAgICFwaW5uZWRSb3dJZHMgfHxcbiAgICAgICAgICAgICFyb3cuZ2V0SXNQaW5uZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFsuLi5waW5uZWRSb3dJZHNdLnJldmVyc2UoKS5pbmRleE9mKHJvdy5pZCksXG4gICAgICAgICAgICBwaW5uZWRSb3dJZHMuaW5kZXhPZihyb3cuaWQpLFxuICAgICAgICBdO1xuICAgIH0sIFtwaW5uZWRSb3dJZHMsIHJvd1Bpbm5pbmddKTtcbiAgICBjb25zdCB0YWJsZUhlYWRIZWlnaHQgPSAoKGVuYWJsZVN0aWNreUhlYWRlciB8fCBpc0Z1bGxTY3JlZW4pICYmXG4gICAgICAgICgoX2IgPSB0YWJsZUhlYWRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsaWVudEhlaWdodCkpIHx8XG4gICAgICAgIDA7XG4gICAgY29uc3QgdGFibGVGb290ZXJIZWlnaHQgPSAoZW5hYmxlU3RpY2t5Rm9vdGVyICYmICgoX2MgPSB0YWJsZUZvb3RlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2xpZW50SGVpZ2h0KSkgfHwgMDtcbiAgICBjb25zdCBzeCA9IHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuc3gsIHRoZW1lKTtcbiAgICBjb25zdCBkZWZhdWx0Um93SGVpZ2h0ID0gZGVuc2l0eSA9PT0gJ2NvbXBhY3QnID8gMzcgOiBkZW5zaXR5ID09PSAnY29tZm9ydGFibGUnID8gNTMgOiA2OTtcbiAgICBjb25zdCBjdXN0b21Sb3dIZWlnaHQgPSBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcGFyc2VJbnQoKF9mID0gKF9kID0gdGFibGVSb3dQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVJvd1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd1Byb3BzLnN0eWxlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBzeCA9PT0gbnVsbCB8fCBzeCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3guaGVpZ2h0LCAxMCkgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJvd0hlaWdodCA9IGN1c3RvbVJvd0hlaWdodCB8fCBkZWZhdWx0Um93SGVpZ2h0O1xuICAgIGNvbnN0IGhhbmRsZURyYWdFbnRlciA9IChfZSkgPT4ge1xuICAgICAgICBpZiAoZW5hYmxlUm93T3JkZXJpbmcgJiYgZHJhZ2dpbmdSb3cpIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRSb3cocm93KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBjb25zdCByb3dSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY2VsbEhpZ2hsaWdodENvbG9yID0gaXNSb3dTZWxlY3RlZFxuICAgICAgICA/IHNlbGVjdGVkUm93QmFja2dyb3VuZENvbG9yXG4gICAgICAgIDogaXNSb3dQaW5uZWRcbiAgICAgICAgICAgID8gcGlubmVkUm93QmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjZWxsSGlnaGxpZ2h0Q29sb3JIb3ZlciA9ICh0YWJsZVJvd1Byb3BzID09PSBudWxsIHx8IHRhYmxlUm93UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUm93UHJvcHMuaG92ZXIpICE9PSBmYWxzZVxuICAgICAgICA/IGlzUm93U2VsZWN0ZWRcbiAgICAgICAgICAgID8gY2VsbEhpZ2hsaWdodENvbG9yXG4gICAgICAgICAgICA6IHRoZW1lLnBhbGV0dGUubW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgPyBgJHtsaWdodGVuKGJhc2VCYWNrZ3JvdW5kQ29sb3IsIDAuMyl9YFxuICAgICAgICAgICAgICAgIDogYCR7ZGFya2VuKGJhc2VCYWNrZ3JvdW5kQ29sb3IsIDAuMyl9YFxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3hzKFRhYmxlUm93LCBPYmplY3QuYXNzaWduKHsgXCJkYXRhLWluZGV4XCI6IHJlbmRlckRldGFpbFBhbmVsID8gc3RhdGljUm93SW5kZXggKiAyIDogc3RhdGljUm93SW5kZXgsIFwiZGF0YS1waW5uZWRcIjogISFpc1Jvd1Bpbm5lZCB8fCB1bmRlZmluZWQsIFwiZGF0YS1zZWxlY3RlZFwiOiBpc1Jvd1NlbGVjdGVkIHx8IHVuZGVmaW5lZCwgb25EcmFnRW50ZXI6IGhhbmRsZURyYWdFbnRlciwgb25EcmFnT3ZlcjogaGFuZGxlRHJhZ092ZXIsIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1ZpcnR1YWxpemVyID09PSBudWxsIHx8IHJvd1ZpcnR1YWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dWaXJ0dWFsaXplci5tZWFzdXJlRWxlbWVudChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHNlbGVjdGVkOiBpc1Jvd1NlbGVjdGVkIH0sIHRhYmxlUm93UHJvcHMsIHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oeyB0cmFuc2Zvcm06IHZpcnR1YWxSb3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHRyYW5zbGF0ZVkoJHt2aXJ0dWFsUm93LnN0YXJ0fXB4KWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIHRhYmxlUm93UHJvcHMgPT09IG51bGwgfHwgdGFibGVSb3dQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVSb3dQcm9wcy5zdHlsZSksIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgJyY6aG92ZXIgdGQ6YWZ0ZXInOiBjZWxsSGlnaGxpZ2h0Q29sb3JIb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiBhbHBoYShjZWxsSGlnaGxpZ2h0Q29sb3JIb3ZlciwgMC4zKSB9LCBjb21tb25DZWxsQmVmb3JlQWZ0ZXJTdHlsZXMpIDogdW5kZWZpbmVkLCBiYWNrZ3JvdW5kQ29sb3I6IGAke2Jhc2VCYWNrZ3JvdW5kQ29sb3J9ICFpbXBvcnRhbnRgLCBib3R0b206ICF2aXJ0dWFsUm93ICYmIGJvdHRvbVBpbm5lZEluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNSb3dQaW5uZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7Ym90dG9tUGlubmVkSW5kZXggKiByb3dIZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmFibGVTdGlja3lGb290ZXIgPyB0YWJsZUZvb3RlckhlaWdodCAtIDEgOiAwKX1weGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBib3hTaXppbmc6ICdib3JkZXItYm94JywgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2ZsZXgnIDogdW5kZWZpbmVkLCBvcGFjaXR5OiBpc1Jvd1Bpbm5lZCA/IDAuOTcgOiBpc0RyYWdnaW5nUm93IHx8IGlzSG92ZXJlZFJvdyA/IDAuNSA6IDEsIHBvc2l0aW9uOiB2aXJ0dWFsUm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gbnVsbCB8fCByb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZS5pbmNsdWRlcygnc3RpY2t5JykpICYmIGlzUm93UGlubmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3RpY2t5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3JlbGF0aXZlJywgdGQ6IE9iamVjdC5hc3NpZ24oe30sIGdldENvbW1vblBpbm5lZENlbGxTdHlsZXMoeyB0YWJsZSwgdGhlbWUgfSkpLCAndGQ6YWZ0ZXInOiBjZWxsSGlnaGxpZ2h0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7IGJhY2tncm91bmRDb2xvcjogY2VsbEhpZ2hsaWdodENvbG9yIH0sIGNvbW1vbkNlbGxCZWZvcmVBZnRlclN0eWxlcykgOiB1bmRlZmluZWQsIHRvcDogdmlydHVhbFJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRvcFBpbm5lZEluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNSb3dQaW5uZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAke3RvcFBpbm5lZEluZGV4ICogcm93SGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuYWJsZVN0aWNreUhlYWRlciB8fCBpc0Z1bGxTY3JlZW4gPyB0YWJsZUhlYWRIZWlnaHQgLSAxIDogMCl9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIHRyYW5zaXRpb246IHZpcnR1YWxSb3cgPyAnbm9uZScgOiAnYWxsIDE1MG1zIGVhc2UtaW4tb3V0Jywgd2lkdGg6ICcxMDAlJywgekluZGV4OiAocm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSBudWxsIHx8IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93UGlubmluZ0Rpc3BsYXlNb2RlLmluY2x1ZGVzKCdzdGlja3knKSkgJiYgaXNSb3dQaW5uZWQgPyAyIDogMCB9LCBzeCkpLCBjaGlsZHJlbjogW3ZpcnR1YWxQYWRkaW5nTGVmdCA/IChqc3goXCJ0ZFwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6ICdmbGV4Jywgd2lkdGg6IHZpcnR1YWxQYWRkaW5nTGVmdCB9IH0pKSA6IG51bGwsICh2aXJ0dWFsQ29sdW1ucyAhPT0gbnVsbCAmJiB2aXJ0dWFsQ29sdW1ucyAhPT0gdm9pZCAwID8gdmlydHVhbENvbHVtbnMgOiB2aXNpYmxlQ2VsbHMpLm1hcCgoY2VsbE9yVmlydHVhbENlbGwsIHN0YXRpY0NvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IGNlbGxPclZpcnR1YWxDZWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtblZpcnR1YWxpemVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ29sdW1uSW5kZXggPSBjZWxsT3JWaXJ0dWFsQ2VsbC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gdmlzaWJsZUNlbGxzW3N0YXRpY0NvbHVtbkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtUm93cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljUm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7Y2VsbC5pZH0tJHtzdGF0aWNSb3dJbmRleH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwgPyAobWVtb01vZGUgPT09ICdjZWxscycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbHVtbi5jb2x1bW5EZWYuY29sdW1uRGVmVHlwZSA9PT0gJ2RhdGEnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWRyYWdnaW5nQ29sdW1uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWRyYWdnaW5nUm93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkaXRpbmdDZWxsID09PSBudWxsIHx8IGVkaXRpbmdDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0aW5nQ2VsbC5pZCkgIT09IGNlbGwuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZWRpdGluZ1JvdyA9PT0gbnVsbCB8fCBlZGl0aW5nUm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0aW5nUm93LmlkKSAhPT0gcm93LmlkID8gKGpzeChNZW1vX01SVF9UYWJsZUJvZHlDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIGtleSkpIDogKGpzeChNUlRfVGFibGVCb2R5Q2VsbCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCBrZXkpKSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KSwgdmlydHVhbFBhZGRpbmdSaWdodCA/IChqc3goXCJ0ZFwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6ICdmbGV4Jywgd2lkdGg6IHZpcnR1YWxQYWRkaW5nUmlnaHQgfSB9KSkgOiBudWxsXSB9KSksIHJlbmRlckRldGFpbFBhbmVsICYmICFyb3cuZ2V0SXNHcm91cGVkKCkgJiYgKGpzeChNUlRfVGFibGVEZXRhaWxQYW5lbCwgeyBwYXJlbnRSb3dSZWY6IHJvd1JlZiwgcm93OiByb3csIHJvd1ZpcnR1YWxpemVyOiByb3dWaXJ0dWFsaXplciwgc3RhdGljUm93SW5kZXg6IHN0YXRpY1Jvd0luZGV4LCB0YWJsZTogdGFibGUsIHZpcnR1YWxSb3c6IHZpcnR1YWxSb3cgfSkpXSB9KSk7XG59O1xuY29uc3QgTWVtb19NUlRfVGFibGVCb2R5Um93ID0gbWVtbyhNUlRfVGFibGVCb2R5Um93LCAocHJldiwgbmV4dCkgPT4gcHJldi5yb3cgPT09IG5leHQucm93ICYmIHByZXYuc3RhdGljUm93SW5kZXggPT09IG5leHQuc3RhdGljUm93SW5kZXgpO1xuXG5jb25zdCBNUlRfVGFibGVCb2R5ID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgdmFyIHsgY29sdW1uVmlydHVhbGl6ZXIsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY29sdW1uVmlydHVhbGl6ZXJcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRCb3R0b21Sb3dzLCBnZXRJc1NvbWVSb3dzUGlubmVkLCBnZXRSb3dNb2RlbCwgZ2V0U3RhdGUsIGdldFRvcFJvd3MsIG9wdGlvbnM6IHsgZW5hYmxlU3RpY2t5Rm9vdGVyLCBlbmFibGVTdGlja3lIZWFkZXIsIGxheW91dE1vZGUsIGxvY2FsaXphdGlvbiwgbWVtb01vZGUsIG11aVRhYmxlQm9keVByb3BzLCByZW5kZXJEZXRhaWxQYW5lbCwgcmVuZGVyRW1wdHlSb3dzRmFsbGJhY2ssIHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSwgfSwgcmVmczogeyB0YWJsZUZvb3RlclJlZiwgdGFibGVIZWFkUmVmLCB0YWJsZVBhcGVyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlciwgaXNGdWxsU2NyZWVuLCByb3dQaW5uaW5nIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRhYmxlQm9keVByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpVGFibGVCb2R5UHJvcHMsIHsgdGFibGUgfSkpLCByZXN0KTtcbiAgICBjb25zdCB0YWJsZUhlYWRIZWlnaHQgPSAoKGVuYWJsZVN0aWNreUhlYWRlciB8fCBpc0Z1bGxTY3JlZW4pICYmXG4gICAgICAgICgoX2IgPSB0YWJsZUhlYWRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsaWVudEhlaWdodCkpIHx8XG4gICAgICAgIDA7XG4gICAgY29uc3QgdGFibGVGb290ZXJIZWlnaHQgPSAoZW5hYmxlU3RpY2t5Rm9vdGVyICYmICgoX2MgPSB0YWJsZUZvb3RlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2xpZW50SGVpZ2h0KSkgfHwgMDtcbiAgICBjb25zdCBwaW5uZWRSb3dJZHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCEoKF9hID0gcm93UGlubmluZy5ib3R0b20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmICEoKF9iID0gcm93UGlubmluZy50b3ApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gZ2V0Um93TW9kZWwoKVxuICAgICAgICAgICAgLnJvd3MuZmlsdGVyKChyb3cpID0+IHJvdy5nZXRJc1Bpbm5lZCgpKVxuICAgICAgICAgICAgLm1hcCgocikgPT4gci5pZCk7XG4gICAgfSwgW3Jvd1Bpbm5pbmcsIGdldFJvd01vZGVsKCkucm93c10pO1xuICAgIGNvbnN0IHJvd3MgPSB1c2VNUlRfUm93cyh0YWJsZSk7XG4gICAgY29uc3Qgcm93VmlydHVhbGl6ZXIgPSB1c2VNUlRfUm93VmlydHVhbGl6ZXIodGFibGUsIHJvd3MpO1xuICAgIGNvbnN0IHsgdmlydHVhbFJvd3MgfSA9IHJvd1ZpcnR1YWxpemVyICE9PSBudWxsICYmIHJvd1ZpcnR1YWxpemVyICE9PSB2b2lkIDAgPyByb3dWaXJ0dWFsaXplciA6IHt9O1xuICAgIGNvbnN0IGNvbW1vblJvd1Byb3BzID0ge1xuICAgICAgICBjb2x1bW5WaXJ0dWFsaXplcixcbiAgICAgICAgbnVtUm93czogcm93cy5sZW5ndGgsXG4gICAgICAgIHRhYmxlLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbIShyb3dQaW5uaW5nRGlzcGxheU1vZGUgPT09IG51bGwgfHwgcm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dQaW5uaW5nRGlzcGxheU1vZGUuaW5jbHVkZXMoJ3N0aWNreScpKSAmJlxuICAgICAgICAgICAgICAgIGdldElzU29tZVJvd3NQaW5uZWQoJ3RvcCcpICYmIChqc3goVGFibGVCb2R5LCBPYmplY3QuYXNzaWduKHt9LCB0YWJsZUJvZHlQcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6IChsYXlvdXRNb2RlID09PSBudWxsIHx8IGxheW91dE1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dE1vZGUuc3RhcnRzV2l0aCgnZ3JpZCcpKSA/ICdncmlkJyA6IHVuZGVmaW5lZCwgcG9zaXRpb246ICdzdGlja3knLCB0b3A6IHRhYmxlSGVhZEhlaWdodCAtIDEsIHpJbmRleDogMSB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVCb2R5UHJvcHMgPT09IG51bGwgfHwgdGFibGVCb2R5UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQm9keVByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IGdldFRvcFJvd3MoKS5tYXAoKHJvdywgc3RhdGljUm93SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblJvd1Byb3BzKSwgeyByb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNSb3dJbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9Nb2RlID09PSAncm93cycgPyAoanN4KE1lbW9fTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCByb3cuaWQpKSA6IChqc3goTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCByb3cuaWQpKTtcbiAgICAgICAgICAgICAgICB9KSB9KSkpLCBqc3goVGFibGVCb2R5LCBPYmplY3QuYXNzaWduKHt9LCB0YWJsZUJvZHlQcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6IChsYXlvdXRNb2RlID09PSBudWxsIHx8IGxheW91dE1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dE1vZGUuc3RhcnRzV2l0aCgnZ3JpZCcpKSA/ICdncmlkJyA6IHVuZGVmaW5lZCwgaGVpZ2h0OiByb3dWaXJ0dWFsaXplclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtyb3dWaXJ0dWFsaXplci5nZXRUb3RhbFNpemUoKX1weGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBtaW5IZWlnaHQ6ICFyb3dzLmxlbmd0aCA/ICcxMDBweCcgOiB1bmRlZmluZWQsIHBvc2l0aW9uOiAncmVsYXRpdmUnIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0YWJsZUJvZHlQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUJvZHlQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVCb2R5UHJvcHMuc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogKF9kID0gdGFibGVCb2R5UHJvcHMgPT09IG51bGwgfHwgdGFibGVCb2R5UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQm9keVByb3BzLmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAoIXJvd3MubGVuZ3RoID8gKGpzeChcInRyXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IChsYXlvdXRNb2RlID09PSBudWxsIHx8IGxheW91dE1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dE1vZGUuc3RhcnRzV2l0aCgnZ3JpZCcpKSA/ICdncmlkJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGpzeChcInRkXCIsIHsgY29sU3BhbjogdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkubGVuZ3RoLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IChsYXlvdXRNb2RlID09PSBudWxsIHx8IGxheW91dE1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dE1vZGUuc3RhcnRzV2l0aCgnZ3JpZCcpKSA/ICdncmlkJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiAoX2UgPSByZW5kZXJFbXB0eVJvd3NGYWxsYmFjayA9PT0gbnVsbCB8fCByZW5kZXJFbXB0eVJvd3NGYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyRW1wdHlSb3dzRmFsbGJhY2soeyB0YWJsZSB9KSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKGpzeChUeXBvZ3JhcGh5LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5zZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U3R5bGU6ICdpdGFsaWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogYG1pbigxMDB2dywgJHsoX2cgPSAoX2YgPSB0YWJsZVBhcGVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jbGllbnRXaWR0aCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMzYwfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5OiAnMnJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGdsb2JhbEZpbHRlciB8fCBjb2x1bW5GaWx0ZXJzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5ub1Jlc3VsdHNGb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvY2FsaXphdGlvbi5ub1JlY29yZHNUb0Rpc3BsYXkgfSkpIH0pIH0pKSA6IChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46ICh2aXJ0dWFsUm93cyAhPT0gbnVsbCAmJiB2aXJ0dWFsUm93cyAhPT0gdm9pZCAwID8gdmlydHVhbFJvd3MgOiByb3dzKS5tYXAoKHJvd09yVmlydHVhbFJvdywgc3RhdGljUm93SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByb3cgPSByb3dPclZpcnR1YWxSb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93VmlydHVhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyRGV0YWlsUGFuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd09yVmlydHVhbFJvdy5pbmRleCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljUm93SW5kZXggPSByb3dPclZpcnR1YWxSb3cuaW5kZXggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNSb3dJbmRleCA9IHJvd09yVmlydHVhbFJvdy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93c1tzdGF0aWNSb3dJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uUm93UHJvcHMpLCB7IHBpbm5lZFJvd0lkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93VmlydHVhbGl6ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljUm93SW5kZXgsIHZpcnR1YWxSb3c6IHJvd1ZpcnR1YWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcm93T3JWaXJ0dWFsUm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7cm93LmlkfS0ke3Jvdy5pbmRleH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9Nb2RlID09PSAncm93cycgPyAoanN4KE1lbW9fTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCBrZXkpKSA6IChqc3goTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfSkpKSB9KSksICEocm93UGlubmluZ0Rpc3BsYXlNb2RlID09PSBudWxsIHx8IHJvd1Bpbm5pbmdEaXNwbGF5TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93UGlubmluZ0Rpc3BsYXlNb2RlLmluY2x1ZGVzKCdzdGlja3knKSkgJiZcbiAgICAgICAgICAgICAgICBnZXRJc1NvbWVSb3dzUGlubmVkKCdib3R0b20nKSAmJiAoanN4KFRhYmxlQm9keSwgT2JqZWN0LmFzc2lnbih7fSwgdGFibGVCb2R5UHJvcHMsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBib3R0b206IHRhYmxlRm9vdGVySGVpZ2h0IC0gMSwgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2dyaWQnIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogJ3N0aWNreScsIHpJbmRleDogMSB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVCb2R5UHJvcHMgPT09IG51bGwgfHwgdGFibGVCb2R5UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQm9keVByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IGdldEJvdHRvbVJvd3MoKS5tYXAoKHJvdywgc3RhdGljUm93SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblJvd1Byb3BzKSwgeyByb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNSb3dJbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9Nb2RlID09PSAncm93cycgPyAoanN4KE1lbW9fTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCByb3cuaWQpKSA6IChqc3goTVJUX1RhYmxlQm9keVJvdywgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCByb3cuaWQpKTtcbiAgICAgICAgICAgICAgICB9KSB9KSkpXSB9KSk7XG59O1xuY29uc3QgTWVtb19NUlRfVGFibGVCb2R5ID0gbWVtbyhNUlRfVGFibGVCb2R5LCAocHJldiwgbmV4dCkgPT4gcHJldi50YWJsZS5vcHRpb25zLmRhdGEgPT09IG5leHQudGFibGUub3B0aW9ucy5kYXRhKTtcblxuY29uc3QgTVJUX1RhYmxlRm9vdGVyQ2VsbCA9IChfYSkgPT4ge1xuICAgIHZhciBfYiwgX2MsIF9kO1xuICAgIHZhciB7IGZvb3Rlciwgc3RhdGljQ29sdW1uSW5kZXgsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZm9vdGVyXCIsIFwic3RhdGljQ29sdW1uSW5kZXhcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlQ29sdW1uUGlubmluZywgbXVpVGFibGVGb290ZXJDZWxsUHJvcHMsIGVuYWJsZUtleWJvYXJkU2hvcnRjdXRzLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5IH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBmb290ZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZlR5cGUgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBpc0NvbHVtblBpbm5lZCA9IGVuYWJsZUNvbHVtblBpbm5pbmcgJiZcbiAgICAgICAgY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgIT09ICdncm91cCcgJiZcbiAgICAgICAgY29sdW1uLmdldElzUGlubmVkKCk7XG4gICAgY29uc3QgYXJncyA9IHsgY29sdW1uLCB0YWJsZSB9O1xuICAgIGNvbnN0IHRhYmxlQ2VsbFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlUYWJsZUZvb3RlckNlbGxQcm9wcywgYXJncykpLCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLm11aVRhYmxlRm9vdGVyQ2VsbFByb3BzLCBhcmdzKSksIHJlc3QpO1xuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMub25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YWJsZUNlbGxQcm9wcywgZXZlbnQpO1xuICAgICAgICBjZWxsS2V5Ym9hcmRTaG9ydGN1dHMoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBjZWxsVmFsdWU6IGZvb3Rlci5jb2x1bW4uY29sdW1uRGVmLmZvb3RlcixcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFRhYmxlQ2VsbCwgT2JqZWN0LmFzc2lnbih7IGFsaWduOiBjb2x1bW5EZWZUeXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/ICdjZW50ZXInXG4gICAgICAgICAgICA6IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgICAgICAgICAgICAgICA/ICdyaWdodCdcbiAgICAgICAgICAgICAgICA6ICdsZWZ0JywgY29sU3BhbjogZm9vdGVyLmNvbFNwYW4sIFwiZGF0YS1pbmRleFwiOiBzdGF0aWNDb2x1bW5JbmRleCwgXCJkYXRhLXBpbm5lZFwiOiAhIWlzQ29sdW1uUGlubmVkIHx8IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGVuYWJsZUtleWJvYXJkU2hvcnRjdXRzID8gMCA6IHVuZGVmaW5lZCwgdmFyaWFudDogXCJmb290ZXJcIiB9LCB0YWJsZUNlbGxQcm9wcywgeyBvbktleURvd246IGhhbmRsZUtleURvd24sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBmb250V2VpZ2h0OiAnYm9sZCcsIHA6IGRlbnNpdHkgPT09ICdjb21wYWN0J1xuICAgICAgICAgICAgICAgID8gJzAuNXJlbSdcbiAgICAgICAgICAgICAgICA6IGRlbnNpdHkgPT09ICdjb21mb3J0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgPyAnMXJlbSdcbiAgICAgICAgICAgICAgICAgICAgOiAnMS41cmVtJywgdmVydGljYWxBbGlnbjogJ3RvcCcgfSwgZ2V0Q29tbW9uTVJUQ2VsbFN0eWxlcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBoZWFkZXI6IGZvb3RlcixcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgdGFibGVDZWxsUHJvcHMsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgfSkpLCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IChfYiA9IHRhYmxlQ2VsbFByb3BzLmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoZm9vdGVyLmlzUGxhY2Vob2xkZXJcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiAoKF9kID0gKF9jID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNvbHVtbkRlZi5Gb290ZXIsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgZm9vdGVyLFxuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgfSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbHVtbkRlZi5mb290ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwpKSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlRm9vdGVyUm93ID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IGNvbHVtblZpcnR1YWxpemVyLCBmb290ZXJHcm91cCwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjb2x1bW5WaXJ0dWFsaXplclwiLCBcImZvb3Rlckdyb3VwXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBsYXlvdXRNb2RlLCBtcnRUaGVtZTogeyBiYXNlQmFja2dyb3VuZENvbG9yIH0sIG11aVRhYmxlRm9vdGVyUm93UHJvcHMsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IHZpcnR1YWxDb2x1bW5zLCB2aXJ0dWFsUGFkZGluZ0xlZnQsIHZpcnR1YWxQYWRkaW5nUmlnaHQgfSA9IGNvbHVtblZpcnR1YWxpemVyICE9PSBudWxsICYmIGNvbHVtblZpcnR1YWxpemVyICE9PSB2b2lkIDAgPyBjb2x1bW5WaXJ0dWFsaXplciA6IHt9O1xuICAgIC8vIGlmIG5vIGNvbnRlbnQgaW4gcm93LCBza2lwIHJvd1xuICAgIGlmICghKChfYiA9IGZvb3Rlckdyb3VwLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb21lKChoZWFkZXIpID0+ICh0eXBlb2YgaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWYuZm9vdGVyID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAhIWhlYWRlci5jb2x1bW4uY29sdW1uRGVmLmZvb3RlcikgfHxcbiAgICAgICAgaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWYuRm9vdGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlUm93UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlUYWJsZUZvb3RlclJvd1Byb3BzLCB7XG4gICAgICAgIGZvb3Rlckdyb3VwLFxuICAgICAgICB0YWJsZSxcbiAgICB9KSksIHJlc3QpO1xuICAgIHJldHVybiAoanN4cyhUYWJsZVJvdywgT2JqZWN0LmFzc2lnbih7fSwgdGFibGVSb3dQcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGJhY2tncm91bmRDb2xvcjogYmFzZUJhY2tncm91bmRDb2xvciwgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2ZsZXgnIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgd2lkdGg6ICcxMDAlJyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVSb3dQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVJvd1Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd1Byb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IFt2aXJ0dWFsUGFkZGluZ0xlZnQgPyAoanN4KFwidGhcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiAnZmxleCcsIHdpZHRoOiB2aXJ0dWFsUGFkZGluZ0xlZnQgfSB9KSkgOiBudWxsLCAodmlydHVhbENvbHVtbnMgIT09IG51bGwgJiYgdmlydHVhbENvbHVtbnMgIT09IHZvaWQgMCA/IHZpcnR1YWxDb2x1bW5zIDogZm9vdGVyR3JvdXAuaGVhZGVycykubWFwKChmb290ZXJPclZpcnR1YWxGb290ZXIsIHN0YXRpY0NvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvb3RlciA9IGZvb3Rlck9yVmlydHVhbEZvb3RlcjtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uVmlydHVhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ29sdW1uSW5kZXggPSBmb290ZXJPclZpcnR1YWxGb290ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZm9vdGVyID0gZm9vdGVyR3JvdXAuaGVhZGVyc1tzdGF0aWNDb2x1bW5JbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb290ZXIgPyAoanN4KE1SVF9UYWJsZUZvb3RlckNlbGwsIHsgZm9vdGVyOiBmb290ZXIsIHN0YXRpY0NvbHVtbkluZGV4OiBzdGF0aWNDb2x1bW5JbmRleCwgdGFibGU6IHRhYmxlIH0sIGZvb3Rlci5pZCkpIDogbnVsbDtcbiAgICAgICAgICAgIH0pLCB2aXJ0dWFsUGFkZGluZ1JpZ2h0ID8gKGpzeChcInRoXCIsIHsgc3R5bGU6IHsgZGlzcGxheTogJ2ZsZXgnLCB3aWR0aDogdmlydHVhbFBhZGRpbmdSaWdodCB9IH0pKSA6IG51bGxdIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVGb290ZXIgPSAoX2EpID0+IHtcbiAgICB2YXIgeyBjb2x1bW5WaXJ0dWFsaXplciwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjb2x1bW5WaXJ0dWFsaXplclwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVN0aWNreUZvb3RlciwgbGF5b3V0TW9kZSwgbXVpVGFibGVGb290ZXJQcm9wcyB9LCByZWZzOiB7IHRhYmxlRm9vdGVyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZUZvb3RlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpVGFibGVGb290ZXJQcm9wcywge1xuICAgICAgICB0YWJsZSxcbiAgICB9KSksIHJlc3QpO1xuICAgIGNvbnN0IHN0aWNrRm9vdGVyID0gKGlzRnVsbFNjcmVlbiB8fCBlbmFibGVTdGlja3lGb290ZXIpICYmIGVuYWJsZVN0aWNreUZvb3RlciAhPT0gZmFsc2U7XG4gICAgY29uc3QgZm9vdGVyR3JvdXBzID0gdGFibGUuZ2V0Rm9vdGVyR3JvdXBzKCk7XG4gICAgLy9pZiBubyBmb290ZXIgY2VsbHMgYXQgYWxsLCBza2lwIGZvb3RlclxuICAgIGlmICghZm9vdGVyR3JvdXBzLnNvbWUoKGZvb3Rlckdyb3VwKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IGZvb3Rlckdyb3VwLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChoZWFkZXIpID0+ICh0eXBlb2YgaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWYuZm9vdGVyID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgISFoZWFkZXIuY29sdW1uLmNvbHVtbkRlZi5mb290ZXIpIHx8XG4gICAgICAgICAgICBoZWFkZXIuY29sdW1uLmNvbHVtbkRlZi5Gb290ZXIpO1xuICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChUYWJsZUZvb3RlciwgT2JqZWN0LmFzc2lnbih7fSwgdGFibGVGb290ZXJQcm9wcywgeyByZWY6IChyZWYpID0+IHtcbiAgICAgICAgICAgIHRhYmxlRm9vdGVyUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICBpZiAodGFibGVGb290ZXJQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUZvb3RlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUZvb3RlclByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB0YWJsZUZvb3RlclByb3BzLnJlZi5jdXJyZW50ID0gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGJvdHRvbTogc3RpY2tGb290ZXIgPyAwIDogdW5kZWZpbmVkLCBkaXNwbGF5OiAobGF5b3V0TW9kZSA9PT0gbnVsbCB8fCBsYXlvdXRNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRNb2RlLnN0YXJ0c1dpdGgoJ2dyaWQnKSkgPyAnZ3JpZCcgOiB1bmRlZmluZWQsIG9wYWNpdHk6IHN0aWNrRm9vdGVyID8gMC45NyA6IHVuZGVmaW5lZCwgb3V0bGluZTogc3RpY2tGb290ZXJcbiAgICAgICAgICAgICAgICA/IHRoZW1lLnBhbGV0dGUubW9kZSA9PT0gJ2xpZ2h0J1xuICAgICAgICAgICAgICAgICAgICA/IGAxcHggc29saWQgJHt0aGVtZS5wYWxldHRlLmdyZXlbMzAwXX1gXG4gICAgICAgICAgICAgICAgICAgIDogYDFweCBzb2xpZCAke3RoZW1lLnBhbGV0dGUuZ3JleVs3MDBdfWBcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgcG9zaXRpb246IHN0aWNrRm9vdGVyID8gJ3N0aWNreScgOiAncmVsYXRpdmUnLCB6SW5kZXg6IHN0aWNrRm9vdGVyID8gMSA6IHVuZGVmaW5lZCB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVGb290ZXJQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUZvb3RlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUZvb3RlclByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IGZvb3Rlckdyb3Vwcy5tYXAoKGZvb3Rlckdyb3VwKSA9PiAoanN4KE1SVF9UYWJsZUZvb3RlclJvdywgeyBjb2x1bW5WaXJ0dWFsaXplcjogY29sdW1uVmlydHVhbGl6ZXIsIGZvb3Rlckdyb3VwOiBmb290ZXJHcm91cCwgdGFibGU6IHRhYmxlIH0sIGZvb3Rlckdyb3VwLmlkKSkpIH0pKSk7XG59O1xuXG5jb25zdCBtcnRGaWx0ZXJPcHRpb25zID0gKGxvY2FsaXphdGlvbikgPT4gW1xuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyRnV6enksXG4gICAgICAgIG9wdGlvbjogJ2Z1enp5JyxcbiAgICAgICAgc3ltYm9sOiAn4omIJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyQ29udGFpbnMsXG4gICAgICAgIG9wdGlvbjogJ2NvbnRhaW5zJyxcbiAgICAgICAgc3ltYm9sOiAnKicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGRpdmlkZXI6IGZhbHNlLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlclN0YXJ0c1dpdGgsXG4gICAgICAgIG9wdGlvbjogJ3N0YXJ0c1dpdGgnLFxuICAgICAgICBzeW1ib2w6ICdhJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogdHJ1ZSxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJFbmRzV2l0aCxcbiAgICAgICAgb3B0aW9uOiAnZW5kc1dpdGgnLFxuICAgICAgICBzeW1ib2w6ICd6JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyRXF1YWxzLFxuICAgICAgICBvcHRpb246ICdlcXVhbHMnLFxuICAgICAgICBzeW1ib2w6ICc9JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogdHJ1ZSxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJOb3RFcXVhbHMsXG4gICAgICAgIG9wdGlvbjogJ25vdEVxdWFscycsXG4gICAgICAgIHN5bWJvbDogJ+KJoCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGRpdmlkZXI6IGZhbHNlLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckJldHdlZW4sXG4gICAgICAgIG9wdGlvbjogJ2JldHdlZW4nLFxuICAgICAgICBzeW1ib2w6ICfih78nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBkaXZpZGVyOiB0cnVlLFxuICAgICAgICBsYWJlbDogbG9jYWxpemF0aW9uLmZpbHRlckJldHdlZW5JbmNsdXNpdmUsXG4gICAgICAgIG9wdGlvbjogJ2JldHdlZW5JbmNsdXNpdmUnLFxuICAgICAgICBzeW1ib2w6ICfirIwnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBkaXZpZGVyOiBmYWxzZSxcbiAgICAgICAgbGFiZWw6IGxvY2FsaXphdGlvbi5maWx0ZXJHcmVhdGVyVGhhbixcbiAgICAgICAgb3B0aW9uOiAnZ3JlYXRlclRoYW4nLFxuICAgICAgICBzeW1ib2w6ICc+JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyR3JlYXRlclRoYW5PckVxdWFsVG8sXG4gICAgICAgIG9wdGlvbjogJ2dyZWF0ZXJUaGFuT3JFcXVhbFRvJyxcbiAgICAgICAgc3ltYm9sOiAn4omlJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyTGVzc1RoYW4sXG4gICAgICAgIG9wdGlvbjogJ2xlc3NUaGFuJyxcbiAgICAgICAgc3ltYm9sOiAnPCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGRpdmlkZXI6IHRydWUsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyTGVzc1RoYW5PckVxdWFsVG8sXG4gICAgICAgIG9wdGlvbjogJ2xlc3NUaGFuT3JFcXVhbFRvJyxcbiAgICAgICAgc3ltYm9sOiAn4omkJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyRW1wdHksXG4gICAgICAgIG9wdGlvbjogJ2VtcHR5JyxcbiAgICAgICAgc3ltYm9sOiAn4oiFJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsb2NhbGl6YXRpb24uZmlsdGVyTm90RW1wdHksXG4gICAgICAgIG9wdGlvbjogJ25vdEVtcHR5JyxcbiAgICAgICAgc3ltYm9sOiAnIeKIhScsXG4gICAgfSxcbl07XG5jb25zdCByYW5nZU1vZGVzID0gWydiZXR3ZWVuJywgJ2JldHdlZW5JbmNsdXNpdmUnLCAnaW5OdW1iZXJSYW5nZSddO1xuY29uc3QgZW1wdHlNb2RlcyA9IFsnZW1wdHknLCAnbm90RW1wdHknXTtcbmNvbnN0IGFyck1vZGVzID0gWydhcnJJbmNsdWRlc1NvbWUnLCAnYXJySW5jbHVkZXNBbGwnLCAnYXJySW5jbHVkZXMnXTtcbmNvbnN0IHJhbmdlVmFyaWFudHMgPSBbJ3JhbmdlLXNsaWRlcicsICdkYXRlLXJhbmdlJywgJ2RhdGV0aW1lLXJhbmdlJywgJ3JhbmdlJ107XG5jb25zdCBNUlRfRmlsdGVyT3B0aW9uTWVudSA9IChfYSkgPT4ge1xuICAgIHZhciBfYiwgX2MsIF9kLCBfZTtcbiAgICB2YXIgeyBhbmNob3JFbCwgaGVhZGVyLCBvblNlbGVjdCwgc2V0QW5jaG9yRWwsIHNldEZpbHRlclZhbHVlLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImFuY2hvckVsXCIsIFwiaGVhZGVyXCIsIFwib25TZWxlY3RcIiwgXCJzZXRBbmNob3JFbFwiLCBcInNldEZpbHRlclZhbHVlXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyTW9kZU9wdGlvbnMsIGdsb2JhbEZpbHRlck1vZGVPcHRpb25zLCBsb2NhbGl6YXRpb24sIG1ydFRoZW1lOiB7IG1lbnVCYWNrZ3JvdW5kQ29sb3IgfSwgcmVuZGVyQ29sdW1uRmlsdGVyTW9kZU1lbnVJdGVtcywgcmVuZGVyR2xvYmFsRmlsdGVyTW9kZU1lbnVJdGVtcywgfSwgc2V0Q29sdW1uRmlsdGVyRm5zLCBzZXRHbG9iYWxGaWx0ZXJGbiwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZGVuc2l0eSwgZ2xvYmFsRmlsdGVyRm4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlciAhPT0gbnVsbCAmJiBoZWFkZXIgIT09IHZvaWQgMCA/IGhlYWRlciA6IHt9O1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW4gIT09IG51bGwgJiYgY29sdW1uICE9PSB2b2lkIDAgPyBjb2x1bW4gOiB7fTtcbiAgICBjb25zdCBjdXJyZW50RmlsdGVyVmFsdWUgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKTtcbiAgICBsZXQgYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPSAoX2IgPSBjb2x1bW5EZWYgPT09IG51bGwgfHwgY29sdW1uRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW5EZWYuY29sdW1uRmlsdGVyTW9kZU9wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbHVtbkZpbHRlck1vZGVPcHRpb25zO1xuICAgIGlmIChyYW5nZVZhcmlhbnRzLmluY2x1ZGVzKGNvbHVtbkRlZiA9PT0gbnVsbCB8fCBjb2x1bW5EZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbkRlZi5maWx0ZXJWYXJpYW50KSkge1xuICAgICAgICBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLnJhbmdlTW9kZXMsXG4gICAgICAgICAgICAuLi4oYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgIT09IG51bGwgJiYgYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgIT09IHZvaWQgMCA/IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zIDogW10pLFxuICAgICAgICBdLmZpbHRlcigob3B0aW9uKSA9PiByYW5nZU1vZGVzLmluY2x1ZGVzKG9wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbEZpbHRlck9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IG1ydEZpbHRlck9wdGlvbnMobG9jYWxpemF0aW9uKS5maWx0ZXIoKGZpbHRlck9wdGlvbikgPT4gY29sdW1uRGVmXG4gICAgICAgID8gYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSBudWxsIHx8IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucy5pbmNsdWRlcyhmaWx0ZXJPcHRpb24ub3B0aW9uKSlcbiAgICAgICAgOiAoIWdsb2JhbEZpbHRlck1vZGVPcHRpb25zIHx8XG4gICAgICAgICAgICBnbG9iYWxGaWx0ZXJNb2RlT3B0aW9ucy5pbmNsdWRlcyhmaWx0ZXJPcHRpb24ub3B0aW9uKSkgJiZcbiAgICAgICAgICAgIFsnY29udGFpbnMnLCAnZnV6enknLCAnc3RhcnRzV2l0aCddLmluY2x1ZGVzKGZpbHRlck9wdGlvbi5vcHRpb24pKSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZVNlbGVjdEZpbHRlck1vZGUgPSAob3B0aW9uKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHByZXZGaWx0ZXJNb2RlID0gKF9hID0gY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLl9maWx0ZXJGbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGlmICghaGVhZGVyIHx8ICFjb2x1bW4pIHtcbiAgICAgICAgICAgIC8vIGdsb2JhbCBmaWx0ZXIgbW9kZVxuICAgICAgICAgICAgc2V0R2xvYmFsRmlsdGVyRm4ob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb24gIT09IHByZXZGaWx0ZXJNb2RlKSB7XG4gICAgICAgICAgICAvLyBjb2x1bW4gZmlsdGVyIG1vZGVcbiAgICAgICAgICAgIHNldENvbHVtbkZpbHRlckZucygocHJldikgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIHsgW2hlYWRlci5pZF06IG9wdGlvbiB9KSkpO1xuICAgICAgICAgICAgLy8gcmVzZXQgZmlsdGVyIHZhbHVlIGFuZC9vciBwZXJmb3JtIG5ldyBmaWx0ZXIgcmVuZGVyXG4gICAgICAgICAgICBpZiAoZW1wdHlNb2Rlcy5pbmNsdWRlcyhvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBub3cgYmUgZW1wdHkvbm90RW1wdHkgZmlsdGVyIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpbHRlclZhbHVlICE9PSAnICcgJiZcbiAgICAgICAgICAgICAgICAgICAgIWVtcHR5TW9kZXMuaW5jbHVkZXMocHJldkZpbHRlck1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSgnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RmlsdGVyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKGN1cnJlbnRGaWx0ZXJWYWx1ZSk7IC8vIHBlcmZvcm0gbmV3IGZpbHRlciByZW5kZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoY29sdW1uRGVmID09PSBudWxsIHx8IGNvbHVtbkRlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uRGVmLmZpbHRlclZhcmlhbnQpID09PSAnbXVsdGktc2VsZWN0JyB8fFxuICAgICAgICAgICAgICAgIGFyck1vZGVzLmluY2x1ZGVzKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdyBiZSBhcnJheSBmaWx0ZXIgbW9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmlsdGVyVmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRGaWx0ZXJWYWx1ZSA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGaWx0ZXJWYWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZShbXSk7XG4gICAgICAgICAgICAgICAgICAgIHNldEZpbHRlclZhbHVlID09PSBudWxsIHx8IHNldEZpbHRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXRGaWx0ZXJWYWx1ZShbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRGaWx0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoY3VycmVudEZpbHRlclZhbHVlKTsgLy8gcGVyZm9ybSBuZXcgZmlsdGVyIHJlbmRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgoX2IgPSBjb2x1bW5EZWYgPT09IG51bGwgfHwgY29sdW1uRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW5EZWYuZmlsdGVyVmFyaWFudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdyYW5nZScpKSB8fFxuICAgICAgICAgICAgICAgIHJhbmdlTW9kZXMuaW5jbHVkZXMob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgbm93IGJlIHJhbmdlIGZpbHRlciBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnRGaWx0ZXJWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCEoY3VycmVudEZpbHRlclZhbHVlID09PSBudWxsIHx8IGN1cnJlbnRGaWx0ZXJWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZpbHRlclZhbHVlLmV2ZXJ5KCh2KSA9PiB2ID09PSAnJykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcmFuZ2VNb2Rlcy5pbmNsdWRlcyhwcmV2RmlsdGVyTW9kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZShbJycsICcnXSk7XG4gICAgICAgICAgICAgICAgICAgIHNldEZpbHRlclZhbHVlID09PSBudWxsIHx8IHNldEZpbHRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXRGaWx0ZXJWYWx1ZSgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoY3VycmVudEZpbHRlclZhbHVlKTsgLy8gcGVyZm9ybSBuZXcgZmlsdGVyIHJlbmRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgbm93IGJlIHNpbmdsZSB2YWx1ZSBmaWx0ZXIgbW9kZVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRGaWx0ZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RmlsdGVyVmFsdWUgPT09IG51bGwgfHwgc2V0RmlsdGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldEZpbHRlclZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEZpbHRlclZhbHVlID09PSAnICcgJiZcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlNb2Rlcy5pbmNsdWRlcyhwcmV2RmlsdGVyTW9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoY3VycmVudEZpbHRlclZhbHVlKTsgLy8gcGVyZm9ybSBuZXcgZmlsdGVyIHJlbmRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRBbmNob3JFbChudWxsKTtcbiAgICAgICAgb25TZWxlY3QgPT09IG51bGwgfHwgb25TZWxlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU2VsZWN0KCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJPcHRpb24gPSAhIWhlYWRlciAmJiBjb2x1bW5EZWYgPyBjb2x1bW5EZWYuX2ZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm47XG4gICAgcmV0dXJuIChqc3goTWVudSwgT2JqZWN0LmFzc2lnbih7IE1lbnVMaXN0UHJvcHM6IHtcbiAgICAgICAgICAgIGRlbnNlOiBkZW5zaXR5ID09PSAnY29tcGFjdCcsXG4gICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbWVudUJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFuY2hvckVsOiBhbmNob3JFbCwgYW5jaG9yT3JpZ2luOiB7IGhvcml6b250YWw6ICdyaWdodCcsIHZlcnRpY2FsOiAnY2VudGVyJyB9LCBkaXNhYmxlU2Nyb2xsTG9jazogdHJ1ZSwgb25DbG9zZTogKCkgPT4gc2V0QW5jaG9yRWwobnVsbCksIG9wZW46ICEhYW5jaG9yRWwgfSwgcmVzdCwgeyBjaGlsZHJlbjogKF9lID0gKGhlYWRlciAmJiBjb2x1bW4gJiYgY29sdW1uRGVmXG4gICAgICAgICAgICA/ICgoX2QgPSAoX2MgPSBjb2x1bW5EZWYucmVuZGVyQ29sdW1uRmlsdGVyTW9kZU1lbnVJdGVtcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoY29sdW1uRGVmLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxGaWx0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0RmlsdGVyTW9kZTogaGFuZGxlU2VsZWN0RmlsdGVyTW9kZSxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiByZW5kZXJDb2x1bW5GaWx0ZXJNb2RlTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlckNvbHVtbkZpbHRlck1vZGVNZW51SXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckNvbHVtbkZpbHRlck1vZGVNZW51SXRlbXMoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGludGVybmFsRmlsdGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdEZpbHRlck1vZGU6IGhhbmRsZVNlbGVjdEZpbHRlck1vZGUsXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDogcmVuZGVyR2xvYmFsRmlsdGVyTW9kZU1lbnVJdGVtcyA9PT0gbnVsbCB8fCByZW5kZXJHbG9iYWxGaWx0ZXJNb2RlTWVudUl0ZW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJHbG9iYWxGaWx0ZXJNb2RlTWVudUl0ZW1zKHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZpbHRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25TZWxlY3RGaWx0ZXJNb2RlOiBoYW5kbGVTZWxlY3RGaWx0ZXJNb2RlLFxuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgfSkpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBpbnRlcm5hbEZpbHRlck9wdGlvbnMubWFwKCh7IGRpdmlkZXIsIGxhYmVsLCBvcHRpb24sIHN5bWJvbCB9LCBpbmRleCkgPT4gKGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgZGl2aWRlcjogZGl2aWRlciwgaWNvbjogc3ltYm9sLCBsYWJlbDogbGFiZWwsIG9uQ2xpY2s6ICgpID0+IGhhbmRsZVNlbGVjdEZpbHRlck1vZGUob3B0aW9uKSwgc2VsZWN0ZWQ6IG9wdGlvbiA9PT0gZmlsdGVyT3B0aW9uLCB0YWJsZTogdGFibGUsIHZhbHVlOiBvcHRpb24gfSwgaW5kZXgpKSkgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9Db2x1bW5BY3Rpb25NZW51ID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgIHZhciB7IGFuY2hvckVsLCBoZWFkZXIsIHNldEFuY2hvckVsLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImFuY2hvckVsXCIsIFwiaGVhZGVyXCIsIFwic2V0QW5jaG9yRWxcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRBbGxMZWFmQ29sdW1ucywgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUsIGNvbHVtbkZpbHRlck1vZGVPcHRpb25zLCBlbmFibGVDb2x1bW5GaWx0ZXJNb2RlcywgZW5hYmxlQ29sdW1uRmlsdGVycywgZW5hYmxlQ29sdW1uUGlubmluZywgZW5hYmxlQ29sdW1uUmVzaXppbmcsIGVuYWJsZUdyb3VwaW5nLCBlbmFibGVIaWRpbmcsIGVuYWJsZVNvcnRpbmcsIGVuYWJsZVNvcnRpbmdSZW1vdmFsLCBpY29uczogeyBDbGVhckFsbEljb24sIER5bmFtaWNGZWVkSWNvbiwgRmlsdGVyTGlzdEljb24sIEZpbHRlckxpc3RPZmZJY29uLCBQdXNoUGluSWNvbiwgUmVzdGFydEFsdEljb24sIFNvcnRJY29uLCBWaWV3Q29sdW1uSWNvbiwgVmlzaWJpbGl0eU9mZkljb24sIH0sIGxvY2FsaXphdGlvbiwgbXJ0VGhlbWU6IHsgbWVudUJhY2tncm91bmRDb2xvciB9LCByZW5kZXJDb2x1bW5BY3Rpb25zTWVudUl0ZW1zLCB9LCByZWZzOiB7IGZpbHRlcklucHV0UmVmcyB9LCBzZXRDb2x1bW5GaWx0ZXJGbnMsIHNldENvbHVtbk9yZGVyLCBzZXRDb2x1bW5TaXppbmdJbmZvLCBzZXRTaG93Q29sdW1uRmlsdGVycywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGNvbHVtblNpemluZywgY29sdW1uVmlzaWJpbGl0eSwgZGVuc2l0eSwgc2hvd0NvbHVtbkZpbHRlcnMgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgY29sdW1uRmlsdGVyVmFsdWUgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKTtcbiAgICBjb25zdCBbZmlsdGVyTWVudUFuY2hvckVsLCBzZXRGaWx0ZXJNZW51QW5jaG9yRWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgaGFuZGxlQ2xlYXJTb3J0ID0gKCkgPT4ge1xuICAgICAgICBjb2x1bW4uY2xlYXJTb3J0aW5nKCk7XG4gICAgICAgIHNldEFuY2hvckVsKG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU29ydEFzYyA9ICgpID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcoZmFsc2UpO1xuICAgICAgICBzZXRBbmNob3JFbChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVNvcnREZXNjID0gKCkgPT4ge1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydGluZyh0cnVlKTtcbiAgICAgICAgc2V0QW5jaG9yRWwobnVsbCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVSZXNldENvbHVtblNpemUgPSAoKSA9PiB7XG4gICAgICAgIHNldENvbHVtblNpemluZ0luZm8oKG9sZCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkKSwgeyBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSB9KSkpO1xuICAgICAgICBjb2x1bW4ucmVzZXRTaXplKCk7XG4gICAgICAgIHNldEFuY2hvckVsKG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlSGlkZUNvbHVtbiA9ICgpID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgICBzZXRBbmNob3JFbChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVBpbkNvbHVtbiA9IChwaW5EaXJlY3Rpb24pID0+IHtcbiAgICAgICAgY29sdW1uLnBpbihwaW5EaXJlY3Rpb24pO1xuICAgICAgICBzZXRBbmNob3JFbChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUdyb3VwQnlDb2x1bW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgICBzZXRDb2x1bW5PcmRlcigob2xkKSA9PiBbJ21ydC1yb3ctZXhwYW5kJywgLi4ub2xkXSk7XG4gICAgICAgIHNldEFuY2hvckVsKG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2xlYXJGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRBbmNob3JFbChudWxsKTtcbiAgICAgICAgaWYgKFsnZW1wdHknLCAnbm90RW1wdHknXS5pbmNsdWRlcyhjb2x1bW5EZWYuX2ZpbHRlckZuKSkge1xuICAgICAgICAgICAgc2V0Q29sdW1uRmlsdGVyRm5zKChwcmV2KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2KSwgeyBbaGVhZGVyLmlkXTogKF9hID0gYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPT09IG51bGwgfHwgYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZnV6enknIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVGaWx0ZXJCeUNvbHVtbiA9ICgpID0+IHtcbiAgICAgICAgc2V0U2hvd0NvbHVtbkZpbHRlcnModHJ1ZSk7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IGZpbHRlcklucHV0UmVmcy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYCR7Y29sdW1uLmlkfS0wYF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb2N1cygpOyB9KTtcbiAgICAgICAgc2V0QW5jaG9yRWwobnVsbCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTaG93QWxsQ29sdW1ucyA9ICgpID0+IHtcbiAgICAgICAgZ2V0QWxsTGVhZkNvbHVtbnMoKVxuICAgICAgICAgICAgLmZpbHRlcigoY29sKSA9PiBjb2wuY29sdW1uRGVmLmVuYWJsZUhpZGluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29sKSA9PiBjb2wudG9nZ2xlVmlzaWJpbGl0eSh0cnVlKSk7XG4gICAgICAgIHNldEFuY2hvckVsKG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlT3BlbkZpbHRlck1vZGVNZW51ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzZXRGaWx0ZXJNZW51QW5jaG9yRWwoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBpc1NlbGVjdEZpbHRlciA9ICEhY29sdW1uRGVmLmZpbHRlclNlbGVjdE9wdGlvbnM7XG4gICAgY29uc3QgYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPSAoX2IgPSBjb2x1bW5EZWYgPT09IG51bGwgfHwgY29sdW1uRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW5EZWYuY29sdW1uRmlsdGVyTW9kZU9wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbHVtbkZpbHRlck1vZGVPcHRpb25zO1xuICAgIGNvbnN0IHNob3dGaWx0ZXJNb2RlU3ViTWVudSA9IGVuYWJsZUNvbHVtbkZpbHRlck1vZGVzICYmXG4gICAgICAgIGNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXJNb2RlcyAhPT0gZmFsc2UgJiZcbiAgICAgICAgIWlzU2VsZWN0RmlsdGVyICYmXG4gICAgICAgIChhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAhIShhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gbnVsbCB8fCBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMubGVuZ3RoKSk7XG4gICAgY29uc3QgaW50ZXJuYWxDb2x1bW5NZW51SXRlbXMgPSBbXG4gICAgICAgIC4uLihlbmFibGVTb3J0aW5nICYmIGNvbHVtbi5nZXRDYW5Tb3J0KClcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIGVuYWJsZVNvcnRpbmdSZW1vdmFsICE9PSBmYWxzZSAmJiAoanN4KE1SVF9BY3Rpb25NZW51SXRlbSwgeyBkaXNhYmxlZDogY29sdW1uLmdldElzU29ydGVkKCkgPT09IGZhbHNlLCBpY29uOiBqc3goQ2xlYXJBbGxJY29uLCB7fSksIGxhYmVsOiBsb2NhbGl6YXRpb24uY2xlYXJTb3J0LCBvbkNsaWNrOiBoYW5kbGVDbGVhclNvcnQsIHRhYmxlOiB0YWJsZSB9LCAwKSksXG4gICAgICAgICAgICAgICAganN4KE1SVF9BY3Rpb25NZW51SXRlbSwgeyBkaXNhYmxlZDogY29sdW1uLmdldElzU29ydGVkKCkgPT09ICdhc2MnLCBpY29uOiBqc3goU29ydEljb24sIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZykgc2NhbGVYKC0xKScgfSB9KSwgbGFiZWw6IChfYyA9IGxvY2FsaXphdGlvbi5zb3J0QnlDb2x1bW5Bc2MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSksIG9uQ2xpY2s6IGhhbmRsZVNvcnRBc2MsIHRhYmxlOiB0YWJsZSB9LCAxKSxcbiAgICAgICAgICAgICAgICBqc3goTVJUX0FjdGlvbk1lbnVJdGVtLCB7IGRpc2FibGVkOiBjb2x1bW4uZ2V0SXNTb3J0ZWQoKSA9PT0gJ2Rlc2MnLCBkaXZpZGVyOiBlbmFibGVDb2x1bW5GaWx0ZXJzIHx8IGVuYWJsZUdyb3VwaW5nIHx8IGVuYWJsZUhpZGluZywgaWNvbjoganN4KFNvcnRJY29uLCB7fSksIGxhYmVsOiAoX2QgPSBsb2NhbGl6YXRpb24uc29ydEJ5Q29sdW1uRGVzYykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKSwgb25DbGljazogaGFuZGxlU29ydERlc2MsIHRhYmxlOiB0YWJsZSB9LCAyKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW10pLFxuICAgICAgICAuLi4oZW5hYmxlQ29sdW1uRmlsdGVycyAmJiBjb2x1bW4uZ2V0Q2FuRmlsdGVyKClcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgZGlzYWJsZWQ6ICFjb2x1bW5GaWx0ZXJWYWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY29sdW1uRmlsdGVyVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNvbHVtbkZpbHRlclZhbHVlLmZpbHRlcigodmFsdWUpID0+IHZhbHVlKS5sZW5ndGgpLCBpY29uOiBqc3goRmlsdGVyTGlzdE9mZkljb24sIHt9KSwgbGFiZWw6IGxvY2FsaXphdGlvbi5jbGVhckZpbHRlciwgb25DbGljazogaGFuZGxlQ2xlYXJGaWx0ZXIsIHRhYmxlOiB0YWJsZSB9LCAzKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSA9PT0gJ3N1YmhlYWRlcicgJiYgKGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgZGlzYWJsZWQ6IHNob3dDb2x1bW5GaWx0ZXJzICYmICFlbmFibGVDb2x1bW5GaWx0ZXJNb2RlcywgZGl2aWRlcjogZW5hYmxlR3JvdXBpbmcgfHwgZW5hYmxlSGlkaW5nLCBpY29uOiBqc3goRmlsdGVyTGlzdEljb24sIHt9KSwgbGFiZWw6IChfZSA9IGxvY2FsaXphdGlvbi5maWx0ZXJCeUNvbHVtbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKSwgb25DbGljazogc2hvd0NvbHVtbkZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaGFuZGxlT3BlbkZpbHRlck1vZGVNZW51XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGhhbmRsZUZpbHRlckJ5Q29sdW1uLCBvbk9wZW5TdWJNZW51OiBzaG93RmlsdGVyTW9kZVN1Yk1lbnUgPyBoYW5kbGVPcGVuRmlsdGVyTW9kZU1lbnUgOiB1bmRlZmluZWQsIHRhYmxlOiB0YWJsZSB9LCA0KSksXG4gICAgICAgICAgICAgICAgc2hvd0ZpbHRlck1vZGVTdWJNZW51ICYmIChqc3goTVJUX0ZpbHRlck9wdGlvbk1lbnUsIHsgYW5jaG9yRWw6IGZpbHRlck1lbnVBbmNob3JFbCwgaGVhZGVyOiBoZWFkZXIsIG9uU2VsZWN0OiBoYW5kbGVGaWx0ZXJCeUNvbHVtbiwgc2V0QW5jaG9yRWw6IHNldEZpbHRlck1lbnVBbmNob3JFbCwgdGFibGU6IHRhYmxlIH0sIDUpKSxcbiAgICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgLi4uKGVuYWJsZUdyb3VwaW5nICYmIGNvbHVtbi5nZXRDYW5Hcm91cCgpXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICBqc3goTVJUX0FjdGlvbk1lbnVJdGVtLCB7IGRpdmlkZXI6IGVuYWJsZUNvbHVtblBpbm5pbmcsIGljb246IGpzeChEeW5hbWljRmVlZEljb24sIHt9KSwgbGFiZWw6IChfZiA9IGxvY2FsaXphdGlvbltjb2x1bW4uZ2V0SXNHcm91cGVkKCkgPyAndW5ncm91cEJ5Q29sdW1uJyA6ICdncm91cEJ5Q29sdW1uJ10pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSksIG9uQ2xpY2s6IGhhbmRsZUdyb3VwQnlDb2x1bW4sIHRhYmxlOiB0YWJsZSB9LCA2KSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW10pLFxuICAgICAgICAuLi4oZW5hYmxlQ29sdW1uUGlubmluZyAmJiBjb2x1bW4uZ2V0Q2FuUGluKClcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgZGlzYWJsZWQ6IGNvbHVtbi5nZXRJc1Bpbm5lZCgpID09PSAnbGVmdCcgfHwgIWNvbHVtbi5nZXRDYW5QaW4oKSwgaWNvbjoganN4KFB1c2hQaW5JY29uLCB7IHN0eWxlOiB7IHRyYW5zZm9ybTogJ3JvdGF0ZSg5MGRlZyknIH0gfSksIGxhYmVsOiBsb2NhbGl6YXRpb24ucGluVG9MZWZ0LCBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oJ2xlZnQnKSwgdGFibGU6IHRhYmxlIH0sIDcpLFxuICAgICAgICAgICAgICAgIGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgZGlzYWJsZWQ6IGNvbHVtbi5nZXRJc1Bpbm5lZCgpID09PSAncmlnaHQnIHx8ICFjb2x1bW4uZ2V0Q2FuUGluKCksIGljb246IGpzeChQdXNoUGluSWNvbiwgeyBzdHlsZTogeyB0cmFuc2Zvcm06ICdyb3RhdGUoLTkwZGVnKScgfSB9KSwgbGFiZWw6IGxvY2FsaXphdGlvbi5waW5Ub1JpZ2h0LCBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oJ3JpZ2h0JyksIHRhYmxlOiB0YWJsZSB9LCA4KSxcbiAgICAgICAgICAgICAgICBqc3goTVJUX0FjdGlvbk1lbnVJdGVtLCB7IGRpc2FibGVkOiAhY29sdW1uLmdldElzUGlubmVkKCksIGRpdmlkZXI6IGVuYWJsZUhpZGluZywgaWNvbjoganN4KFB1c2hQaW5JY29uLCB7fSksIGxhYmVsOiBsb2NhbGl6YXRpb24udW5waW4sIG9uQ2xpY2s6ICgpID0+IGhhbmRsZVBpbkNvbHVtbihmYWxzZSksIHRhYmxlOiB0YWJsZSB9LCA5KSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW10pLFxuICAgICAgICAuLi4oZW5hYmxlQ29sdW1uUmVzaXppbmcgJiYgY29sdW1uLmdldENhblJlc2l6ZSgpXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICBqc3goTVJUX0FjdGlvbk1lbnVJdGVtLCB7IGRpc2FibGVkOiBjb2x1bW5TaXppbmdbY29sdW1uLmlkXSA9PT0gdW5kZWZpbmVkLCBpY29uOiBqc3goUmVzdGFydEFsdEljb24sIHt9KSwgbGFiZWw6IGxvY2FsaXphdGlvbi5yZXNldENvbHVtblNpemUsIG9uQ2xpY2s6IGhhbmRsZVJlc2V0Q29sdW1uU2l6ZSwgdGFibGU6IHRhYmxlIH0sIDEwKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW10pLFxuICAgICAgICAuLi4oZW5hYmxlSGlkaW5nXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICBqc3goTVJUX0FjdGlvbk1lbnVJdGVtLCB7IGRpc2FibGVkOiAhY29sdW1uLmdldENhbkhpZGUoKSwgaWNvbjoganN4KFZpc2liaWxpdHlPZmZJY29uLCB7fSksIGxhYmVsOiAoX2cgPSBsb2NhbGl6YXRpb24uaGlkZUNvbHVtbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKSwgb25DbGljazogaGFuZGxlSGlkZUNvbHVtbiwgdGFibGU6IHRhYmxlIH0sIDExKSxcbiAgICAgICAgICAgICAgICBqc3goTVJUX0FjdGlvbk1lbnVJdGVtLCB7IGRpc2FibGVkOiAhT2JqZWN0LnZhbHVlcyhjb2x1bW5WaXNpYmlsaXR5KS5maWx0ZXIoKHZpc2libGUpID0+ICF2aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCwgaWNvbjoganN4KFZpZXdDb2x1bW5JY29uLCB7fSksIGxhYmVsOiAoX2ggPSBsb2NhbGl6YXRpb24uc2hvd0FsbENvbHVtbnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXBsYWNlKCd7Y29sdW1ufScsIFN0cmluZyhjb2x1bW5EZWYuaGVhZGVyKSksIG9uQ2xpY2s6IGhhbmRsZVNob3dBbGxDb2x1bW5zLCB0YWJsZTogdGFibGUgfSwgMTIpLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXSksXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuIChqc3goTWVudSwgT2JqZWN0LmFzc2lnbih7IE1lbnVMaXN0UHJvcHM6IHtcbiAgICAgICAgICAgIGRlbnNlOiBkZW5zaXR5ID09PSAnY29tcGFjdCcsXG4gICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbWVudUJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFuY2hvckVsOiBhbmNob3JFbCwgZGlzYWJsZVNjcm9sbExvY2s6IHRydWUsIG9uQ2xvc2U6ICgpID0+IHNldEFuY2hvckVsKG51bGwpLCBvcGVuOiAhIWFuY2hvckVsIH0sIHJlc3QsIHsgY2hpbGRyZW46IChfbCA9IChfayA9IChfaiA9IGNvbHVtbkRlZi5yZW5kZXJDb2x1bW5BY3Rpb25zTWVudUl0ZW1zKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY2FsbChjb2x1bW5EZWYsIHtcbiAgICAgICAgICAgIGNsb3NlTWVudTogKCkgPT4gc2V0QW5jaG9yRWwobnVsbCksXG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBpbnRlcm5hbENvbHVtbk1lbnVJdGVtcyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogcmVuZGVyQ29sdW1uQWN0aW9uc01lbnVJdGVtcyA9PT0gbnVsbCB8fCByZW5kZXJDb2x1bW5BY3Rpb25zTWVudUl0ZW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJDb2x1bW5BY3Rpb25zTWVudUl0ZW1zKHtcbiAgICAgICAgICAgIGNsb3NlTWVudTogKCkgPT4gc2V0QW5jaG9yRWwobnVsbCksXG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBpbnRlcm5hbENvbHVtbk1lbnVJdGVtcyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICB9KSkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogaW50ZXJuYWxDb2x1bW5NZW51SXRlbXMgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRDZWxsQ29sdW1uQWN0aW9uc0J1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIHsgaGVhZGVyLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImhlYWRlclwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWNvbnM6IHsgTW9yZVZlcnRJY29uIH0sIGxvY2FsaXphdGlvbiwgbXVpQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IFthbmNob3JFbCwgc2V0QW5jaG9yRWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldEFuY2hvckVsKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIH07XG4gICAgY29uc3QgaWNvbkJ1dHRvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlDb2x1bW5BY3Rpb25zQnV0dG9uUHJvcHMsIHtcbiAgICAgICAgY29sdW1uLFxuICAgICAgICB0YWJsZSxcbiAgICB9KSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpQ29sdW1uQWN0aW9uc0J1dHRvblByb3BzLCB7XG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbHRpcFByb3BzKCd0b3AnKSwgeyB0aXRsZTogKF9iID0gaWNvbkJ1dHRvblByb3BzID09PSBudWxsIHx8IGljb25CdXR0b25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWNvbkJ1dHRvblByb3BzLnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24uY29sdW1uQWN0aW9ucywgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5jb2x1bW5BY3Rpb25zLCBvbkNsaWNrOiBoYW5kbGVDbGljaywgc2l6ZTogXCJzbWFsbFwiIH0sIGljb25CdXR0b25Qcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7ICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBoZWlnaHQ6ICcycmVtJywgbTogJy04cHggLTRweCcsIG9wYWNpdHk6IDAuMywgdHJhbnNpdGlvbjogJ2FsbCAxNTBtcycsIHdpZHRoOiAnMnJlbScgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGljb25CdXR0b25Qcm9wcyA9PT0gbnVsbCB8fCBpY29uQnV0dG9uUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGljb25CdXR0b25Qcm9wcy5zeCwgdGhlbWUpKSksIHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiAoX2MgPSBpY29uQnV0dG9uUHJvcHMgPT09IG51bGwgfHwgaWNvbkJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uQnV0dG9uUHJvcHMuY2hpbGRyZW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChqc3goTW9yZVZlcnRJY29uLCB7IHN0eWxlOiB7IHRyYW5zZm9ybTogJ3NjYWxlKDAuOSknIH0gfSkpIH0pKSB9KSksIGFuY2hvckVsICYmIChqc3goTVJUX0NvbHVtbkFjdGlvbk1lbnUsIHsgYW5jaG9yRWw6IGFuY2hvckVsLCBoZWFkZXI6IGhlYWRlciwgc2V0QW5jaG9yRWw6IHNldEFuY2hvckVsLCB0YWJsZTogdGFibGUgfSkpXSB9KSk7XG59O1xuXG5jb25zdCBNUlRfRmlsdGVyQ2hlY2tib3ggPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jLCBfZDtcbiAgICB2YXIgeyBjb2x1bW4sIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY29sdW1uXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgbG9jYWxpemF0aW9uLCBtdWlGaWx0ZXJDaGVja2JveFByb3BzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHkgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCBjaGVja2JveFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlGaWx0ZXJDaGVja2JveFByb3BzLCB7XG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLm11aUZpbHRlckNoZWNrYm94UHJvcHMsIHtcbiAgICAgICAgY29sdW1uLFxuICAgICAgICB0YWJsZSxcbiAgICB9KSksIHJlc3QpO1xuICAgIGNvbnN0IGZpbHRlckxhYmVsID0gKF9iID0gbG9jYWxpemF0aW9uLmZpbHRlckJ5Q29sdW1uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgne2NvbHVtbn0nLCBjb2x1bW5EZWYuaGVhZGVyKTtcbiAgICByZXR1cm4gKGpzeChUb29sdGlwLCBPYmplY3QuYXNzaWduKHt9LCBnZXRDb21tb25Ub29sdGlwUHJvcHMoKSwgeyB0aXRsZTogKF9jID0gY2hlY2tib3hQcm9wcyA9PT0gbnVsbCB8fCBjaGVja2JveFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja2JveFByb3BzLnRpdGxlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmaWx0ZXJMYWJlbCwgY2hpbGRyZW46IGpzeChGb3JtQ29udHJvbExhYmVsLCB7IGNvbnRyb2w6IGpzeChDaGVja2JveCwgT2JqZWN0LmFzc2lnbih7IGNoZWNrZWQ6IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpID09PSAndHJ1ZScsIGNvbG9yOiBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSA9PT0gdW5kZWZpbmVkID8gJ2RlZmF1bHQnIDogJ3ByaW1hcnknLCBpbmRldGVybWluYXRlOiBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSA9PT0gdW5kZWZpbmVkLCBzaXplOiBkZW5zaXR5ID09PSAnY29tcGFjdCcgPyAnc21hbGwnIDogJ21lZGl1bScgfSwgY2hlY2tib3hQcm9wcywgeyBvbkNoYW5nZTogKGUsIGNoZWNrZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUoY29sdW1uLmdldEZpbHRlclZhbHVlKCkgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29sdW1uLmdldEZpbHRlclZhbHVlKCkgPT09ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2ZhbHNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gY2hlY2tib3hQcm9wcyA9PT0gbnVsbCB8fCBjaGVja2JveFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja2JveFByb3BzLm9uQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjaGVja2JveFByb3BzLCBlLCBjaGVja2VkKTtcbiAgICAgICAgICAgICAgICB9LCBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGNoZWNrYm94UHJvcHMgPT09IG51bGwgfHwgY2hlY2tib3hQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tib3hQcm9wcy5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjaGVja2JveFByb3BzLCBlKTtcbiAgICAgICAgICAgICAgICB9LCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGhlaWdodDogJzIuNXJlbScsIHdpZHRoOiAnMi41cmVtJyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY2hlY2tib3hQcm9wcyA9PT0gbnVsbCB8fCBjaGVja2JveFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja2JveFByb3BzLnN4LCB0aGVtZSkpKSB9KSksIGRpc2FibGVUeXBvZ3JhcGh5OiB0cnVlLCBsYWJlbDogKF9kID0gY2hlY2tib3hQcm9wcy50aXRsZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmlsdGVyTGFiZWwsIHN4OiB7IGNvbG9yOiAndGV4dC5zZWNvbmRhcnknLCBmb250V2VpZ2h0OiAnbm9ybWFsJywgbXQ6ICctNHB4JyB9LCB0aXRsZTogdW5kZWZpbmVkIH0pIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfRmlsdGVyVGV4dEZpZWxkID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iLCBfYywgX2QsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeCwgX3ksIF96LCBfMDtcbiAgICB2YXIgeyBoZWFkZXIsIHJhbmdlRmlsdGVySW5kZXgsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiaGVhZGVyXCIsIFwicmFuZ2VGaWx0ZXJJbmRleFwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgZW5hYmxlQ29sdW1uRmlsdGVyTW9kZXMsIGljb25zOiB7IENsb3NlSWNvbiwgRmlsdGVyTGlzdEljb24gfSwgbG9jYWxpemF0aW9uLCBtYW51YWxGaWx0ZXJpbmcsIG11aUZpbHRlckF1dG9jb21wbGV0ZVByb3BzLCBtdWlGaWx0ZXJEYXRlUGlja2VyUHJvcHMsIG11aUZpbHRlckRhdGVUaW1lUGlja2VyUHJvcHMsIG11aUZpbHRlclRleHRGaWVsZFByb3BzLCBtdWlGaWx0ZXJUaW1lUGlja2VyUHJvcHMsIH0sIHJlZnM6IHsgZmlsdGVySW5wdXRSZWZzIH0sIHNldENvbHVtbkZpbHRlckZucywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGZpbHRlclZhcmlhbnQgfSA9IGNvbHVtbkRlZjtcbiAgICBjb25zdCBhcmdzID0geyBjb2x1bW4sIHJhbmdlRmlsdGVySW5kZXgsIHRhYmxlIH07XG4gICAgY29uc3QgdGV4dEZpZWxkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aUZpbHRlclRleHRGaWVsZFByb3BzLCBhcmdzKSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpRmlsdGVyVGV4dEZpZWxkUHJvcHMsIGFyZ3MpKSwgcmVzdCk7XG4gICAgY29uc3QgYXV0b2NvbXBsZXRlUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlGaWx0ZXJBdXRvY29tcGxldGVQcm9wcywgYXJncykpLCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLm11aUZpbHRlckF1dG9jb21wbGV0ZVByb3BzLCBhcmdzKSk7XG4gICAgY29uc3QgZGF0ZVBpY2tlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpRmlsdGVyRGF0ZVBpY2tlclByb3BzLCBhcmdzKSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpRmlsdGVyRGF0ZVBpY2tlclByb3BzLCBhcmdzKSk7XG4gICAgY29uc3QgZGF0ZVRpbWVQaWNrZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aUZpbHRlckRhdGVUaW1lUGlja2VyUHJvcHMsIGFyZ3MpKSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNvbHVtbkRlZi5tdWlGaWx0ZXJEYXRlVGltZVBpY2tlclByb3BzLCBhcmdzKSk7XG4gICAgY29uc3QgdGltZVBpY2tlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpRmlsdGVyVGltZVBpY2tlclByb3BzLCBhcmdzKSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpRmlsdGVyVGltZVBpY2tlclByb3BzLCBhcmdzKSk7XG4gICAgY29uc3QgeyBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucywgY3VycmVudEZpbHRlck9wdGlvbiwgZmFjZXRlZFVuaXF1ZVZhbHVlcywgaXNBdXRvY29tcGxldGVGaWx0ZXIsIGlzRGF0ZUZpbHRlciwgaXNNdWx0aVNlbGVjdEZpbHRlciwgaXNSYW5nZUZpbHRlciwgaXNTZWxlY3RGaWx0ZXIsIGlzVGV4dGJveEZpbHRlciwgfSA9IGdldENvbHVtbkZpbHRlckluZm8oeyBoZWFkZXIsIHRhYmxlIH0pO1xuICAgIGNvbnN0IGRyb3Bkb3duT3B0aW9ucyA9IHVzZURyb3Bkb3duT3B0aW9ucyh7IGhlYWRlciwgdGFibGUgfSk7XG4gICAgY29uc3QgZmlsdGVyQ2hpcExhYmVsID0gWydlbXB0eScsICdub3RFbXB0eSddLmluY2x1ZGVzKGN1cnJlbnRGaWx0ZXJPcHRpb24pXG4gICAgICAgID8gbG9jYWxpemF0aW9uW2BmaWx0ZXIkeygoX2MgPSAoX2IgPSBjdXJyZW50RmlsdGVyT3B0aW9uID09PSBudWxsIHx8IGN1cnJlbnRGaWx0ZXJPcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGaWx0ZXJPcHRpb24uY2hhckF0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjdXJyZW50RmlsdGVyT3B0aW9uLCAwKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvVXBwZXJDYXNlKCkpICtcbiAgICAgICAgICAgIChjdXJyZW50RmlsdGVyT3B0aW9uID09PSBudWxsIHx8IGN1cnJlbnRGaWx0ZXJPcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGaWx0ZXJPcHRpb24uc2xpY2UoMSkpfWBdXG4gICAgICAgIDogJyc7XG4gICAgY29uc3QgZmlsdGVyUGxhY2Vob2xkZXIgPSAhaXNSYW5nZUZpbHRlclxuICAgICAgICA/ICgoX2QgPSB0ZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEZpZWxkUHJvcHMucGxhY2Vob2xkZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChfZiA9IGxvY2FsaXphdGlvbi5maWx0ZXJCeUNvbHVtbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnJlcGxhY2UoJ3tjb2x1bW59JywgU3RyaW5nKGNvbHVtbkRlZi5oZWFkZXIpKSlcbiAgICAgICAgOiByYW5nZUZpbHRlckluZGV4ID09PSAwXG4gICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5taW5cbiAgICAgICAgICAgIDogcmFuZ2VGaWx0ZXJJbmRleCA9PT0gMVxuICAgICAgICAgICAgICAgID8gbG9jYWxpemF0aW9uLm1heFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgY29uc3Qgc2hvd0NoYW5nZU1vZGVCdXR0b24gPSAhIShlbmFibGVDb2x1bW5GaWx0ZXJNb2RlcyAmJlxuICAgICAgICBjb2x1bW5EZWYuZW5hYmxlQ29sdW1uRmlsdGVyTW9kZXMgIT09IGZhbHNlICYmXG4gICAgICAgICFyYW5nZUZpbHRlckluZGV4ICYmXG4gICAgICAgIChhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAhIShhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gbnVsbCB8fCBhbGxvd2VkQ29sdW1uRmlsdGVyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMubGVuZ3RoKSkpO1xuICAgIGNvbnN0IFthbmNob3JFbCwgc2V0QW5jaG9yRWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2ZpbHRlclZhbHVlLCBzZXRGaWx0ZXJWYWx1ZV0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBpc011bHRpU2VsZWN0RmlsdGVyXG4gICAgICAgICAgICA/IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpIHx8IFtdXG4gICAgICAgICAgICA6IGlzUmFuZ2VGaWx0ZXJcbiAgICAgICAgICAgICAgICA/ICgoX2EgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3JhbmdlRmlsdGVySW5kZXhdKSB8fCAnJ1xuICAgICAgICAgICAgICAgIDogaXNBdXRvY29tcGxldGVGaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgPyB0eXBlb2YgY29sdW1uLmdldEZpbHRlclZhbHVlKCkgPT09ICdzdHJpbmcnID8gY29sdW1uLmdldEZpbHRlclZhbHVlKCkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICA6ICgoX2IgPSBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgIH0pO1xuICAgIGNvbnN0IFthdXRvY29tcGxldGVWYWx1ZSwgc2V0QXV0b2NvbXBsZXRlVmFsdWVdID0gdXNlU3RhdGUoKCkgPT4gaXNBdXRvY29tcGxldGVGaWx0ZXIgPyAoY29sdW1uLmdldEZpbHRlclZhbHVlKCkgfHwgbnVsbCkgOiBudWxsKTtcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2VEZWJvdW5jZWQgPSB1c2VDYWxsYmFjayhkZWJvdW5jZSgobmV3VmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzUmFuZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSgob2xkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RmlsdGVyVmFsdWVzID0gb2xkICE9PSBudWxsICYmIG9sZCAhPT0gdm9pZCAwID8gb2xkIDogWycnLCAnJ107XG4gICAgICAgICAgICAgICAgbmV3RmlsdGVyVmFsdWVzW3JhbmdlRmlsdGVySW5kZXhdID0gbmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHZvaWQgMCA/IG5ld1ZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGaWx0ZXJWYWx1ZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZShuZXdWYWx1ZSAhPT0gbnVsbCAmJiBuZXdWYWx1ZSAhPT0gdm9pZCAwID8gbmV3VmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSwgaXNUZXh0Ym94RmlsdGVyID8gKG1hbnVhbEZpbHRlcmluZyA/IDQwMCA6IDIwMCkgOiAxKSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBzZXRGaWx0ZXJWYWx1ZShuZXdWYWx1ZSAhPT0gbnVsbCAmJiBuZXdWYWx1ZSAhPT0gdm9pZCAwID8gbmV3VmFsdWUgOiAnJyk7XG4gICAgICAgIGhhbmRsZUNoYW5nZURlYm91bmNlZChuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVUZXh0RmllbGRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRleHRGaWVsZFByb3BzLnR5cGUgPT09ICdkYXRlJ1xuICAgICAgICAgICAgPyBldmVudC50YXJnZXQudmFsdWVBc0RhdGVcbiAgICAgICAgICAgIDogdGV4dEZpZWxkUHJvcHMudHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGV2ZW50LnRhcmdldC52YWx1ZUFzTnVtYmVyXG4gICAgICAgICAgICAgICAgOiBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSk7XG4gICAgICAgIChfYSA9IHRleHRGaWVsZFByb3BzID09PSBudWxsIHx8IHRleHRGaWVsZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RmllbGRQcm9wcy5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGV4dEZpZWxkUHJvcHMsIGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUF1dG9jb21wbGV0ZUlucHV0Q2hhbmdlID0gKF9ldmVudCwgbmV3VmFsdWUsIF9yZWFzb24pID0+IHtcbiAgICAgICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUF1dG9jb21wbGV0ZUNoYW5nZSA9IChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBzZXRBdXRvY29tcGxldGVWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIGhhbmRsZUNoYW5nZURlYm91bmNlZChnZXRWYWx1ZUFuZExhYmVsKG5ld1ZhbHVlKS52YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDbGVhciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlzTXVsdGlTZWxlY3RGaWx0ZXIpIHtcbiAgICAgICAgICAgIHNldEZpbHRlclZhbHVlKFtdKTtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSYW5nZUZpbHRlcikge1xuICAgICAgICAgICAgc2V0RmlsdGVyVmFsdWUoJycpO1xuICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKChvbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdGaWx0ZXJWYWx1ZXMgPSAoQXJyYXkuaXNBcnJheShvbGQpICYmIG9sZCkgfHwgWycnLCAnJ107XG4gICAgICAgICAgICAgICAgbmV3RmlsdGVyVmFsdWVzW3JhbmdlRmlsdGVySW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGaWx0ZXJWYWx1ZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0F1dG9jb21wbGV0ZUZpbHRlcikge1xuICAgICAgICAgICAgc2V0QXV0b2NvbXBsZXRlVmFsdWUobnVsbCk7XG4gICAgICAgICAgICBzZXRGaWx0ZXJWYWx1ZSgnJyk7XG4gICAgICAgICAgICAvLyB3aGVuIHVzaW5nICdhdXRvY29tcGxldGUnIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgaW5zaWRlIGVmZmVjdCBhbmQgb25seSBpZiB0aGUgZmlsdGVyVmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gc28gdGhlIGZvbGxvd2luZyBjYWxsIGlzIGV4Y2Vzc2l2ZTsgc2hvdWxkIGJlIHVuY29tbWVudGVkIGlmIHRoZSBoYW5kbGVDbGVhciBiZWNvbWVzIHBhcnQgb2YgdGhlIEF1dG9jb21wbGV0ZSBjb21wb25lbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAvLyBjb2x1bW4uc2V0RmlsdGVyVmFsdWUodW5kZWZpbmVkKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0RmlsdGVyVmFsdWUoJycpO1xuICAgICAgICAgICAgY29sdW1uLnNldEZpbHRlclZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNsZWFyRW1wdHlGaWx0ZXJDaGlwID0gKCkgPT4ge1xuICAgICAgICBzZXRGaWx0ZXJWYWx1ZSgnJyk7XG4gICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRDb2x1bW5GaWx0ZXJGbnMoKHByZXYpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2KSwgeyBbaGVhZGVyLmlkXTogKF9hID0gYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPT09IG51bGwgfHwgYWxsb3dlZENvbHVtbkZpbHRlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFsbG93ZWRDb2x1bW5GaWx0ZXJPcHRpb25zWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZnV6enknIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVGaWx0ZXJNZW51T3BlbiA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXRBbmNob3JFbChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGZpbHRlclZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSYW5nZUZpbHRlciAmJiByYW5nZUZpbHRlckluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRGaWx0ZXJWYWx1ZShmaWx0ZXJWYWx1ZVtyYW5nZUZpbHRlckluZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRGaWx0ZXJWYWx1ZShmaWx0ZXJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtjb2x1bW4uZ2V0RmlsdGVyVmFsdWUoKV0pO1xuICAgIGlmIChjb2x1bW5EZWYuRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiAoX2cgPSBjb2x1bW5EZWYuRmlsdGVyKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuY2FsbChjb2x1bW5EZWYsIHsgY29sdW1uLCBoZWFkZXIsIHJhbmdlRmlsdGVySW5kZXgsIHRhYmxlIH0pIH0pKTtcbiAgICB9XG4gICAgY29uc3QgZW5kQWRvcm5tZW50ID0gIWlzQXV0b2NvbXBsZXRlRmlsdGVyICYmICFpc0RhdGVGaWx0ZXIgJiYgIWZpbHRlckNoaXBMYWJlbCA/IChqc3goSW5wdXRBZG9ybm1lbnQsIHsgcG9zaXRpb246IFwiZW5kXCIsIHN4OiB7XG4gICAgICAgICAgICBtcjogaXNTZWxlY3RGaWx0ZXIgfHwgaXNNdWx0aVNlbGVjdEZpbHRlciA/ICcyMHB4JyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6ICgoX2ggPSBmaWx0ZXJWYWx1ZSA9PT0gbnVsbCB8fCBmaWx0ZXJWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyVmFsdWUubGVuZ3RoKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAwKSA+IDAgPyAndmlzaWJsZScgOiAnaGlkZGVuJyxcbiAgICAgICAgfSwgY2hpbGRyZW46IGpzeChUb29sdGlwLCB7IHBsYWNlbWVudDogXCJyaWdodFwiLCB0aXRsZTogKF9qID0gbG9jYWxpemF0aW9uLmNsZWFyRmlsdGVyKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAnJywgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5jbGVhckZpbHRlciwgZGlzYWJsZWQ6ICEoKF9rID0gZmlsdGVyVmFsdWUgPT09IG51bGwgfHwgZmlsdGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlclZhbHVlLnRvU3RyaW5nKCkpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5sZW5ndGgpLCBvbkNsaWNrOiBoYW5kbGVDbGVhciwgc2l6ZTogXCJzbWFsbFwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMnJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjkpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMnJlbScsXG4gICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBqc3goQ2xvc2VJY29uLCB7fSkgfSkgfSkgfSkgfSkpIDogbnVsbDtcbiAgICBjb25zdCBzdGFydEFkb3JubWVudCA9IHNob3dDaGFuZ2VNb2RlQnV0dG9uID8gKGpzeHMoSW5wdXRBZG9ybm1lbnQsIHsgcG9zaXRpb246IFwic3RhcnRcIiwgY2hpbGRyZW46IFtqc3goVG9vbHRpcCwgeyB0aXRsZTogbG9jYWxpemF0aW9uLmNoYW5nZUZpbHRlck1vZGUsIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHsgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCB7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uY2hhbmdlRmlsdGVyTW9kZSwgb25DbGljazogaGFuZGxlRmlsdGVyTWVudU9wZW4sIHNpemU6IFwic21hbGxcIiwgc3g6IHsgaGVpZ2h0OiAnMS43NXJlbScsIHdpZHRoOiAnMS43NXJlbScgfSwgY2hpbGRyZW46IGpzeChGaWx0ZXJMaXN0SWNvbiwge30pIH0pIH0pIH0pLCBmaWx0ZXJDaGlwTGFiZWwgJiYgKGpzeChDaGlwLCB7IGxhYmVsOiBmaWx0ZXJDaGlwTGFiZWwsIG9uRGVsZXRlOiBoYW5kbGVDbGVhckVtcHR5RmlsdGVyQ2hpcCB9KSldIH0pKSA6IG51bGw7XG4gICAgY29uc3QgY29tbW9uVGV4dEZpZWxkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBmdWxsV2lkdGg6IHRydWUsIGhlbHBlclRleHQ6IHNob3dDaGFuZ2VNb2RlQnV0dG9uID8gKGpzeChcImxhYmVsXCIsIHsgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5maWx0ZXJNb2RlLnJlcGxhY2UoJ3tmaWx0ZXJUeXBlfScsIGxvY2FsaXphdGlvbltgZmlsdGVyJHsoKF9sID0gY3VycmVudEZpbHRlck9wdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyT3B0aW9uLmNoYXJBdCgwKSkgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnRvVXBwZXJDYXNlKCkpICtcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpbHRlck9wdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyT3B0aW9uLnNsaWNlKDEpKX1gXSkgfSkpIDogbnVsbCwgaW5wdXRSZWY6IChpbnB1dFJlZikgPT4ge1xuICAgICAgICAgICAgZmlsdGVySW5wdXRSZWZzLmN1cnJlbnRbYCR7Y29sdW1uLmlkfS0ke3JhbmdlRmlsdGVySW5kZXggIT09IG51bGwgJiYgcmFuZ2VGaWx0ZXJJbmRleCAhPT0gdm9pZCAwID8gcmFuZ2VGaWx0ZXJJbmRleCA6IDB9YF0gPVxuICAgICAgICAgICAgICAgIGlucHV0UmVmO1xuICAgICAgICAgICAgaWYgKHRleHRGaWVsZFByb3BzLmlucHV0UmVmKSB7XG4gICAgICAgICAgICAgICAgdGV4dEZpZWxkUHJvcHMuaW5wdXRSZWYgPSBpbnB1dFJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbWFyZ2luOiAnbm9uZScsIHBsYWNlaG9sZGVyOiBmaWx0ZXJDaGlwTGFiZWwgfHwgaXNTZWxlY3RGaWx0ZXIgfHwgaXNNdWx0aVNlbGVjdEZpbHRlclxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogZmlsdGVyUGxhY2Vob2xkZXIsIHZhcmlhbnQ6ICdzdGFuZGFyZCcgfSwgdGV4dEZpZWxkUHJvcHMpLCB7IHNsb3RQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0ZXh0RmllbGRQcm9wcy5zbG90UHJvcHMpLCB7IGZvcm1IZWxwZXJUZXh0OiBPYmplY3QuYXNzaWduKHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjc1cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogJzAuOHJlbScsXG4gICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICAgICAgICAgIH0gfSwgKF9tID0gdGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uZm9ybUhlbHBlclRleHQpLCBpbnB1dDogZW5kQWRvcm5tZW50IC8vaGFjayBiZWNhdXNlIG11aSBsb29rcyBmb3IgcHJlc2VuY2Ugb2YgZW5kQWRvcm5tZW50IGtleSBpbnN0ZWFkIG9mIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7IGVuZEFkb3JubWVudCwgc3RhcnRBZG9ybm1lbnQgfSwgKF9vID0gdGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28uaW5wdXQpIDogT2JqZWN0LmFzc2lnbih7IHN0YXJ0QWRvcm5tZW50IH0sIChfcCA9IHRleHRGaWVsZFByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wLmlucHV0KSwgaHRtbElucHV0OiBPYmplY3QuYXNzaWduKHsgJ2FyaWEtbGFiZWwnOiBmaWx0ZXJQbGFjZWhvbGRlciwgYXV0b0NvbXBsZXRlOiAnb2ZmJywgZGlzYWJsZWQ6ICEhZmlsdGVyQ2hpcExhYmVsLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBmaWx0ZXJDaGlwTGFiZWwgPyAwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sIHRpdGxlOiBmaWx0ZXJQbGFjZWhvbGRlciB9LCAoX3EgPSB0ZXh0RmllbGRQcm9wcy5zbG90UHJvcHMpID09PSBudWxsIHx8IF9xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcS5odG1sSW5wdXQpIH0pLCBvbktleURvd246IChlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgKF9hID0gdGV4dEZpZWxkUHJvcHMub25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0ZXh0RmllbGRQcm9wcywgZSk7XG4gICAgICAgIH0sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgbWluV2lkdGg6IGlzRGF0ZUZpbHRlclxuICAgICAgICAgICAgICAgID8gJzE2MHB4J1xuICAgICAgICAgICAgICAgIDogZW5hYmxlQ29sdW1uRmlsdGVyTW9kZXMgJiYgcmFuZ2VGaWx0ZXJJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/ICcxMTBweCdcbiAgICAgICAgICAgICAgICAgICAgOiBpc1JhbmdlRmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcxMDBweCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIWZpbHRlckNoaXBMYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzEyMHB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2F1dG8nLCBteDogJy0ycHgnLCBwOiAwLCB3aWR0aDogJ2NhbGMoMTAwJSArIDRweCknIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0ZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEZpZWxkUHJvcHMuc3gsIHRoZW1lKSkpIH0pO1xuICAgIGNvbnN0IGNvbW1vbkRhdGVQaWNrZXJQcm9wcyA9IHtcbiAgICAgICAgb25DaGFuZ2U6IChuZXdEYXRlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVDaGFuZ2UobmV3RGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmaWx0ZXJWYWx1ZSB8fCBudWxsLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKGZpbHRlclZhcmlhbnQgPT09IG51bGwgfHwgZmlsdGVyVmFyaWFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyVmFyaWFudC5zdGFydHNXaXRoKCd0aW1lJykpID8gKGpzeChUaW1lUGlja2VyLCBPYmplY3QuYXNzaWduKHt9LCBjb21tb25EYXRlUGlja2VyUHJvcHMsIHRpbWVQaWNrZXJQcm9wcywgeyBzbG90UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IE9iamVjdC5hc3NpZ24oeyBjbGVhcmFibGU6IHRydWUsIG9uQ2xlYXI6ICgpID0+IGhhbmRsZUNsZWFyKCkgfSwgKF9yID0gdGltZVBpY2tlclByb3BzID09PSBudWxsIHx8IHRpbWVQaWNrZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGltZVBpY2tlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yLmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpZWxkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblRleHRGaWVsZFByb3BzKSwgKF9zID0gdGltZVBpY2tlclByb3BzID09PSBudWxsIHx8IHRpbWVQaWNrZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGltZVBpY2tlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zLnRleHRGaWVsZCksXG4gICAgICAgICAgICAgICAgfSB9KSkpIDogKGZpbHRlclZhcmlhbnQgPT09IG51bGwgfHwgZmlsdGVyVmFyaWFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyVmFyaWFudC5zdGFydHNXaXRoKCdkYXRldGltZScpKSA/IChqc3goRGF0ZVRpbWVQaWNrZXIsIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vbkRhdGVQaWNrZXJQcm9wcywgZGF0ZVRpbWVQaWNrZXJQcm9wcywgeyBzbG90UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IE9iamVjdC5hc3NpZ24oeyBjbGVhcmFibGU6IHRydWUsIG9uQ2xlYXI6ICgpID0+IGhhbmRsZUNsZWFyKCkgfSwgKF90ID0gZGF0ZVRpbWVQaWNrZXJQcm9wcyA9PT0gbnVsbCB8fCBkYXRlVGltZVBpY2tlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRlVGltZVBpY2tlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90LmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpZWxkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblRleHRGaWVsZFByb3BzKSwgKF91ID0gZGF0ZVRpbWVQaWNrZXJQcm9wcyA9PT0gbnVsbCB8fCBkYXRlVGltZVBpY2tlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRlVGltZVBpY2tlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF91LnRleHRGaWVsZCksXG4gICAgICAgICAgICAgICAgfSB9KSkpIDogKGZpbHRlclZhcmlhbnQgPT09IG51bGwgfHwgZmlsdGVyVmFyaWFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyVmFyaWFudC5zdGFydHNXaXRoKCdkYXRlJykpID8gKGpzeChEYXRlUGlja2VyLCBPYmplY3QuYXNzaWduKHt9LCBjb21tb25EYXRlUGlja2VyUHJvcHMsIGRhdGVQaWNrZXJQcm9wcywgeyBzbG90UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IE9iamVjdC5hc3NpZ24oeyBjbGVhcmFibGU6IHRydWUsIG9uQ2xlYXI6ICgpID0+IGhhbmRsZUNsZWFyKCkgfSwgKF92ID0gZGF0ZVBpY2tlclByb3BzID09PSBudWxsIHx8IGRhdGVQaWNrZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0ZVBpY2tlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92LmZpZWxkKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpZWxkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblRleHRGaWVsZFByb3BzKSwgKF93ID0gZGF0ZVBpY2tlclByb3BzID09PSBudWxsIHx8IGRhdGVQaWNrZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0ZVBpY2tlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93LnRleHRGaWVsZCksXG4gICAgICAgICAgICAgICAgfSB9KSkpIDogaXNBdXRvY29tcGxldGVGaWx0ZXIgPyAoanN4KEF1dG9jb21wbGV0ZSwgT2JqZWN0LmFzc2lnbih7IGZyZWVTb2xvOiB0cnVlLCBnZXRPcHRpb25MYWJlbDogKG9wdGlvbikgPT4gZ2V0VmFsdWVBbmRMYWJlbChvcHRpb24pLmxhYmVsLCBvbkNoYW5nZTogKF9lLCBuZXdWYWx1ZSkgPT4gaGFuZGxlQXV0b2NvbXBsZXRlQ2hhbmdlKG5ld1ZhbHVlKSwgb3B0aW9uczogKF94ID0gZHJvcGRvd25PcHRpb25zID09PSBudWxsIHx8IGRyb3Bkb3duT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJvcGRvd25PcHRpb25zLm1hcCgob3B0aW9uKSA9PiBnZXRWYWx1ZUFuZExhYmVsKG9wdGlvbikpKSAhPT0gbnVsbCAmJiBfeCAhPT0gdm9pZCAwID8gX3ggOiBbXSwgaW5wdXRWYWx1ZTogZmlsdGVyVmFsdWUsIG9uSW5wdXRDaGFuZ2U6IGhhbmRsZUF1dG9jb21wbGV0ZUlucHV0Q2hhbmdlIH0sIGF1dG9jb21wbGV0ZVByb3BzLCB7IHJlbmRlcklucHV0OiAoYnVpbHRpblRleHRGaWVsZFByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2Y7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoanN4KFRleHRGaWVsZCwgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGV4dEZpZWxkUHJvcHMsIGJ1aWx0aW5UZXh0RmllbGRQcm9wcywgeyBzbG90UHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsdGluVGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSwgY29tbW9uVGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSwgeyBpbnB1dDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWx0aW5UZXh0RmllbGRQcm9wcy5JbnB1dFByb3BzKSwgKF9hID0gYnVpbHRpblRleHRGaWVsZFByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0KSwgeyBzdGFydEFkb3JubWVudDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBjb21tb25UZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCBjb21tb25UZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tbW9uVGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5wdXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdGFydEFkb3JubWVudCB9KSwgaHRtbElucHV0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbHRpblRleHRGaWVsZFByb3BzLmlucHV0UHJvcHMpLCAoX2QgPSBidWlsdGluVGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaHRtbElucHV0KSwgKF9mID0gY29tbW9uVGV4dEZpZWxkUHJvcHMgPT09IG51bGwgfHwgY29tbW9uVGV4dEZpZWxkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbW1vblRleHRGaWVsZFByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmh0bWxJbnB1dCkgfSksIG9uQ2xpY2s6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpIH0pKSk7XG4gICAgICAgICAgICAgICAgfSwgdmFsdWU6IGF1dG9jb21wbGV0ZVZhbHVlIH0pKSkgOiAoanN4KFRleHRGaWVsZCwgT2JqZWN0LmFzc2lnbih7IHNlbGVjdDogaXNTZWxlY3RGaWx0ZXIgfHwgaXNNdWx0aVNlbGVjdEZpbHRlciB9LCBjb21tb25UZXh0RmllbGRQcm9wcywgeyBzbG90UHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGV4dEZpZWxkUHJvcHMuc2xvdFByb3BzKSwgeyBpbnB1dExhYmVsOiBPYmplY3QuYXNzaWduKHsgc2hyaW5rOiBpc1NlbGVjdEZpbHRlciB8fCBpc011bHRpU2VsZWN0RmlsdGVyIH0sIChfeSA9IGNvbW1vblRleHRGaWVsZFByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3kgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF95LmlucHV0TGFiZWwpLCBzZWxlY3Q6IE9iamVjdC5hc3NpZ24oeyBNZW51UHJvcHM6IHsgZGlzYWJsZVNjcm9sbExvY2s6IHRydWUgfSwgZGlzcGxheUVtcHR5OiB0cnVlLCBtdWx0aXBsZTogaXNNdWx0aVNlbGVjdEZpbHRlciwgcmVuZGVyVmFsdWU6IGlzTXVsdGlTZWxlY3RGaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChzZWxlY3RlZCkgPT4gIUFycmF5LmlzQXJyYXkoc2VsZWN0ZWQpIHx8IChzZWxlY3RlZCA9PT0gbnVsbCB8fCBzZWxlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWQubGVuZ3RoKSA9PT0gMCA/IChqc3goQm94LCB7IHN4OiB7IG9wYWNpdHk6IDAuNSB9LCBjaGlsZHJlbjogZmlsdGVyUGxhY2Vob2xkZXIgfSkpIDogKGpzeChCb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBmbGV4V3JhcDogJ3dyYXAnLCBnYXA6ICcycHgnIH0sIGNoaWxkcmVuOiBzZWxlY3RlZC5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gZHJvcGRvd25PcHRpb25zID09PSBudWxsIHx8IGRyb3Bkb3duT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJvcGRvd25PcHRpb25zLmZpbmQoKG9wdGlvbikgPT4gZ2V0VmFsdWVBbmRMYWJlbChvcHRpb24pLnZhbHVlID09PSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGpzeChDaGlwLCB7IGxhYmVsOiBnZXRWYWx1ZUFuZExhYmVsKHNlbGVjdGVkVmFsdWUpLmxhYmVsIH0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIChfeiA9IGNvbW1vblRleHRGaWVsZFByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX3ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF96LnNlbGVjdCkgfSksIG9uQ2hhbmdlOiBoYW5kbGVUZXh0RmllbGRDaGFuZ2UsIG9uQ2xpY2s6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLCB2YWx1ZTogaXNNdWx0aVNlbGVjdEZpbHRlclxuICAgICAgICAgICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoZmlsdGVyVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGZpbHRlclZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdXG4gICAgICAgICAgICAgICAgICAgIDogZmlsdGVyVmFsdWUsIGNoaWxkcmVuOiAoaXNTZWxlY3RGaWx0ZXIgfHwgaXNNdWx0aVNlbGVjdEZpbHRlcikgJiYgW1xuICAgICAgICAgICAgICAgICAgICBqc3goTWVudUl0ZW0sIHsgZGlzYWJsZWQ6IHRydWUsIGRpdmlkZXI6IHRydWUsIGhpZGRlbjogdHJ1ZSwgdmFsdWU6IFwiXCIsIGNoaWxkcmVuOiBqc3goQm94LCB7IHN4OiB7IG9wYWNpdHk6IDAuNSB9LCBjaGlsZHJlbjogZmlsdGVyUGxhY2Vob2xkZXIgfSkgfSwgXCJwXCIpLFxuICAgICAgICAgICAgICAgICAgICAuLi5bXG4gICAgICAgICAgICAgICAgICAgICAgICAoXzAgPSB0ZXh0RmllbGRQcm9wcy5jaGlsZHJlbikgIT09IG51bGwgJiYgXzAgIT09IHZvaWQgMCA/IF8wIDogZHJvcGRvd25PcHRpb25zID09PSBudWxsIHx8IGRyb3Bkb3duT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJvcGRvd25PcHRpb25zLm1hcCgob3B0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhYmVsLCB2YWx1ZSB9ID0gZ2V0VmFsdWVBbmRMYWJlbChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoanN4cyhNZW51SXRlbSwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdmFsdWU6IHZhbHVlLCBjaGlsZHJlbjogW2lzTXVsdGlTZWxlY3RGaWx0ZXIgJiYgKGpzeChDaGVja2JveCwgeyBjaGVja2VkOiAoKF9hID0gY29sdW1uLmdldEZpbHRlclZhbHVlKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5pbmNsdWRlcyh2YWx1ZSksIHN4OiB7IG1yOiAnMC41cmVtJyB9IH0pKSwgbGFiZWwsICcgJywgIWNvbHVtbkRlZi5maWx0ZXJTZWxlY3RPcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCgke2ZhY2V0ZWRVbmlxdWVWYWx1ZXMuZ2V0KHZhbHVlKX0pYF0gfSwgYCR7aW5kZXh9LSR7dmFsdWV9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXSB9KSkpLCBqc3goTVJUX0ZpbHRlck9wdGlvbk1lbnUsIHsgYW5jaG9yRWw6IGFuY2hvckVsLCBoZWFkZXI6IGhlYWRlciwgc2V0QW5jaG9yRWw6IHNldEFuY2hvckVsLCBzZXRGaWx0ZXJWYWx1ZTogc2V0RmlsdGVyVmFsdWUsIHRhYmxlOiB0YWJsZSB9KV0gfSkpO1xufTtcblxuY29uc3QgTVJUX0ZpbHRlclJhbmdlRmllbGRzID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgaGVhZGVyLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImhlYWRlclwiLCBcInRhYmxlXCJdKTtcbiAgICByZXR1cm4gKGpzeChCb3gsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBkaXNwbGF5OiAnZ3JpZCcsIGdhcDogJzFyZW0nLCBncmlkVGVtcGxhdGVDb2x1bW5zOiAnMWZyIDFmcicgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5zeCwgdGhlbWUpKSksIGNoaWxkcmVuOiBbMCwgMV0ubWFwKChyYW5nZUZpbHRlckluZGV4KSA9PiAoanN4KE1SVF9GaWx0ZXJUZXh0RmllbGQsIHsgaGVhZGVyOiBoZWFkZXIsIHJhbmdlRmlsdGVySW5kZXg6IHJhbmdlRmlsdGVySW5kZXgsIHRhYmxlOiB0YWJsZSB9LCByYW5nZUZpbHRlckluZGV4KSkpIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfRmlsdGVyUmFuZ2VTbGlkZXIgPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IGhlYWRlciwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJoZWFkZXJcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGVuYWJsZUNvbHVtbkZpbHRlck1vZGVzLCBsb2NhbGl6YXRpb24sIG11aUZpbHRlclNsaWRlclByb3BzIH0sIHJlZnM6IHsgZmlsdGVySW5wdXRSZWZzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGNvbHVtbiB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW47XG4gICAgY29uc3QgY3VycmVudEZpbHRlck9wdGlvbiA9IGNvbHVtbkRlZi5fZmlsdGVyRm47XG4gICAgY29uc3Qgc2hvd0NoYW5nZU1vZGVCdXR0b24gPSBlbmFibGVDb2x1bW5GaWx0ZXJNb2RlcyAmJiBjb2x1bW5EZWYuZW5hYmxlQ29sdW1uRmlsdGVyTW9kZXMgIT09IGZhbHNlO1xuICAgIGNvbnN0IHNsaWRlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlGaWx0ZXJTbGlkZXJQcm9wcywgeyBjb2x1bW4sIHRhYmxlIH0pKSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGNvbHVtbkRlZi5tdWlGaWx0ZXJTbGlkZXJQcm9wcywgeyBjb2x1bW4sIHRhYmxlIH0pKSwgcmVzdCk7XG4gICAgbGV0IFttaW4sIG1heF0gPSBzbGlkZXJQcm9wcy5taW4gIT09IHVuZGVmaW5lZCAmJiBzbGlkZXJQcm9wcy5tYXggIT09IHVuZGVmaW5lZFxuICAgICAgICA/IFtzbGlkZXJQcm9wcy5taW4sIHNsaWRlclByb3BzLm1heF1cbiAgICAgICAgOiAoKF9iID0gY29sdW1uLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogWzAsIDFdKTtcbiAgICAvL2ZpeCBwb3RlbnRpYWwgVGFuU3RhY2sgVGFibGUgYnVncyB3aGVyZSBtaW4gb3IgbWF4IGlzIGFuIGFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWluKSlcbiAgICAgICAgbWluID0gbWluWzBdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1heCkpXG4gICAgICAgIG1heCA9IG1heFswXTtcbiAgICBpZiAobWluID09PSBudWxsKVxuICAgICAgICBtaW4gPSAwO1xuICAgIGlmIChtYXggPT09IG51bGwpXG4gICAgICAgIG1heCA9IDE7XG4gICAgY29uc3QgW2ZpbHRlclZhbHVlcywgc2V0RmlsdGVyVmFsdWVzXSA9IHVzZVN0YXRlKFttaW4sIG1heF0pO1xuICAgIGNvbnN0IGNvbHVtbkZpbHRlclZhbHVlID0gY29sdW1uLmdldEZpbHRlclZhbHVlKCk7XG4gICAgY29uc3QgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBwcmV2ZW50IG1vdmluZyB0aGUgZm9jdXMgdG8gdGhlIG5leHQvcHJldiBjZWxsIHdoZW4gdXNpbmcgdGhlIGFycm93IGtleXNcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0xlZnQnIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uRmlsdGVyVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldEZpbHRlclZhbHVlcyhbbWluLCBtYXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uRmlsdGVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0RmlsdGVyVmFsdWVzKGNvbHVtbkZpbHRlclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfSwgW2NvbHVtbkZpbHRlclZhbHVlLCBtaW4sIG1heF0pO1xuICAgIHJldHVybiAoanN4cyhTdGFjaywgeyBjaGlsZHJlbjogW2pzeChTbGlkZXIsIE9iamVjdC5hc3NpZ24oeyBkaXNhYmxlU3dhcDogdHJ1ZSwgbWF4OiBtYXgsIG1pbjogbWluLCBvbkNoYW5nZTogKF9ldmVudCwgdmFsdWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZpbHRlclZhbHVlcyh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH0sIG9uQ2hhbmdlQ29tbWl0dGVkOiAoX2V2ZW50LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA8PSBtaW4gJiYgdmFsdWVbMV0gPj0gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlIGVudGlyZSByYW5nZSwgcmVtb3ZlIHRoZSBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBvbktleURvd246IGhhbmRsZUtleURvd24sIHZhbHVlOiBmaWx0ZXJWYWx1ZXMsIHZhbHVlTGFiZWxEaXNwbGF5OiBcImF1dG9cIiB9LCBzbGlkZXJQcm9wcywgeyBzbG90UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcklucHV0UmVmcy5jdXJyZW50W2Ake2NvbHVtbi5pZH0tMGBdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gc2xpZGVyUHJvcHMgPT09IG51bGwgfHwgc2xpZGVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsaWRlclByb3BzLnNsb3RQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlclByb3BzLnNsb3RQcm9wcy5pbnB1dC5yZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IG06ICdhdXRvJywgbWluV2lkdGg6IGAke2NvbHVtbi5nZXRTaXplKCkgLSA1MH1weGAsIG10OiAhc2hvd0NoYW5nZU1vZGVCdXR0b24gPyAnMTBweCcgOiAnNnB4JywgcHg6ICc0cHgnLCB3aWR0aDogJ2NhbGMoMTAwJSAtIDhweCknIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhzbGlkZXJQcm9wcyA9PT0gbnVsbCB8fCBzbGlkZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xpZGVyUHJvcHMuc3gsIHRoZW1lKSkpIH0pKSwgc2hvd0NoYW5nZU1vZGVCdXR0b24gPyAoanN4KEZvcm1IZWxwZXJUZXh0LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC43NXJlbScsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcwLjhyZW0nLFxuICAgICAgICAgICAgICAgICAgICBtOiAnLTNweCAtNnB4JyxcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5maWx0ZXJNb2RlLnJlcGxhY2UoJ3tmaWx0ZXJUeXBlfScsIGxvY2FsaXphdGlvbltgZmlsdGVyJHsoKF9jID0gY3VycmVudEZpbHRlck9wdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RmlsdGVyT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmlsdGVyT3B0aW9uLmNoYXJBdCgwKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvVXBwZXJDYXNlKCkpICtcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRGaWx0ZXJPcHRpb24gPT09IG51bGwgfHwgY3VycmVudEZpbHRlck9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZpbHRlck9wdGlvbi5zbGljZSgxKSl9YF0pIH0pKSA6IG51bGxdIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRDZWxsRmlsdGVyQ29udGFpbmVyID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgaGVhZGVyLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImhlYWRlclwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IHNob3dDb2x1bW5GaWx0ZXJzIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGlzUmFuZ2VGaWx0ZXIgfSA9IGdldENvbHVtbkZpbHRlckluZm8oeyBoZWFkZXIsIHRhYmxlIH0pO1xuICAgIHJldHVybiAoanN4KENvbGxhcHNlLCBPYmplY3QuYXNzaWduKHsgaW46IHNob3dDb2x1bW5GaWx0ZXJzIHx8IGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlID09PSAncG9wb3ZlcicsIG1vdW50T25FbnRlcjogdHJ1ZSwgdW5tb3VudE9uRXhpdDogdHJ1ZSB9LCByZXN0LCB7IGNoaWxkcmVuOiBjb2x1bW5EZWYuZmlsdGVyVmFyaWFudCA9PT0gJ2NoZWNrYm94JyA/IChqc3goTVJUX0ZpbHRlckNoZWNrYm94LCB7IGNvbHVtbjogY29sdW1uLCB0YWJsZTogdGFibGUgfSkpIDogY29sdW1uRGVmLmZpbHRlclZhcmlhbnQgPT09ICdyYW5nZS1zbGlkZXInID8gKGpzeChNUlRfRmlsdGVyUmFuZ2VTbGlkZXIsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSkgOiBpc1JhbmdlRmlsdGVyID8gKGpzeChNUlRfRmlsdGVyUmFuZ2VGaWVsZHMsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSkgOiAoanN4KE1SVF9GaWx0ZXJUZXh0RmllbGQsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSkgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRDZWxsRmlsdGVyTGFiZWwgPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgaGVhZGVyLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImhlYWRlclwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUsIGljb25zOiB7IEZpbHRlckFsdEljb24gfSwgbG9jYWxpemF0aW9uLCB9LCByZWZzOiB7IGZpbHRlcklucHV0UmVmcyB9LCBzZXRTaG93Q29sdW1uRmlsdGVycywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSgpO1xuICAgIGNvbnN0IFthbmNob3JFbCwgc2V0QW5jaG9yRWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyBjdXJyZW50RmlsdGVyT3B0aW9uLCBpc011bHRpU2VsZWN0RmlsdGVyLCBpc1JhbmdlRmlsdGVyLCBpc1NlbGVjdEZpbHRlciwgfSA9IGdldENvbHVtbkZpbHRlckluZm8oeyBoZWFkZXIsIHRhYmxlIH0pO1xuICAgIGNvbnN0IGRyb3Bkb3duT3B0aW9ucyA9IHVzZURyb3Bkb3duT3B0aW9ucyh7IGhlYWRlciwgdGFibGUgfSk7XG4gICAgY29uc3QgZ2V0U2VsZWN0TGFiZWwgPSAoaW5kZXgpID0+IGdldFZhbHVlQW5kTGFiZWwoZHJvcGRvd25PcHRpb25zID09PSBudWxsIHx8IGRyb3Bkb3duT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJvcGRvd25PcHRpb25zLmZpbmQoKG9wdGlvbikgPT4gZ2V0VmFsdWVBbmRMYWJlbChvcHRpb24pLnZhbHVlID09PVxuICAgICAgICAoaW5kZXggIT09IHVuZGVmaW5lZCA/IGZpbHRlclZhbHVlW2luZGV4XSA6IGZpbHRlclZhbHVlKSkpLmxhYmVsO1xuICAgIGNvbnN0IGlzRmlsdGVyQWN0aXZlID0gKEFycmF5LmlzQXJyYXkoZmlsdGVyVmFsdWUpICYmIGZpbHRlclZhbHVlLnNvbWUoQm9vbGVhbikpIHx8XG4gICAgICAgICghIWZpbHRlclZhbHVlICYmICFBcnJheS5pc0FycmF5KGZpbHRlclZhbHVlKSk7XG4gICAgY29uc3QgZmlsdGVyVG9vbHRpcCA9IGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlID09PSAncG9wb3ZlcicgJiYgIWlzRmlsdGVyQWN0aXZlXG4gICAgICAgID8gKF9iID0gbG9jYWxpemF0aW9uLmZpbHRlckJ5Q29sdW1uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgne2NvbHVtbn0nLCBTdHJpbmcoY29sdW1uRGVmLmhlYWRlcikpXG4gICAgICAgIDogbG9jYWxpemF0aW9uLmZpbHRlcmluZ0J5Q29sdW1uXG4gICAgICAgICAgICAucmVwbGFjZSgne2NvbHVtbn0nLCBTdHJpbmcoY29sdW1uRGVmLmhlYWRlcikpXG4gICAgICAgICAgICAucmVwbGFjZSgne2ZpbHRlclR5cGV9JywgY3VycmVudEZpbHRlck9wdGlvblxuICAgICAgICAgICAgPyBsb2NhbGl6YXRpb25bYGZpbHRlciR7Y3VycmVudEZpbHRlck9wdGlvbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgY3VycmVudEZpbHRlck9wdGlvbi5zbGljZSgxKX1gXVxuICAgICAgICAgICAgOiAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKCd7ZmlsdGVyVmFsdWV9JywgYFwiJHtBcnJheS5pc0FycmF5KGZpbHRlclZhbHVlKVxuICAgICAgICAgICAgPyBmaWx0ZXJWYWx1ZVxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaXNNdWx0aVNlbGVjdEZpbHRlciA/IGdldFNlbGVjdExhYmVsKGluZGV4KSA6IHZhbHVlKVxuICAgICAgICAgICAgICAgIC5qb2luKGBcIiAke2lzUmFuZ2VGaWx0ZXIgPyBsb2NhbGl6YXRpb24uYW5kIDogbG9jYWxpemF0aW9uLm9yfSBcImApXG4gICAgICAgICAgICA6IGlzU2VsZWN0RmlsdGVyXG4gICAgICAgICAgICAgICAgPyBnZXRTZWxlY3RMYWJlbCgpXG4gICAgICAgICAgICAgICAgOiBmaWx0ZXJWYWx1ZX1cImApXG4gICAgICAgICAgICAucmVwbGFjZSgnXCIgXCInLCAnJyk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KEdyb3csIHsgaW46IGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlID09PSAncG9wb3ZlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgKCEhZmlsdGVyVmFsdWUgJiYgIWlzUmFuZ2VGaWx0ZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc1JhbmdlRmlsdGVyICYmICghIShmaWx0ZXJWYWx1ZSA9PT0gbnVsbCB8fCBmaWx0ZXJWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyVmFsdWVbMF0pIHx8ICEhKGZpbHRlclZhbHVlID09PSBudWxsIHx8IGZpbHRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXJWYWx1ZVsxXSkpKSwgdW5tb3VudE9uRXhpdDogdHJ1ZSwgY2hpbGRyZW46IGpzeChCb3gsIHsgY29tcG9uZW50OiBcInNwYW5cIiwgc3g6IHsgZmxleDogJzAgMCcgfSwgY2hpbGRyZW46IGpzeChUb29sdGlwLCB7IHBsYWNlbWVudDogXCJ0b3BcIiwgdGl0bGU6IGZpbHRlclRvb2x0aXAsIGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7IGRpc2FibGVSaXBwbGU6IHRydWUsIG9uQ2xpY2s6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5jaG9yRWwoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTaG93Q29sdW1uRmlsdGVycyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IChfYSA9IGZpbHRlcklucHV0UmVmcy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYCR7Y29sdW1uLmlkfS0wYF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb2N1cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9mID0gKF9lID0gKF9kID0gZmlsdGVySW5wdXRSZWZzLmN1cnJlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFtgJHtjb2x1bW4uaWR9LTBgXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNlbGVjdCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2l6ZTogXCJzbWFsbFwiIH0sIHJlc3QsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBoZWlnaHQ6ICcxNnB4JywgbWw6ICc0cHgnLCBvcGFjaXR5OiBpc0ZpbHRlckFjdGl2ZSA/IDEgOiAwLjMsIHA6ICc4cHgnLCB0cmFuc2Zvcm06ICdzY2FsZSgwLjc1KScsIHRyYW5zaXRpb246ICdhbGwgMTUwbXMgZWFzZS1pbi1vdXQnLCB3aWR0aDogJzE2cHgnIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhyZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3Quc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjoganN4KEZpbHRlckFsdEljb24sIHt9KSB9KSkgfSkgfSkgfSksIGNvbHVtbkZpbHRlckRpc3BsYXlNb2RlID09PSAncG9wb3ZlcicgJiYgKGpzeChQb3BvdmVyLCB7IGFuY2hvckVsOiBhbmNob3JFbCwgYW5jaG9yT3JpZ2luOiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWw6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgICAgICAgICAgICAgfSwgZGlzYWJsZVNjcm9sbExvY2s6IHRydWUsIG9uQ2xpY2s6IChldmVudCkgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIG9uQ2xvc2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEFuY2hvckVsKG51bGwpO1xuICAgICAgICAgICAgICAgIH0sIG9uS2V5RG93bjogKGV2ZW50KSA9PiBldmVudC5rZXkgPT09ICdFbnRlcicgJiYgc2V0QW5jaG9yRWwobnVsbCksIG9wZW46ICEhYW5jaG9yRWwsIHNsb3RQcm9wczogeyBwYXBlcjogeyBzeDogeyBvdmVyZmxvdzogJ3Zpc2libGUnIH0gfSB9LCB0cmFuc2Zvcm1PcmlnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjoganN4KEJveCwgeyBzeDogeyBwOiAnMXJlbScgfSwgY2hpbGRyZW46IGpzeChNUlRfVGFibGVIZWFkQ2VsbEZpbHRlckNvbnRhaW5lciwgeyBoZWFkZXI6IGhlYWRlciwgdGFibGU6IHRhYmxlIH0pIH0pIH0pKV0gfSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlSGVhZENlbGxHcmFiSGFuZGxlID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgY29sdW1uLCB0YWJsZSwgdGFibGVIZWFkQ2VsbFJlZiB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNvbHVtblwiLCBcInRhYmxlXCIsIFwidGFibGVIZWFkQ2VsbFJlZlwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVDb2x1bW5PcmRlcmluZywgbXVpQ29sdW1uRHJhZ0hhbmRsZVByb3BzIH0sIHNldENvbHVtbk9yZGVyLCBzZXRDb2x1bW5QaW5uaW5nLCBzZXREcmFnZ2luZ0NvbHVtbiwgc2V0SG92ZXJlZENvbHVtbiwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmIH0gPSBjb2x1bW47XG4gICAgY29uc3QgeyBjb2x1bW5PcmRlciwgZHJhZ2dpbmdDb2x1bW4sIGhvdmVyZWRDb2x1bW4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaWNvbkJ1dHRvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlDb2x1bW5EcmFnSGFuZGxlUHJvcHMsIHsgY29sdW1uLCB0YWJsZSB9KSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpQ29sdW1uRHJhZ0hhbmRsZVByb3BzLCB7XG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBpY29uQnV0dG9uUHJvcHMgPT09IG51bGwgfHwgaWNvbkJ1dHRvblByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uQnV0dG9uUHJvcHMub25EcmFnU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGljb25CdXR0b25Qcm9wcywgZXZlbnQpO1xuICAgICAgICBzZXREcmFnZ2luZ0NvbHVtbihjb2x1bW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSh0YWJsZUhlYWRDZWxsUmVmLmN1cnJlbnQsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gaWNvbkJ1dHRvblByb3BzID09PSBudWxsIHx8IGljb25CdXR0b25Qcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWNvbkJ1dHRvblByb3BzLm9uRHJhZ0VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaWNvbkJ1dHRvblByb3BzLCBldmVudCk7XG4gICAgICAgIGlmICgoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gJ2Ryb3Atem9uZScpIHtcbiAgICAgICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuYWJsZUNvbHVtbk9yZGVyaW5nICYmXG4gICAgICAgICAgICBob3ZlcmVkQ29sdW1uICYmXG4gICAgICAgICAgICAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSAhPT0gKGRyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlb3JkZXJlZENvbHVtbnMgPSByZW9yZGVyQ29sdW1uKGNvbHVtbiwgaG92ZXJlZENvbHVtbiwgY29sdW1uT3JkZXIpO1xuICAgICAgICAgICAgc2V0Q29sdW1uT3JkZXIocmVvcmRlcmVkQ29sdW1ucyk7XG4gICAgICAgICAgICBzZXRDb2x1bW5QaW5uaW5nKCh7IGxlZnQgPSBbXSwgcmlnaHQgPSBbXSB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHJlb3JkZXJlZENvbHVtbnMuZmlsdGVyKGhlYWRlciA9PiBsZWZ0LmluY2x1ZGVzKGhlYWRlcikpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByZW9yZGVyZWRDb2x1bW5zLmZpbHRlcihoZWFkZXIgPT4gcmlnaHQuaW5jbHVkZXMoaGVhZGVyKSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RHJhZ2dpbmdDb2x1bW4obnVsbCk7XG4gICAgICAgIHNldEhvdmVyZWRDb2x1bW4obnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChNUlRfR3JhYkhhbmRsZUJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7fSwgaWNvbkJ1dHRvblByb3BzLCB7IG9uRHJhZ0VuZDogaGFuZGxlRHJhZ0VuZCwgb25EcmFnU3RhcnQ6IGhhbmRsZURyYWdTdGFydCwgdGFibGU6IHRhYmxlIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVIZWFkQ2VsbFJlc2l6ZUhhbmRsZSA9IChfYSkgPT4ge1xuICAgIHZhciBfYjtcbiAgICB2YXIgeyBoZWFkZXIsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiaGVhZGVyXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uUmVzaXplRGlyZWN0aW9uLCBjb2x1bW5SZXNpemVNb2RlIH0sIHNldENvbHVtblNpemluZ0luZm8sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHkgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCBoYW5kbGVyID0gaGVhZGVyLmdldFJlc2l6ZUhhbmRsZXIoKTtcbiAgICBjb25zdCBteCA9IGRlbnNpdHkgPT09ICdjb21wYWN0J1xuICAgICAgICA/ICctOHB4J1xuICAgICAgICA6IGRlbnNpdHkgPT09ICdjb21mb3J0YWJsZSdcbiAgICAgICAgICAgID8gJy0xNnB4J1xuICAgICAgICAgICAgOiAnLTI0cHgnO1xuICAgIGNvbnN0IGxyID0gY29sdW1uLmNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlID09PSAnZGlzcGxheScgPyAnNHB4JyA6ICcwJztcbiAgICByZXR1cm4gKGpzeChCb3gsIHsgY2xhc3NOYW1lOiBcIk11aS1UYWJsZUhlYWRDZWxsLVJlc2l6ZUhhbmRsZS1XcmFwcGVyXCIsIG9uRG91YmxlQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHNldENvbHVtblNpemluZ0luZm8oKG9sZCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkKSwgeyBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSB9KSkpO1xuICAgICAgICAgICAgY29sdW1uLnJlc2V0U2l6ZSgpO1xuICAgICAgICB9LCBvbk1vdXNlRG93bjogaGFuZGxlciwgb25Ub3VjaFN0YXJ0OiBoYW5kbGVyLCBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBjb2x1bW4uZ2V0SXNSZXNpemluZygpICYmIGNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkVuZCdcbiAgICAgICAgICAgICAgICA/IGB0cmFuc2xhdGVYKCR7KGNvbHVtblJlc2l6ZURpcmVjdGlvbiA9PT0gJ3J0bCcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IGdldFN0YXRlKCkuY29sdW1uU2l6aW5nSW5mby5kZWx0YU9mZnNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCl9cHgpYFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCBzeDogKHRoZW1lKSA9PiAoe1xuICAgICAgICAgICAgJyY6YWN0aXZlID4gaHInOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmluZm8ubWFpbixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGggfHwgY29sdW1uUmVzaXplTW9kZSA9PT0gJ29uRW5kJyA/IDEgOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnNvcjogJ2NvbC1yZXNpemUnLFxuICAgICAgICAgICAgbGVmdDogY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IGxyIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWw6IGNvbHVtblJlc2l6ZURpcmVjdGlvbiA9PT0gJ3J0bCcgPyBteCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1yOiBjb2x1bW5SZXNpemVEaXJlY3Rpb24gPT09ICdsdHInID8gbXggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHB4OiAnNHB4JyxcbiAgICAgICAgICAgIHJpZ2h0OiBjb2x1bW5SZXNpemVEaXJlY3Rpb24gPT09ICdsdHInID8gbHIgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pLCBjaGlsZHJlbjoganN4KERpdmlkZXIsIHsgY2xhc3NOYW1lOiBcIk11aS1UYWJsZUhlYWRDZWxsLVJlc2l6ZUhhbmRsZS1EaXZpZGVyXCIsIGZsZXhJdGVtOiB0cnVlLCBvcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGJvcmRlclJhZGl1czogJzJweCcsIGJvcmRlcldpZHRoOiAnMnB4JywgaGVpZ2h0OiAnMjRweCcsIHRvdWNoQWN0aW9uOiAnbm9uZScsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoNHB4KScsIHRyYW5zaXRpb246IGNvbHVtbi5nZXRJc1Jlc2l6aW5nKClcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiAnYWxsIDE1MG1zIGVhc2UtaW4tb3V0JywgdXNlclNlbGVjdDogJ25vbmUnLCB6SW5kZXg6IDQgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5zeCwgdGhlbWUpKSkgfSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlSGVhZENlbGxTb3J0TGFiZWwgPSAoX2EpID0+IHtcbiAgICB2YXIgeyBoZWFkZXIsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiaGVhZGVyXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgQXJyb3dEb3dud2FyZEljb24sIFN5bmNBbHRJY29uIH0sIGxvY2FsaXphdGlvbiwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCB7IGlzTG9hZGluZywgc2hvd1NrZWxldG9ucywgc29ydGluZyB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc1NvcnRlZCA9ICEhY29sdW1uLmdldElzU29ydGVkKCk7XG4gICAgY29uc3Qgc29ydFRvb2x0aXAgPSBpc0xvYWRpbmcgfHwgc2hvd1NrZWxldG9uc1xuICAgICAgICA/ICcnXG4gICAgICAgIDogY29sdW1uLmdldElzU29ydGVkKClcbiAgICAgICAgICAgID8gY29sdW1uLmdldElzU29ydGVkKCkgPT09ICdkZXNjJ1xuICAgICAgICAgICAgICAgID8gbG9jYWxpemF0aW9uLnNvcnRlZEJ5Q29sdW1uRGVzYy5yZXBsYWNlKCd7Y29sdW1ufScsIGNvbHVtbkRlZi5oZWFkZXIpXG4gICAgICAgICAgICAgICAgOiBsb2NhbGl6YXRpb24uc29ydGVkQnlDb2x1bW5Bc2MucmVwbGFjZSgne2NvbHVtbn0nLCBjb2x1bW5EZWYuaGVhZGVyKVxuICAgICAgICAgICAgOiBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlcigpID09PSAnZGVzYydcbiAgICAgICAgICAgICAgICA/IGxvY2FsaXphdGlvbi5zb3J0QnlDb2x1bW5EZXNjLnJlcGxhY2UoJ3tjb2x1bW59JywgY29sdW1uRGVmLmhlYWRlcilcbiAgICAgICAgICAgICAgICA6IGxvY2FsaXphdGlvbi5zb3J0QnlDb2x1bW5Bc2MucmVwbGFjZSgne2NvbHVtbn0nLCBjb2x1bW5EZWYuaGVhZGVyKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBpc1NvcnRlZFxuICAgICAgICA/IGNvbHVtbi5nZXRJc1NvcnRlZCgpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiAoanN4KFRvb2x0aXAsIHsgcGxhY2VtZW50OiBcInRvcFwiLCB0aXRsZTogc29ydFRvb2x0aXAsIGNoaWxkcmVuOiBqc3goQmFkZ2UsIHsgYmFkZ2VDb250ZW50OiBzb3J0aW5nLmxlbmd0aCA+IDEgPyBjb2x1bW4uZ2V0U29ydEluZGV4KCkgKyAxIDogMCwgb3ZlcmxhcDogXCJjaXJjdWxhclwiLCBjaGlsZHJlbjoganN4KFRhYmxlU29ydExhYmVsLCBPYmplY3QuYXNzaWduKHsgSWNvbkNvbXBvbmVudDogIWlzU29ydGVkXG4gICAgICAgICAgICAgICAgICAgID8gKHByb3BzKSA9PiAoanN4KFN5bmNBbHRJY29uLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBkaXJlY3Rpb246IGRpcmVjdGlvbiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTkwZGVnKSBzY2FsZVgoMC45KSB0cmFuc2xhdGVYKC0xcHgpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpKVxuICAgICAgICAgICAgICAgICAgICA6IEFycm93RG93bndhcmRJY29uLCBhY3RpdmU6IHRydWUsIFwiYXJpYS1sYWJlbFwiOiBzb3J0VG9vbHRpcCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaGVhZGVyLmNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoZSk7XG4gICAgICAgICAgICAgICAgfSB9LCByZXN0LCB7IHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgJy5NdWlUYWJsZVNvcnRMYWJlbC1pY29uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGAke3RoZW1lLnBhbGV0dGUubW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGVtZS5wYWxldHRlLnRleHQucHJpbWFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhlbWUucGFsZXR0ZS50ZXh0LnNlY29uZGFyeX0gIWltcG9ydGFudGAsXG4gICAgICAgICAgICAgICAgICAgIH0sIGZsZXg6ICcwIDAnLCBvcGFjaXR5OiBpc1NvcnRlZCA/IDEgOiAwLjMsIHRyYW5zaXRpb246ICdhbGwgMTUwbXMgZWFzZS1pbi1vdXQnLCB3aWR0aDogJzNjaCcgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5zeCwgdGhlbWUpKSkgfSkpIH0pIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWRDZWxsID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iLCBfYywgX2QsIF9mLCBfZywgX2gsIF9qO1xuICAgIHZhciB7IGNvbHVtblZpcnR1YWxpemVyLCBoZWFkZXIsIHN0YXRpY0NvbHVtbkluZGV4LCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNvbHVtblZpcnR1YWxpemVyXCIsIFwiaGVhZGVyXCIsIFwic3RhdGljQ29sdW1uSW5kZXhcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUsIGNvbHVtblJlc2l6ZURpcmVjdGlvbiwgY29sdW1uUmVzaXplTW9kZSwgZW5hYmxlS2V5Ym9hcmRTaG9ydGN1dHMsIGVuYWJsZUNvbHVtbkFjdGlvbnMsIGVuYWJsZUNvbHVtbkRyYWdnaW5nLCBlbmFibGVDb2x1bW5PcmRlcmluZywgZW5hYmxlQ29sdW1uUGlubmluZywgZW5hYmxlR3JvdXBpbmcsIGVuYWJsZU11bHRpU29ydCwgbGF5b3V0TW9kZSwgbXJ0VGhlbWU6IHsgZHJhZ2dpbmdCb3JkZXJDb2xvciB9LCBtdWlUYWJsZUhlYWRDZWxsUHJvcHMsIH0sIHJlZnM6IHsgdGFibGVIZWFkQ2VsbFJlZnMgfSwgc2V0SG92ZXJlZENvbHVtbiwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uU2l6aW5nSW5mbywgZGVuc2l0eSwgZHJhZ2dpbmdDb2x1bW4sIGdyb3VwaW5nLCBob3ZlcmVkQ29sdW1uLCBzaG93Q29sdW1uRmlsdGVycywgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGhlYWRlcjtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmVHlwZSB9ID0gY29sdW1uRGVmO1xuICAgIGNvbnN0IHRhYmxlQ2VsbFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlUYWJsZUhlYWRDZWxsUHJvcHMsIHsgY29sdW1uLCB0YWJsZSB9KSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhjb2x1bW5EZWYubXVpVGFibGVIZWFkQ2VsbFByb3BzLCB7XG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICBjb25zdCBpc0NvbHVtblBpbm5lZCA9IGVuYWJsZUNvbHVtblBpbm5pbmcgJiZcbiAgICAgICAgY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgIT09ICdncm91cCcgJiZcbiAgICAgICAgY29sdW1uLmdldElzUGlubmVkKCk7XG4gICAgY29uc3Qgc2hvd0NvbHVtbkFjdGlvbnMgPSAoZW5hYmxlQ29sdW1uQWN0aW9ucyB8fCBjb2x1bW5EZWYuZW5hYmxlQ29sdW1uQWN0aW9ucykgJiZcbiAgICAgICAgY29sdW1uRGVmLmVuYWJsZUNvbHVtbkFjdGlvbnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IHNob3dEcmFnSGFuZGxlID0gZW5hYmxlQ29sdW1uRHJhZ2dpbmcgIT09IGZhbHNlICYmXG4gICAgICAgIGNvbHVtbkRlZi5lbmFibGVDb2x1bW5EcmFnZ2luZyAhPT0gZmFsc2UgJiZcbiAgICAgICAgKGVuYWJsZUNvbHVtbkRyYWdnaW5nIHx8XG4gICAgICAgICAgICAoZW5hYmxlQ29sdW1uT3JkZXJpbmcgJiYgY29sdW1uRGVmLmVuYWJsZUNvbHVtbk9yZGVyaW5nICE9PSBmYWxzZSkgfHxcbiAgICAgICAgICAgIChlbmFibGVHcm91cGluZyAmJlxuICAgICAgICAgICAgICAgIGNvbHVtbkRlZi5lbmFibGVHcm91cGluZyAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAhZ3JvdXBpbmcuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgIGNvbnN0IGhlYWRlclBMID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBwbCA9IDA7XG4gICAgICAgIGlmIChjb2x1bW4uZ2V0Q2FuU29ydCgpKVxuICAgICAgICAgICAgcGwgKz0gMTtcbiAgICAgICAgaWYgKHNob3dDb2x1bW5BY3Rpb25zKVxuICAgICAgICAgICAgcGwgKz0gMS43NTtcbiAgICAgICAgaWYgKHNob3dEcmFnSGFuZGxlKVxuICAgICAgICAgICAgcGwgKz0gMS41O1xuICAgICAgICByZXR1cm4gcGw7XG4gICAgfSwgW3Nob3dDb2x1bW5BY3Rpb25zLCBzaG93RHJhZ0hhbmRsZV0pO1xuICAgIGNvbnN0IGRyYWdnaW5nQm9yZGVycyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzaG93UmVzaXplQm9yZGVyID0gY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uID09PSBjb2x1bW4uaWQgJiZcbiAgICAgICAgICAgIGNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkNoYW5nZScgJiZcbiAgICAgICAgICAgICFoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJvcmRlclN0eWxlID0gc2hvd1Jlc2l6ZUJvcmRlclxuICAgICAgICAgICAgPyBgMnB4IHNvbGlkICR7ZHJhZ2dpbmdCb3JkZXJDb2xvcn0gIWltcG9ydGFudGBcbiAgICAgICAgICAgIDogKGRyYWdnaW5nQ29sdW1uID09PSBudWxsIHx8IGRyYWdnaW5nQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnZ2luZ0NvbHVtbi5pZCkgPT09IGNvbHVtbi5pZFxuICAgICAgICAgICAgICAgID8gYDFweCBkYXNoZWQgJHt0aGVtZS5wYWxldHRlLmdyZXlbNTAwXX1gXG4gICAgICAgICAgICAgICAgOiAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gY29sdW1uLmlkXG4gICAgICAgICAgICAgICAgICAgID8gYDJweCBkYXNoZWQgJHtkcmFnZ2luZ0JvcmRlckNvbG9yfWBcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzaG93UmVzaXplQm9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAnbHRyJ1xuICAgICAgICAgICAgICAgID8geyBib3JkZXJSaWdodDogYm9yZGVyU3R5bGUgfVxuICAgICAgICAgICAgICAgIDogeyBib3JkZXJMZWZ0OiBib3JkZXJTdHlsZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyYWdnaW5nQm9yZGVycyA9IGJvcmRlclN0eWxlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJTdHlsZSxcbiAgICAgICAgICAgICAgICBib3JkZXJSaWdodDogYm9yZGVyU3R5bGUsXG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBib3JkZXJTdHlsZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZHJhZ2dpbmdCb3JkZXJzO1xuICAgIH0sIFtkcmFnZ2luZ0NvbHVtbiwgaG92ZXJlZENvbHVtbiwgY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uXSk7XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKF9lKSA9PiB7XG4gICAgICAgIGlmIChlbmFibGVHcm91cGluZyAmJiAoaG92ZXJlZENvbHVtbiA9PT0gbnVsbCB8fCBob3ZlcmVkQ29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3ZlcmVkQ29sdW1uLmlkKSA9PT0gJ2Ryb3Atem9uZScpIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRDb2x1bW4obnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUNvbHVtbk9yZGVyaW5nICYmIGRyYWdnaW5nQ29sdW1uICYmIGNvbHVtbkRlZlR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRDb2x1bW4oY29sdW1uRGVmLmVuYWJsZUNvbHVtbk9yZGVyaW5nICE9PSBmYWxzZSA/IGNvbHVtbiA6IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IChlKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5EZWYuZW5hYmxlQ29sdW1uT3JkZXJpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMub25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YWJsZUNlbGxQcm9wcywgZXZlbnQpO1xuICAgICAgICBjZWxsS2V5Ym9hcmRTaG9ydGN1dHMoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBjZWxsVmFsdWU6IGhlYWRlci5jb2x1bW4uY29sdW1uRGVmLmhlYWRlcixcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IEhlYWRlckVsZW1lbnQgPSAoX2IgPSBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLkhlYWRlciwge1xuICAgICAgICBjb2x1bW4sXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgdGFibGUsXG4gICAgfSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbHVtbkRlZi5oZWFkZXI7XG4gICAgcmV0dXJuIChqc3hzKFRhYmxlQ2VsbCwgT2JqZWN0LmFzc2lnbih7IGFsaWduOiBjb2x1bW5EZWZUeXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/ICdjZW50ZXInXG4gICAgICAgICAgICA6IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgICAgICAgICAgICAgICA/ICdyaWdodCdcbiAgICAgICAgICAgICAgICA6ICdsZWZ0JywgXCJhcmlhLXNvcnRcIjogY29sdW1uLmdldElzU29ydGVkKClcbiAgICAgICAgICAgID8gY29sdW1uLmdldElzU29ydGVkKCkgPT09ICdhc2MnXG4gICAgICAgICAgICAgICAgPyAnYXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIDogJ2Rlc2NlbmRpbmcnXG4gICAgICAgICAgICA6ICdub25lJywgY29sU3BhbjogaGVhZGVyLmNvbFNwYW4sIFwiZGF0YS1jYW4tc29ydFwiOiBjb2x1bW4uZ2V0Q2FuU29ydCgpIHx8IHVuZGVmaW5lZCwgXCJkYXRhLWluZGV4XCI6IHN0YXRpY0NvbHVtbkluZGV4LCBcImRhdGEtcGlubmVkXCI6ICEhaXNDb2x1bW5QaW5uZWQgfHwgdW5kZWZpbmVkLCBcImRhdGEtc29ydFwiOiBjb2x1bW4uZ2V0SXNTb3J0ZWQoKSB8fCB1bmRlZmluZWQsIG9uRHJhZ0VudGVyOiBoYW5kbGVEcmFnRW50ZXIsIG9uRHJhZ092ZXI6IGhhbmRsZURyYWdPdmVyLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRhYmxlSGVhZENlbGxSZWZzLmN1cnJlbnRbY29sdW1uLmlkXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbkRlZlR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gY29sdW1uVmlydHVhbGl6ZXIgPT09IG51bGwgfHwgY29sdW1uVmlydHVhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtblZpcnR1YWxpemVyLm1lYXN1cmVFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb2x1bW5WaXJ0dWFsaXplciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0YWJJbmRleDogZW5hYmxlS2V5Ym9hcmRTaG9ydGN1dHMgPyAwIDogdW5kZWZpbmVkIH0sIHRhYmxlQ2VsbFByb3BzLCB7IG9uS2V5RG93bjogaGFuZGxlS2V5RG93biwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7ICcmIDpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICAnLk11aUJ1dHRvbkJhc2Utcm9vdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgZmxleERpcmVjdGlvbjogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2NvbHVtbicgOiB1bmRlZmluZWQsIGZvbnRXZWlnaHQ6ICdib2xkJywgb3ZlcmZsb3c6ICd2aXNpYmxlJywgcDogZGVuc2l0eSA9PT0gJ2NvbXBhY3QnXG4gICAgICAgICAgICAgICAgPyAnMC41cmVtJ1xuICAgICAgICAgICAgICAgIDogZGVuc2l0eSA9PT0gJ2NvbWZvcnRhYmxlJ1xuICAgICAgICAgICAgICAgICAgICA/IGNvbHVtbkRlZlR5cGUgPT09ICdkaXNwbGF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnMC43NXJlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJzFyZW0nXG4gICAgICAgICAgICAgICAgICAgIDogY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcxcmVtIDEuMjVyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcxLjVyZW0nLCBwYjogY29sdW1uRGVmVHlwZSA9PT0gJ2Rpc3BsYXknXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiBzaG93Q29sdW1uRmlsdGVycyB8fCBkZW5zaXR5ID09PSAnY29tcGFjdCdcbiAgICAgICAgICAgICAgICAgICAgPyAnMC40cmVtJ1xuICAgICAgICAgICAgICAgICAgICA6ICcwLjZyZW0nLCBwdDogY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJyB8fCBkZW5zaXR5ID09PSAnY29tcGFjdCdcbiAgICAgICAgICAgICAgICA/ICcwLjI1cmVtJ1xuICAgICAgICAgICAgICAgIDogZGVuc2l0eSA9PT0gJ2NvbWZvcnRhYmxlJ1xuICAgICAgICAgICAgICAgICAgICA/ICcuNzVyZW0nXG4gICAgICAgICAgICAgICAgICAgIDogJzEuMjVyZW0nLCB1c2VyU2VsZWN0OiBlbmFibGVNdWx0aVNvcnQgJiYgY29sdW1uLmdldENhblNvcnQoKSA/ICdub25lJyA6IHVuZGVmaW5lZCwgdmVydGljYWxBbGlnbjogJ3RvcCcgfSwgZ2V0Q29tbW9uTVJUQ2VsbFN0eWxlcyh7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHRhYmxlQ2VsbFByb3BzLFxuICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgIH0pKSwgZHJhZ2dpbmdCb3JkZXJzKSksIGNoaWxkcmVuOiBbaGVhZGVyLmlzUGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6ICgoX2MgPSB0YWJsZUNlbGxQcm9wcy5jaGlsZHJlbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKGpzeHMoQm94LCB7IGNsYXNzTmFtZTogXCJNdWktVGFibGVIZWFkQ2VsbC1Db250ZW50XCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICh0YWJsZUNlbGxQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZUNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDZWxsUHJvcHMuYWxpZ24pID09PSAncmlnaHQnID8gJ3Jvdy1yZXZlcnNlJyA6ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IGNvbHVtbkRlZlR5cGUgPT09ICdncm91cCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLmFsaWduKSA9PT0gJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdjZW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb2x1bW4uZ2V0Q2FuUmVzaXplKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3BhY2UtYmV0d2VlbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZmxleC1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbanN4cyhCb3gsIHsgY2xhc3NOYW1lOiBcIk11aS1UYWJsZUhlYWRDZWxsLUNvbnRlbnQtTGFiZWxzXCIsIG9uQ2xpY2s6IGNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlcigpLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBjb2x1bW4uZ2V0Q2FuU29ydCgpICYmIGNvbHVtbkRlZlR5cGUgIT09ICdncm91cCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAodGFibGVDZWxsUHJvcHMgPT09IG51bGwgfHwgdGFibGVDZWxsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ2VsbFByb3BzLmFsaWduKSA9PT0gJ3JpZ2h0JyA/ICdyb3ctcmV2ZXJzZScgOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGNvbHVtbkRlZlR5cGUgPT09ICdkYXRhJyA/ICdoaWRkZW4nIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbDogKHRhYmxlQ2VsbFByb3BzID09PSBudWxsIHx8IHRhYmxlQ2VsbFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZUNlbGxQcm9wcy5hbGlnbikgPT09ICdjZW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAke2hlYWRlclBMfXJlbWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbanN4KEJveCwgeyBjbGFzc05hbWU6IFwiTXVpLVRhYmxlSGVhZENlbGwtQ29udGVudC1XcmFwcGVyXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2NsaXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGAke01hdGgubWluKChfZiA9IChfZCA9IGNvbHVtbkRlZi5oZWFkZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDAsIDQpfWNoYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogY29sdW1uRGVmVHlwZSA9PT0gJ2RhdGEnID8gJ2hpZGRlbicgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICgoX2ggPSAoX2cgPSBjb2x1bW5EZWYuaGVhZGVyKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubGVuZ3RoKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAwKSA8IDIwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ25vd3JhcCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBIZWFkZXJFbGVtZW50IH0pLCBjb2x1bW4uZ2V0Q2FuRmlsdGVyKCkgJiYgKGpzeChNUlRfVGFibGVIZWFkQ2VsbEZpbHRlckxhYmVsLCB7IGhlYWRlcjogaGVhZGVyLCB0YWJsZTogdGFibGUgfSkpLCBjb2x1bW4uZ2V0Q2FuU29ydCgpICYmIChqc3goTVJUX1RhYmxlSGVhZENlbGxTb3J0TGFiZWwsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSldIH0pLCBjb2x1bW5EZWZUeXBlICE9PSAnZ3JvdXAnICYmIChqc3hzKEJveCwgeyBjbGFzc05hbWU6IFwiTXVpLVRhYmxlSGVhZENlbGwtQ29udGVudC1BY3Rpb25zXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbc2hvd0RyYWdIYW5kbGUgJiYgKGpzeChNUlRfVGFibGVIZWFkQ2VsbEdyYWJIYW5kbGUsIHsgY29sdW1uOiBjb2x1bW4sIHRhYmxlOiB0YWJsZSwgdGFibGVIZWFkQ2VsbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IChfaiA9IHRhYmxlSGVhZENlbGxSZWZzLmN1cnJlbnQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaltjb2x1bW4uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSksIHNob3dDb2x1bW5BY3Rpb25zICYmIChqc3goTVJUX1RhYmxlSGVhZENlbGxDb2x1bW5BY3Rpb25zQnV0dG9uLCB7IGhlYWRlcjogaGVhZGVyLCB0YWJsZTogdGFibGUgfSkpXSB9KSksIGNvbHVtbi5nZXRDYW5SZXNpemUoKSAmJiAoanN4KE1SVF9UYWJsZUhlYWRDZWxsUmVzaXplSGFuZGxlLCB7IGhlYWRlcjogaGVhZGVyLCB0YWJsZTogdGFibGUgfSkpXSB9KSkpLCBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSA9PT0gJ3N1YmhlYWRlcicgJiYgY29sdW1uLmdldENhbkZpbHRlcigpICYmIChqc3goTVJUX1RhYmxlSGVhZENlbGxGaWx0ZXJDb250YWluZXIsIHsgaGVhZGVyOiBoZWFkZXIsIHRhYmxlOiB0YWJsZSB9KSldIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVIZWFkUm93ID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgY29sdW1uVmlydHVhbGl6ZXIsIGhlYWRlckdyb3VwLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNvbHVtblZpcnR1YWxpemVyXCIsIFwiaGVhZGVyR3JvdXBcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBvcHRpb25zOiB7IGVuYWJsZVN0aWNreUhlYWRlciwgbGF5b3V0TW9kZSwgbXJ0VGhlbWU6IHsgYmFzZUJhY2tncm91bmRDb2xvciB9LCBtdWlUYWJsZUhlYWRSb3dQcm9wcywgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgdmlydHVhbENvbHVtbnMsIHZpcnR1YWxQYWRkaW5nTGVmdCwgdmlydHVhbFBhZGRpbmdSaWdodCB9ID0gY29sdW1uVmlydHVhbGl6ZXIgIT09IG51bGwgJiYgY29sdW1uVmlydHVhbGl6ZXIgIT09IHZvaWQgMCA/IGNvbHVtblZpcnR1YWxpemVyIDoge307XG4gICAgY29uc3QgdGFibGVSb3dQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRhYmxlSGVhZFJvd1Byb3BzLCB7XG4gICAgICAgIGhlYWRlckdyb3VwLFxuICAgICAgICB0YWJsZSxcbiAgICB9KSksIHJlc3QpO1xuICAgIHJldHVybiAoanN4cyhUYWJsZVJvdywgT2JqZWN0LmFzc2lnbih7fSwgdGFibGVSb3dQcm9wcywgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGJhY2tncm91bmRDb2xvcjogYmFzZUJhY2tncm91bmRDb2xvciwgYm94U2hhZG93OiBgNHB4IDAgOHB4ICR7YWxwaGEodGhlbWUucGFsZXR0ZS5jb21tb24uYmxhY2ssIDAuMSl9YCwgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2ZsZXgnIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogZW5hYmxlU3RpY2t5SGVhZGVyICYmIGxheW91dE1vZGUgPT09ICdzZW1hbnRpYydcbiAgICAgICAgICAgICAgICA/ICdzdGlja3knXG4gICAgICAgICAgICAgICAgOiAncmVsYXRpdmUnLCB0b3A6IDAgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHRhYmxlUm93UHJvcHMgPT09IG51bGwgfHwgdGFibGVSb3dQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVSb3dQcm9wcy5zeCwgdGhlbWUpKSksIGNoaWxkcmVuOiBbdmlydHVhbFBhZGRpbmdMZWZ0ID8gKGpzeChcInRoXCIsIHsgc3R5bGU6IHsgZGlzcGxheTogJ2ZsZXgnLCB3aWR0aDogdmlydHVhbFBhZGRpbmdMZWZ0IH0gfSkpIDogbnVsbCwgKHZpcnR1YWxDb2x1bW5zICE9PSBudWxsICYmIHZpcnR1YWxDb2x1bW5zICE9PSB2b2lkIDAgPyB2aXJ0dWFsQ29sdW1ucyA6IGhlYWRlckdyb3VwLmhlYWRlcnMpLm1hcCgoaGVhZGVyT3JWaXJ0dWFsSGVhZGVyLCBzdGF0aWNDb2x1bW5JbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSBoZWFkZXJPclZpcnR1YWxIZWFkZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtblZpcnR1YWxpemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NvbHVtbkluZGV4ID0gaGVhZGVyT3JWaXJ0dWFsSGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IGhlYWRlckdyb3VwLmhlYWRlcnNbc3RhdGljQ29sdW1uSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyID8gKGpzeChNUlRfVGFibGVIZWFkQ2VsbCwgeyBjb2x1bW5WaXJ0dWFsaXplcjogY29sdW1uVmlydHVhbGl6ZXIsIGhlYWRlcjogaGVhZGVyLCBzdGF0aWNDb2x1bW5JbmRleDogc3RhdGljQ29sdW1uSW5kZXgsIHRhYmxlOiB0YWJsZSB9LCBoZWFkZXIuaWQpKSA6IG51bGw7XG4gICAgICAgICAgICB9KSwgdmlydHVhbFBhZGRpbmdSaWdodCA/IChqc3goXCJ0aFwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6ICdmbGV4Jywgd2lkdGg6IHZpcnR1YWxQYWRkaW5nUmlnaHQgfSB9KSkgOiBudWxsXSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1Rvb2xiYXJBbGVydEJhbm5lciA9IChfYSkgPT4ge1xuICAgIHZhciBfYiwgX2MsIF9kO1xuICAgIHZhciB7IHN0YWNrQWxlcnRCYW5uZXIsIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wic3RhY2tBbGVydEJhbm5lclwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCwgZ2V0Q29yZVJvd01vZGVsLCBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVSb3dTZWxlY3Rpb24sIGVuYWJsZVNlbGVjdEFsbCwgbG9jYWxpemF0aW9uLCBtYW51YWxQYWdpbmF0aW9uLCBtdWlUb29sYmFyQWxlcnRCYW5uZXJDaGlwUHJvcHMsIG11aVRvb2xiYXJBbGVydEJhbm5lclByb3BzLCBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciwgcmVuZGVyVG9vbGJhckFsZXJ0QmFubmVyQ29udGVudCwgcm93Q291bnQsIH0sIHJlZnM6IHsgdGFibGVQYXBlclJlZiB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkZW5zaXR5LCBncm91cGluZywgcm93U2VsZWN0aW9uLCBzaG93QWxlcnRCYW5uZXIgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgYWxlcnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRvb2xiYXJBbGVydEJhbm5lclByb3BzLCB7XG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcmVzdCk7XG4gICAgY29uc3QgY2hpcFByb3BzID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRvb2xiYXJBbGVydEJhbm5lckNoaXBQcm9wcywge1xuICAgICAgICB0YWJsZSxcbiAgICB9KTtcbiAgICBjb25zdCB0b3RhbFJvd0NvdW50ID0gcm93Q291bnQgIT09IG51bGwgJiYgcm93Q291bnQgIT09IHZvaWQgMCA/IHJvd0NvdW50IDogZ2V0Q29yZVJvd01vZGVsKCkucm93cy5sZW5ndGg7XG4gICAgY29uc3QgZmlsdGVyZWRSb3dDb3VudCA9IGdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCgpLnJvd3MubGVuZ3RoO1xuICAgIGNvbnN0IHNlbGVjdGVkUm93Q291bnQgPSB1c2VNZW1vKCgpID0+IG1hbnVhbFBhZ2luYXRpb25cbiAgICAgICAgPyBPYmplY3QudmFsdWVzKHJvd1NlbGVjdGlvbikuZmlsdGVyKEJvb2xlYW4pLmxlbmd0aFxuICAgICAgICA6IGZpbHRlcmVkUm93Q291bnQsIFtyb3dTZWxlY3Rpb24sIHRvdGFsUm93Q291bnQsIG1hbnVhbFBhZ2luYXRpb24sIGZpbHRlcmVkUm93Q291bnRdKTtcbiAgICBjb25zdCBzZWxlY3RlZEFsZXJ0ID0gc2VsZWN0ZWRSb3dDb3VudCA+IDAgPyAoanN4cyhTdGFjaywgeyBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBkaXJlY3Rpb246IFwicm93XCIsIGdhcDogXCIxNnB4XCIsIGNoaWxkcmVuOiBbKF9jID0gKF9iID0gbG9jYWxpemF0aW9uLnNlbGVjdGVkQ291bnRPZlJvd0NvdW50Um93c1NlbGVjdGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgne3NlbGVjdGVkQ291bnR9Jywgc2VsZWN0ZWRSb3dDb3VudC50b0xvY2FsZVN0cmluZyhsb2NhbGl6YXRpb24ubGFuZ3VhZ2UpKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlcGxhY2UoJ3tyb3dDb3VudH0nLCB0b3RhbFJvd0NvdW50LnRvTG9jYWxlU3RyaW5nKGxvY2FsaXphdGlvbi5sYW5ndWFnZSkpLCBqc3goQnV0dG9uLCB7IG9uQ2xpY2s6IChldmVudCkgPT4gZ2V0TVJUX1NlbGVjdEFsbEhhbmRsZXIoeyB0YWJsZSB9KShldmVudCwgZmFsc2UsIHRydWUpLCBzaXplOiBcInNtYWxsXCIsIHN4OiB7IHA6ICcycHgnIH0sIGNoaWxkcmVuOiBsb2NhbGl6YXRpb24uY2xlYXJTZWxlY3Rpb24gfSldIH0pKSA6IG51bGw7XG4gICAgY29uc3QgZ3JvdXBlZEFsZXJ0ID0gZ3JvdXBpbmcubGVuZ3RoID4gMCA/IChqc3hzKFwic3BhblwiLCB7IGNoaWxkcmVuOiBbbG9jYWxpemF0aW9uLmdyb3VwZWRCeSwgJyAnLCBncm91cGluZy5tYXAoKGNvbHVtbklkLCBpbmRleCkgPT4gKGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW2luZGV4ID4gMCA/IGxvY2FsaXphdGlvbi50aGVuQnkgOiAnJywganN4KENoaXAsIE9iamVjdC5hc3NpZ24oeyBsYWJlbDogdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKS5jb2x1bW5EZWYuaGVhZGVyLCBvbkRlbGV0ZTogKCkgPT4gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKS50b2dnbGVHcm91cGluZygpIH0sIGNoaXBQcm9wcykpXSB9LCBgJHtpbmRleH0tJHtjb2x1bW5JZH1gKSkpXSB9KSkgOiBudWxsO1xuICAgIHJldHVybiAoanN4KENvbGxhcHNlLCB7IGluOiBzaG93QWxlcnRCYW5uZXIgfHwgISFzZWxlY3RlZEFsZXJ0IHx8ICEhZ3JvdXBlZEFsZXJ0LCB0aW1lb3V0OiBzdGFja0FsZXJ0QmFubmVyID8gMjAwIDogMCwgY2hpbGRyZW46IGpzeChBbGVydCwgT2JqZWN0LmFzc2lnbih7IGNvbG9yOiBcImluZm9cIiwgaWNvbjogZmFsc2UgfSwgYWxlcnRQcm9wcywgeyBzeDogKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oeyAnJiAuTXVpQWxlcnQtbWVzc2FnZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBgY2FsYygkeyhfYiA9IChfYSA9IHRhYmxlUGFwZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaWVudFdpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAzNjB9cHggLSAxcmVtKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICB9LCBib3JkZXJSYWRpdXM6IDAsIGZvbnRTaXplOiAnMXJlbScsIGxlZnQ6IDAsIG1iOiBzdGFja0FsZXJ0QmFubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIgPT09ICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnLTFyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIHA6IDAsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCByaWdodDogMCwgdG9wOiAwLCB3aWR0aDogJzEwMCUnLCB6SW5kZXg6IDIgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGFsZXJ0UHJvcHMgPT09IG51bGwgfHwgYWxlcnRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxlcnRQcm9wcy5zeCwgdGhlbWUpKSk7XG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogKF9kID0gcmVuZGVyVG9vbGJhckFsZXJ0QmFubmVyQ29udGVudCA9PT0gbnVsbCB8fCByZW5kZXJUb29sYmFyQWxlcnRCYW5uZXJDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJUb29sYmFyQWxlcnRCYW5uZXJDb250ZW50KHtcbiAgICAgICAgICAgICAgICBncm91cGVkQWxlcnQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRBbGVydCxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyhhbGVydFByb3BzID09PSBudWxsIHx8IGFsZXJ0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFsZXJ0UHJvcHMudGl0bGUpICYmIGpzeChBbGVydFRpdGxlLCB7IGNoaWxkcmVuOiBhbGVydFByb3BzLnRpdGxlIH0pLCBqc3hzKFN0YWNrLCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDogcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIgIT09ICdoZWFkLW92ZXJsYXknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAuNXJlbSAxcmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRlbnNpdHkgPT09ICdzcGFjaW91cydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAuNzVyZW0gMS4yNXJlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGVuc2l0eSA9PT0gJ2NvbWZvcnRhYmxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAuNXJlbSAwLjc1cmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAuMjVyZW0gMC41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbYWxlcnRQcm9wcyA9PT0gbnVsbCB8fCBhbGVydFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGVydFByb3BzLmNoaWxkcmVuLCAoYWxlcnRQcm9wcyA9PT0gbnVsbCB8fCBhbGVydFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGVydFByb3BzLmNoaWxkcmVuKSAmJiAoc2VsZWN0ZWRBbGVydCB8fCBncm91cGVkQWxlcnQpICYmIChqc3goXCJiclwiLCB7fSkpLCBqc3hzKEJveCwgeyBzeDogeyBkaXNwbGF5OiAnZmxleCcgfSwgY2hpbGRyZW46IFtlbmFibGVSb3dTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVTZWxlY3RBbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciA9PT0gJ2hlYWQtb3ZlcmxheScgJiYgKGpzeChNUlRfU2VsZWN0Q2hlY2tib3gsIHsgdGFibGU6IHRhYmxlIH0pKSwgJyAnLCBzZWxlY3RlZEFsZXJ0XSB9KSwgc2VsZWN0ZWRBbGVydCAmJiBncm91cGVkQWxlcnQgJiYganN4KFwiYnJcIiwge30pLCBncm91cGVkQWxlcnRdIH0pXSB9KSkgfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9UYWJsZUhlYWQgPSAoX2EpID0+IHtcbiAgICB2YXIgeyBjb2x1bW5WaXJ0dWFsaXplciwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjb2x1bW5WaXJ0dWFsaXplclwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVN0aWNreUhlYWRlciwgbGF5b3V0TW9kZSwgbXVpVGFibGVIZWFkUHJvcHMsIHBvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyLCB9LCByZWZzOiB7IHRhYmxlSGVhZFJlZiB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBpc0Z1bGxTY3JlZW4sIHNob3dBbGVydEJhbm5lciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0YWJsZUhlYWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRhYmxlSGVhZFByb3BzLCB7IHRhYmxlIH0pKSwgcmVzdCk7XG4gICAgY29uc3Qgc3RpY2t5SGVhZGVyID0gZW5hYmxlU3RpY2t5SGVhZGVyIHx8IGlzRnVsbFNjcmVlbjtcbiAgICByZXR1cm4gKGpzeChUYWJsZUhlYWQsIE9iamVjdC5hc3NpZ24oe30sIHRhYmxlSGVhZFByb3BzLCB7IHJlZjogKHJlZikgPT4ge1xuICAgICAgICAgICAgdGFibGVIZWFkUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICBpZiAodGFibGVIZWFkUHJvcHMgPT09IG51bGwgfHwgdGFibGVIZWFkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlSGVhZFByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWRQcm9wcy5yZWYuY3VycmVudCA9IHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBkaXNwbGF5OiAobGF5b3V0TW9kZSA9PT0gbnVsbCB8fCBsYXlvdXRNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRNb2RlLnN0YXJ0c1dpdGgoJ2dyaWQnKSkgPyAnZ3JpZCcgOiB1bmRlZmluZWQsIG9wYWNpdHk6IDAuOTcsIHBvc2l0aW9uOiBzdGlja3lIZWFkZXIgPyAnc3RpY2t5JyA6ICdyZWxhdGl2ZScsIHRvcDogc3RpY2t5SGVhZGVyICYmIChsYXlvdXRNb2RlID09PSBudWxsIHx8IGxheW91dE1vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dE1vZGUuc3RhcnRzV2l0aCgnZ3JpZCcpKSA/IDAgOiB1bmRlZmluZWQsIHpJbmRleDogc3RpY2t5SGVhZGVyID8gMiA6IHVuZGVmaW5lZCB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVIZWFkUHJvcHMgPT09IG51bGwgfHwgdGFibGVIZWFkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlSGVhZFByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IHBvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyID09PSAnaGVhZC1vdmVybGF5JyAmJlxuICAgICAgICAgICAgKHNob3dBbGVydEJhbm5lciB8fCB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsKCkucm93cy5sZW5ndGggPiAwKSA/IChqc3goXCJ0clwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2dyaWQnIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IGpzeChcInRoXCIsIHsgY29sU3BhbjogdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkubGVuZ3RoLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAobGF5b3V0TW9kZSA9PT0gbnVsbCB8fCBsYXlvdXRNb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRNb2RlLnN0YXJ0c1dpdGgoJ2dyaWQnKSkgPyAnZ3JpZCcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGpzeChNUlRfVG9vbGJhckFsZXJ0QmFubmVyLCB7IHRhYmxlOiB0YWJsZSB9KSB9KSB9KSkgOiAodGFibGVcbiAgICAgICAgICAgIC5nZXRIZWFkZXJHcm91cHMoKVxuICAgICAgICAgICAgLm1hcCgoaGVhZGVyR3JvdXApID0+IChqc3goTVJUX1RhYmxlSGVhZFJvdywgeyBjb2x1bW5WaXJ0dWFsaXplcjogY29sdW1uVmlydHVhbGl6ZXIsIGhlYWRlckdyb3VwOiBoZWFkZXJHcm91cCwgdGFibGU6IHRhYmxlIH0sIGhlYWRlckdyb3VwLmlkKSkpKSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRGbGF0SGVhZGVycywgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgY29sdW1ucywgZW5hYmxlU3RpY2t5SGVhZGVyLCBlbmFibGVUYWJsZUZvb3RlciwgZW5hYmxlVGFibGVIZWFkLCBsYXlvdXRNb2RlLCBtZW1vTW9kZSwgbXVpVGFibGVQcm9wcywgcmVuZGVyQ2FwdGlvbiwgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY29sdW1uU2l6aW5nLCBjb2x1bW5TaXppbmdJbmZvLCBjb2x1bW5WaXNpYmlsaXR5LCBpc0Z1bGxTY3JlZW4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgdGFibGVQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRhYmxlUHJvcHMsIHsgdGFibGUgfSkpLCByZXN0KTtcbiAgICBjb25zdCBDYXB0aW9uID0gcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHJlbmRlckNhcHRpb24sIHsgdGFibGUgfSk7XG4gICAgY29uc3QgY29sdW1uU2l6ZVZhcnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGdldEZsYXRIZWFkZXJzKCk7XG4gICAgICAgIGNvbnN0IGNvbFNpemVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbFNpemUgPSBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29sU2l6ZXNbYC0taGVhZGVyLSR7cGFyc2VDU1NWYXJJZChoZWFkZXIuaWQpfS1zaXplYF0gPSBjb2xTaXplO1xuICAgICAgICAgICAgY29sU2l6ZXNbYC0tY29sLSR7cGFyc2VDU1NWYXJJZChoZWFkZXIuY29sdW1uLmlkKX0tc2l6ZWBdID0gY29sU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sU2l6ZXM7XG4gICAgfSwgW2NvbHVtbnMsIGNvbHVtblNpemluZywgY29sdW1uU2l6aW5nSW5mbywgY29sdW1uVmlzaWJpbGl0eV0pO1xuICAgIGNvbnN0IGNvbHVtblZpcnR1YWxpemVyID0gdXNlTVJUX0NvbHVtblZpcnR1YWxpemVyKHRhYmxlKTtcbiAgICBjb25zdCBjb21tb25UYWJsZUdyb3VwUHJvcHMgPSB7XG4gICAgICAgIGNvbHVtblZpcnR1YWxpemVyLFxuICAgICAgICB0YWJsZSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhUYWJsZSwgT2JqZWN0LmFzc2lnbih7IHN0aWNreUhlYWRlcjogZW5hYmxlU3RpY2t5SGVhZGVyIHx8IGlzRnVsbFNjcmVlbiB9LCB0YWJsZVByb3BzLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbHVtblNpemVWYXJzKSwgdGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLnN0eWxlKSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBib3JkZXJDb2xsYXBzZTogJ3NlcGFyYXRlJywgZGlzcGxheTogKGxheW91dE1vZGUgPT09IG51bGwgfHwgbGF5b3V0TW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0TW9kZS5zdGFydHNXaXRoKCdncmlkJykpID8gJ2dyaWQnIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmModGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IFshIUNhcHRpb24gJiYganN4KFwiY2FwdGlvblwiLCB7IGNoaWxkcmVuOiBDYXB0aW9uIH0pLCBlbmFibGVUYWJsZUhlYWQgJiYganN4KE1SVF9UYWJsZUhlYWQsIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblRhYmxlR3JvdXBQcm9wcykpLCBtZW1vTW9kZSA9PT0gJ3RhYmxlLWJvZHknIHx8IGNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA/IChqc3goTWVtb19NUlRfVGFibGVCb2R5LCBPYmplY3QuYXNzaWduKHt9LCBjb21tb25UYWJsZUdyb3VwUHJvcHMpKSkgOiAoanN4KE1SVF9UYWJsZUJvZHksIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblRhYmxlR3JvdXBQcm9wcykpKSwgZW5hYmxlVGFibGVGb290ZXIgJiYganN4KE1SVF9UYWJsZUZvb3RlciwgT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGFibGVHcm91cFByb3BzKSldIH0pKSk7XG59O1xuXG5jb25zdCBNUlRfVGFibGVMb2FkaW5nT3ZlcmxheSA9IChfYSkgPT4ge1xuICAgIHZhciBfYjtcbiAgICB2YXIgeyB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWQsIGxvY2FsaXphdGlvbiwgbXJ0VGhlbWU6IHsgYmFzZUJhY2tncm91bmRDb2xvciB9LCBtdWlDaXJjdWxhclByb2dyZXNzUHJvcHMsIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCBjaXJjdWxhclByb2dyZXNzUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlDaXJjdWxhclByb2dyZXNzUHJvcHMsIHsgdGFibGUgfSkpLCByZXN0KTtcbiAgICByZXR1cm4gKGpzeChCb3gsIHsgc3g6IHtcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhbHBoYShiYXNlQmFja2dyb3VuZENvbG9yLCAwLjUpLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIG1heEhlaWdodDogJzEwMHZoJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgekluZGV4OiAzLFxuICAgICAgICB9LCBjaGlsZHJlbjogKF9iID0gY2lyY3VsYXJQcm9ncmVzc1Byb3BzID09PSBudWxsIHx8IGNpcmN1bGFyUHJvZ3Jlc3NQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2lyY3VsYXJQcm9ncmVzc1Byb3BzLkNvbXBvbmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKGpzeChDaXJjdWxhclByb2dyZXNzLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5ub1JlY29yZHNUb0Rpc3BsYXksIGlkOiBgbXJ0LXByb2dyZXNzLSR7aWR9YCB9LCBjaXJjdWxhclByb2dyZXNzUHJvcHMpKSkgfSkpO1xufTtcblxuY29uc3QgTVJUX0NlbGxBY3Rpb25NZW51ID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iLCBfYztcbiAgICB2YXIgeyB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVkaXREaXNwbGF5TW9kZSwgZW5hYmxlQ2xpY2tUb0NvcHksIGVuYWJsZUVkaXRpbmcsIGljb25zOiB7IENvbnRlbnRDb3B5LCBFZGl0SWNvbiB9LCBsb2NhbGl6YXRpb24sIG1ydFRoZW1lOiB7IG1lbnVCYWNrZ3JvdW5kQ29sb3IgfSwgcmVuZGVyQ2VsbEFjdGlvbk1lbnVJdGVtcywgfSwgcmVmczogeyBhY3Rpb25DZWxsUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGFjdGlvbkNlbGwsIGRlbnNpdHkgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgY2VsbCA9IGFjdGlvbkNlbGw7XG4gICAgY29uc3QgeyByb3cgfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW4gfSA9IGNlbGw7XG4gICAgY29uc3QgeyBjb2x1bW5EZWYgfSA9IGNvbHVtbjtcbiAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRhYmxlLnNldEFjdGlvbkNlbGwobnVsbCk7XG4gICAgICAgIGFjdGlvbkNlbGxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbE1lbnVJdGVtcyA9IFtcbiAgICAgICAgKHBhcnNlRnJvbVZhbHVlc09yRnVuYyhlbmFibGVDbGlja1RvQ29weSwgY2VsbCkgPT09ICdjb250ZXh0LW1lbnUnIHx8XG4gICAgICAgICAgICBwYXJzZUZyb21WYWx1ZXNPckZ1bmMoY29sdW1uRGVmLmVuYWJsZUNsaWNrVG9Db3B5LCBjZWxsKSA9PT1cbiAgICAgICAgICAgICAgICAnY29udGV4dC1tZW51JykgJiYgKGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgaWNvbjoganN4KENvbnRlbnRDb3B5LCB7fSksIGxhYmVsOiBsb2NhbGl6YXRpb24uY29weSwgb25DbGljazogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY2VsbC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZSgpO1xuICAgICAgICAgICAgfSwgdGFibGU6IHRhYmxlIH0sICdtcnQtY29weScpKSxcbiAgICAgICAgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKGVuYWJsZUVkaXRpbmcsIHJvdykgJiYgZWRpdERpc3BsYXlNb2RlID09PSAnY2VsbCcgJiYgKGpzeChNUlRfQWN0aW9uTWVudUl0ZW0sIHsgaWNvbjoganN4KEVkaXRJY29uLCB7fSksIGxhYmVsOiBsb2NhbGl6YXRpb24uZWRpdCwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wZW5FZGl0aW5nQ2VsbCh7IGNlbGwsIHRhYmxlIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgICAgICAgICB9LCB0YWJsZTogdGFibGUgfSwgJ21ydC1lZGl0JykpLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IHJlbmRlckFjdGlvblByb3BzID0ge1xuICAgICAgICBjZWxsLFxuICAgICAgICBjbG9zZU1lbnU6IGhhbmRsZUNsb3NlLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIGludGVybmFsTWVudUl0ZW1zLFxuICAgICAgICByb3csXG4gICAgICAgIHRhYmxlLFxuICAgIH07XG4gICAgY29uc3QgbWVudUl0ZW1zID0gKF9jID0gKF9iID0gY29sdW1uRGVmLnJlbmRlckNlbGxBY3Rpb25NZW51SXRlbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbHVtbkRlZiwgcmVuZGVyQWN0aW9uUHJvcHMpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiByZW5kZXJDZWxsQWN0aW9uTWVudUl0ZW1zID09PSBudWxsIHx8IHJlbmRlckNlbGxBY3Rpb25NZW51SXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckNlbGxBY3Rpb25NZW51SXRlbXMocmVuZGVyQWN0aW9uUHJvcHMpO1xuICAgIHJldHVybiAoKCEhKG1lbnVJdGVtcyA9PT0gbnVsbCB8fCBtZW51SXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lbnVJdGVtcy5sZW5ndGgpIHx8ICEhKGludGVybmFsTWVudUl0ZW1zID09PSBudWxsIHx8IGludGVybmFsTWVudUl0ZW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcm5hbE1lbnVJdGVtcy5sZW5ndGgpKSAmJiAoanN4KE1lbnUsIE9iamVjdC5hc3NpZ24oeyBNZW51TGlzdFByb3BzOiB7XG4gICAgICAgICAgICBkZW5zZTogZGVuc2l0eSA9PT0gJ2NvbXBhY3QnLFxuICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG1lbnVCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBhbmNob3JFbDogYWN0aW9uQ2VsbFJlZi5jdXJyZW50LCBkaXNhYmxlU2Nyb2xsTG9jazogdHJ1ZSwgb25DbGljazogKGV2ZW50KSA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgb25DbG9zZTogaGFuZGxlQ2xvc2UsIG9wZW46ICEhY2VsbCwgdHJhbnNmb3JtT3JpZ2luOiB7IGhvcml6b250YWw6IC0xMDAsIHZlcnRpY2FsOiA4IH0gfSwgcmVzdCwgeyBjaGlsZHJlbjogbWVudUl0ZW1zICE9PSBudWxsICYmIG1lbnVJdGVtcyAhPT0gdm9pZCAwID8gbWVudUl0ZW1zIDogaW50ZXJuYWxNZW51SXRlbXMgfSkpKSk7XG59O1xuXG5jb25zdCBNUlRfRWRpdFJvd01vZGFsID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IG9wZW4sIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wib3BlblwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGxvY2FsaXphdGlvbiwgbXVpQ3JlYXRlUm93TW9kYWxQcm9wcywgbXVpRWRpdFJvd0RpYWxvZ1Byb3BzLCBvbkNyZWF0aW5nUm93Q2FuY2VsLCBvbkVkaXRpbmdSb3dDYW5jZWwsIHJlbmRlckNyZWF0ZVJvd0RpYWxvZ0NvbnRlbnQsIHJlbmRlckVkaXRSb3dEaWFsb2dDb250ZW50LCB9LCBzZXRDcmVhdGluZ1Jvdywgc2V0RWRpdGluZ1JvdywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgY3JlYXRpbmdSb3csIGVkaXRpbmdSb3cgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3Qgcm93ID0gKGNyZWF0aW5nUm93ICE9PSBudWxsICYmIGNyZWF0aW5nUm93ICE9PSB2b2lkIDAgPyBjcmVhdGluZ1JvdyA6IGVkaXRpbmdSb3cpO1xuICAgIGNvbnN0IGRpYWxvZ1Byb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlFZGl0Um93RGlhbG9nUHJvcHMsIHsgcm93LCB0YWJsZSB9KSksIChjcmVhdGluZ1JvdyAmJlxuICAgICAgICBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpQ3JlYXRlUm93TW9kYWxQcm9wcywgeyByb3csIHRhYmxlIH0pKSksIHJlc3QpO1xuICAgIGNvbnN0IGludGVybmFsRWRpdENvbXBvbmVudHMgPSByb3dcbiAgICAgICAgLmdldEFsbENlbGxzKClcbiAgICAgICAgLmZpbHRlcigoY2VsbCkgPT4gY2VsbC5jb2x1bW4uY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgPT09ICdkYXRhJylcbiAgICAgICAgLm1hcCgoY2VsbCkgPT4gKGpzeChNUlRfRWRpdENlbGxUZXh0RmllbGQsIHsgY2VsbDogY2VsbCwgdGFibGU6IHRhYmxlIH0sIGNlbGwuaWQpKSk7XG4gICAgcmV0dXJuIChqc3goRGlhbG9nLCBPYmplY3QuYXNzaWduKHsgZnVsbFdpZHRoOiB0cnVlLCBtYXhXaWR0aDogXCJ4c1wiLCBvbkNsb3NlOiAoZXZlbnQsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGNyZWF0aW5nUm93KSB7XG4gICAgICAgICAgICAgICAgb25DcmVhdGluZ1Jvd0NhbmNlbCA9PT0gbnVsbCB8fCBvbkNyZWF0aW5nUm93Q2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNyZWF0aW5nUm93Q2FuY2VsKHsgcm93LCB0YWJsZSB9KTtcbiAgICAgICAgICAgICAgICBzZXRDcmVhdGluZ1JvdyhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uRWRpdGluZ1Jvd0NhbmNlbCA9PT0gbnVsbCB8fCBvbkVkaXRpbmdSb3dDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRWRpdGluZ1Jvd0NhbmNlbCh7IHJvdywgdGFibGUgfSk7XG4gICAgICAgICAgICAgICAgc2V0RWRpdGluZ1JvdyhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdy5fdmFsdWVzQ2FjaGUgPSB7fTsgLy9yZXNldCB2YWx1ZXMgY2FjaGVcbiAgICAgICAgICAgIChfYSA9IGRpYWxvZ1Byb3BzLm9uQ2xvc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRpYWxvZ1Byb3BzLCBldmVudCwgcmVhc29uKTtcbiAgICAgICAgfSwgb3Blbjogb3BlbiB9LCBkaWFsb2dQcm9wcywgeyBjaGlsZHJlbjogKF9iID0gKChjcmVhdGluZ1JvdyAmJlxuICAgICAgICAgICAgKHJlbmRlckNyZWF0ZVJvd0RpYWxvZ0NvbnRlbnQgPT09IG51bGwgfHwgcmVuZGVyQ3JlYXRlUm93RGlhbG9nQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyQ3JlYXRlUm93RGlhbG9nQ29udGVudCh7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxFZGl0Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICB9KSkpIHx8XG4gICAgICAgICAgICAocmVuZGVyRWRpdFJvd0RpYWxvZ0NvbnRlbnQgPT09IG51bGwgfHwgcmVuZGVyRWRpdFJvd0RpYWxvZ0NvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlckVkaXRSb3dEaWFsb2dDb250ZW50KHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEVkaXRDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIH0pKSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KERpYWxvZ1RpdGxlLCB7IHN4OiB7IHRleHRBbGlnbjogJ2NlbnRlcicgfSwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5lZGl0IH0pLCBqc3goRGlhbG9nQ29udGVudCwgeyBjaGlsZHJlbjoganN4KFwiZm9ybVwiLCB7IG9uU3VibWl0OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLCBjaGlsZHJlbjoganN4KFN0YWNrLCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogJzMycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGludGVybmFsRWRpdENvbXBvbmVudHMgfSkgfSkgfSksIGpzeChEaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHA6ICcxLjI1cmVtJyB9LCBjaGlsZHJlbjoganN4KE1SVF9FZGl0QWN0aW9uQnV0dG9ucywgeyByb3c6IHJvdywgdGFibGU6IHRhYmxlLCB2YXJpYW50OiBcInRleHRcIiB9KSB9KV0gfSkpIH0pKSk7XG59O1xuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5jb25zdCBNUlRfVGFibGVDb250YWluZXIgPSAoX2EpID0+IHtcbiAgICB2YXIgeyB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGNyZWF0ZURpc3BsYXlNb2RlLCBlZGl0RGlzcGxheU1vZGUsIGVuYWJsZUNlbGxBY3Rpb25zLCBlbmFibGVTdGlja3lIZWFkZXIsIG11aVRhYmxlQ29udGFpbmVyUHJvcHMsIH0sIHJlZnM6IHsgYm90dG9tVG9vbGJhclJlZiwgdGFibGVDb250YWluZXJSZWYsIHRvcFRvb2xiYXJSZWYgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgYWN0aW9uQ2VsbCwgY3JlYXRpbmdSb3csIGVkaXRpbmdSb3csIGlzRnVsbFNjcmVlbiwgaXNMb2FkaW5nLCBzaG93TG9hZGluZ092ZXJsYXksIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGxvYWRpbmcgPSBzaG93TG9hZGluZ092ZXJsYXkgIT09IGZhbHNlICYmIChpc0xvYWRpbmcgfHwgc2hvd0xvYWRpbmdPdmVybGF5KTtcbiAgICBjb25zdCBbdG90YWxUb29sYmFySGVpZ2h0LCBzZXRUb3RhbFRvb2xiYXJIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgdGFibGVDb250YWluZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRhYmxlQ29udGFpbmVyUHJvcHMsIHtcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCB0b3BUb29sYmFySGVpZ2h0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyAoKF9iID0gKF9hID0gdG9wVG9vbGJhclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2Zmc2V0SGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICBjb25zdCBib3R0b21Ub29sYmFySGVpZ2h0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyAoKF9kID0gKF9jID0gYm90dG9tVG9vbGJhclJlZiA9PT0gbnVsbCB8fCBib3R0b21Ub29sYmFyUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib3R0b21Ub29sYmFyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vZmZzZXRIZWlnaHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIHNldFRvdGFsVG9vbGJhckhlaWdodCh0b3BUb29sYmFySGVpZ2h0ICsgYm90dG9tVG9vbGJhckhlaWdodCk7XG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlTW9kYWxPcGVuID0gY3JlYXRlRGlzcGxheU1vZGUgPT09ICdtb2RhbCcgJiYgY3JlYXRpbmdSb3c7XG4gICAgY29uc3QgZWRpdE1vZGFsT3BlbiA9IGVkaXREaXNwbGF5TW9kZSA9PT0gJ21vZGFsJyAmJiBlZGl0aW5nUm93O1xuICAgIHJldHVybiAoanN4cyhUYWJsZUNvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1idXN5XCI6IGxvYWRpbmcsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBsb2FkaW5nID8gJ21ydC1wcm9ncmVzcycgOiB1bmRlZmluZWQgfSwgdGFibGVDb250YWluZXJQcm9wcywgeyByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmICh0YWJsZUNvbnRhaW5lclByb3BzID09PSBudWxsIHx8IHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlQ29udGFpbmVyUHJvcHMucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNvbnRhaW5lclByb3BzLnJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0eWxlOiBPYmplY3QuYXNzaWduKHsgbWF4SGVpZ2h0OiBpc0Z1bGxTY3JlZW5cbiAgICAgICAgICAgICAgICA/IGBjYWxjKDEwMHZoIC0gJHt0b3RhbFRvb2xiYXJIZWlnaHR9cHgpYFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0sIHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IG51bGwgfHwgdGFibGVDb250YWluZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDb250YWluZXJQcm9wcy5zdHlsZSksIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgbWF4SGVpZ2h0OiBlbmFibGVTdGlja3lIZWFkZXJcbiAgICAgICAgICAgICAgICA/IGBjbGFtcCgzNTBweCwgY2FsYygxMDB2aCAtICR7dG90YWxUb29sYmFySGVpZ2h0fXB4KSwgOTk5OXB4KWBcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgbWF4V2lkdGg6ICcxMDAlJywgb3ZlcmZsb3c6ICdhdXRvJywgcG9zaXRpb246ICdyZWxhdGl2ZScgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHRhYmxlQ29udGFpbmVyUHJvcHMgPT09IG51bGwgfHwgdGFibGVDb250YWluZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFibGVDb250YWluZXJQcm9wcy5zeCwgdGhlbWUpKSksIGNoaWxkcmVuOiBbbG9hZGluZyA/IGpzeChNUlRfVGFibGVMb2FkaW5nT3ZlcmxheSwgeyB0YWJsZTogdGFibGUgfSkgOiBudWxsLCBqc3goTVJUX1RhYmxlLCB7IHRhYmxlOiB0YWJsZSB9KSwgKGNyZWF0ZU1vZGFsT3BlbiB8fCBlZGl0TW9kYWxPcGVuKSAmJiAoanN4KE1SVF9FZGl0Um93TW9kYWwsIHsgb3BlbjogdHJ1ZSwgdGFibGU6IHRhYmxlIH0pKSwgZW5hYmxlQ2VsbEFjdGlvbnMgJiYgYWN0aW9uQ2VsbCAmJiBqc3goTVJUX0NlbGxBY3Rpb25NZW51LCB7IHRhYmxlOiB0YWJsZSB9KV0gfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9MaW5lYXJQcm9ncmVzc0JhciA9IChfYSkgPT4ge1xuICAgIHZhciB7IGlzVG9wVG9vbGJhciwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJpc1RvcFRvb2xiYXJcIiwgXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBtdWlMaW5lYXJQcm9ncmVzc1Byb3BzIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzU2F2aW5nLCBzaG93UHJvZ3Jlc3NCYXJzIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGxpbmVhclByb2dyZXNzUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlMaW5lYXJQcm9ncmVzc1Byb3BzLCB7XG4gICAgICAgIGlzVG9wVG9vbGJhcixcbiAgICAgICAgdGFibGUsXG4gICAgfSkpLCByZXN0KTtcbiAgICByZXR1cm4gKGpzeChDb2xsYXBzZSwgeyBpbjogc2hvd1Byb2dyZXNzQmFycyAhPT0gZmFsc2UgJiYgKHNob3dQcm9ncmVzc0JhcnMgfHwgaXNTYXZpbmcpLCBtb3VudE9uRW50ZXI6IHRydWUsIHN4OiB7XG4gICAgICAgICAgICBib3R0b206IGlzVG9wVG9vbGJhciA/IDAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogIWlzVG9wVG9vbGJhciA/IDAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICB9LCB1bm1vdW50T25FeGl0OiB0cnVlLCBjaGlsZHJlbjoganN4KExpbmVhclByb2dyZXNzLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWJ1c3lcIjogXCJ0cnVlXCIsIFwiYXJpYS1sYWJlbFwiOiBcIkxvYWRpbmdcIiwgc3g6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSB9LCBsaW5lYXJQcm9ncmVzc1Byb3BzKSkgfSkpO1xufTtcblxuY29uc3QgZGVmYXVsdFJvd3NQZXJQYWdlID0gWzUsIDEwLCAxNSwgMjAsIDI1LCAzMCwgNTAsIDEwMF07XG5jb25zdCBNUlRfVGFibGVQYWdpbmF0aW9uID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgcG9zaXRpb24gPSAnYm90dG9tJywgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJwb3NpdGlvblwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gICAgY29uc3QgaXNNb2JpbGUgPSB1c2VNZWRpYVF1ZXJ5KCcobWF4LXdpZHRoOiA3MjBweCknKTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZVRvb2xiYXJJbnRlcm5hbEFjdGlvbnMsIGljb25zOiB7IENoZXZyb25MZWZ0SWNvbiwgQ2hldnJvblJpZ2h0SWNvbiwgRmlyc3RQYWdlSWNvbiwgTGFzdFBhZ2VJY29uIH0sIGlkLCBsb2NhbGl6YXRpb24sIG11aVBhZ2luYXRpb25Qcm9wcywgcGFnaW5hdGlvbkRpc3BsYXlNb2RlLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBwYWdpbmF0aW9uOiB7IHBhZ2VJbmRleCA9IDAsIHBhZ2VTaXplID0gMTAgfSwgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgcGFnaW5hdGlvblByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpUGFnaW5hdGlvblByb3BzLCB7XG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcmVzdCk7XG4gICAgY29uc3QgdG90YWxSb3dDb3VudCA9IHRhYmxlLmdldFJvd0NvdW50KCk7XG4gICAgY29uc3QgbnVtYmVyT2ZQYWdlcyA9IHRhYmxlLmdldFBhZ2VDb3VudCgpO1xuICAgIGNvbnN0IHNob3dGaXJzdExhc3RQYWdlQnV0dG9ucyA9IG51bWJlck9mUGFnZXMgPiAyO1xuICAgIGNvbnN0IGZpcnN0Um93SW5kZXggPSBwYWdlSW5kZXggKiBwYWdlU2l6ZTtcbiAgICBjb25zdCBsYXN0Um93SW5kZXggPSBNYXRoLm1pbihwYWdlSW5kZXggKiBwYWdlU2l6ZSArIHBhZ2VTaXplLCB0b3RhbFJvd0NvdW50KTtcbiAgICBjb25zdCBfYiA9IHBhZ2luYXRpb25Qcm9wcyAhPT0gbnVsbCAmJiBwYWdpbmF0aW9uUHJvcHMgIT09IHZvaWQgMCA/IHBhZ2luYXRpb25Qcm9wcyA6IHt9LCB7IFNlbGVjdFByb3BzID0ge30sIGRpc2FibGVkID0gZmFsc2UsIHJvd3NQZXJQYWdlT3B0aW9ucyA9IGRlZmF1bHRSb3dzUGVyUGFnZSwgc2hvd0ZpcnN0QnV0dG9uID0gc2hvd0ZpcnN0TGFzdFBhZ2VCdXR0b25zLCBzaG93TGFzdEJ1dHRvbiA9IHNob3dGaXJzdExhc3RQYWdlQnV0dG9ucywgc2hvd1Jvd3NQZXJQYWdlID0gdHJ1ZSB9ID0gX2IsIHJlc3RQYWdpbmF0aW9uUHJvcHMgPSBfX3Jlc3QoX2IsIFtcIlNlbGVjdFByb3BzXCIsIFwiZGlzYWJsZWRcIiwgXCJyb3dzUGVyUGFnZU9wdGlvbnNcIiwgXCJzaG93Rmlyc3RCdXR0b25cIiwgXCJzaG93TGFzdEJ1dHRvblwiLCBcInNob3dSb3dzUGVyUGFnZVwiXSk7XG4gICAgY29uc3QgZGlzYWJsZUJhY2sgPSBwYWdlSW5kZXggPD0gMCB8fCBkaXNhYmxlZDtcbiAgICBjb25zdCBkaXNhYmxlTmV4dCA9IGxhc3RSb3dJbmRleCA+PSB0b3RhbFJvd0NvdW50IHx8IGRpc2FibGVkO1xuICAgIGlmIChpc01vYmlsZSAmJiAoU2VsZWN0UHJvcHMgPT09IG51bGwgfHwgU2VsZWN0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFNlbGVjdFByb3BzLm5hdGl2ZSkgIT09IGZhbHNlKSB7XG4gICAgICAgIFNlbGVjdFByb3BzLm5hdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHRvb2x0aXBQcm9wcyA9IGdldENvbW1vblRvb2x0aXBQcm9wcygpO1xuICAgIHJldHVybiAoanN4cyhCb3gsIHsgY2xhc3NOYW1lOiBcIk11aVRhYmxlUGFnaW5hdGlvbi1yb290XCIsIHN4OiB7XG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgICAgICAgICBnYXA6ICc4cHgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IHsgbWQ6ICdzcGFjZS1iZXR3ZWVuJywgc206ICdjZW50ZXInIH0sXG4gICAgICAgICAgICBqdXN0aWZ5U2VsZjogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgIG10OiBwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9uc1xuICAgICAgICAgICAgICAgID8gJzNyZW0nXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIHB4OiAnOHB4JyxcbiAgICAgICAgICAgIHB5OiAnMTJweCcsXG4gICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbc2hvd1Jvd3NQZXJQYWdlICYmIChqc3hzKEJveCwgeyBzeDogeyBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZGlzcGxheTogJ2ZsZXgnLCBnYXA6ICc4cHgnIH0sIGNoaWxkcmVuOiBbanN4KElucHV0TGFiZWwsIHsgaHRtbEZvcjogYG1ydC1yb3dzLXBlci1wYWdlLSR7aWR9YCwgc3g6IHsgbWI6IDAgfSwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5yb3dzUGVyUGFnZSB9KSwganN4KFNlbGVjdCwgT2JqZWN0LmFzc2lnbih7IE1lbnVQcm9wczogeyBkaXNhYmxlU2Nyb2xsTG9jazogdHJ1ZSB9LCBkaXNhYmxlVW5kZXJsaW5lOiB0cnVlLCBkaXNhYmxlZDogZGlzYWJsZWQsIGlucHV0UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGxvY2FsaXphdGlvbi5yb3dzUGVyUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYG1ydC1yb3dzLXBlci1wYWdlLSR7aWR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxhYmVsOiBsb2NhbGl6YXRpb24ucm93c1BlclBhZ2UsIG9uQ2hhbmdlOiAoZXZlbnQpID0+IHRhYmxlLnNldFBhZ2VTaXplKCtldmVudC50YXJnZXQudmFsdWUpLCBzeDogeyBtYjogMCB9LCB2YWx1ZTogcGFnZVNpemUsIHZhcmlhbnQ6IFwic3RhbmRhcmRcIiB9LCBTZWxlY3RQcm9wcywgeyBjaGlsZHJlbjogcm93c1BlclBhZ2VPcHRpb25zLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG9wdGlvbiAhPT0gJ251bWJlcicgPyBvcHRpb24udmFsdWUgOiBvcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSB0eXBlb2Ygb3B0aW9uICE9PSAnbnVtYmVyJyA/IG9wdGlvbi5sYWJlbCA6IGAke29wdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gU2VsZWN0UHJvcHMgPT09IG51bGwgfHwgU2VsZWN0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFNlbGVjdFByb3BzLmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKFNlbGVjdFByb3BzID09PSBudWxsIHx8IFNlbGVjdFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBTZWxlY3RQcm9wcy5uYXRpdmUpID8gKGpzeChcIm9wdGlvblwiLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGxhYmVsIH0sIHZhbHVlKSkgOiAoanN4KE1lbnVJdGVtLCB7IHN4OiB7IG06IDAgfSwgdmFsdWU6IHZhbHVlLCBjaGlsZHJlbjogbGFiZWwgfSwgdmFsdWUpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSkpXSB9KSksIHBhZ2luYXRpb25EaXNwbGF5TW9kZSA9PT0gJ3BhZ2VzJyA/IChqc3goUGFnaW5hdGlvbiwgT2JqZWN0LmFzc2lnbih7IGNvdW50OiBudW1iZXJPZlBhZ2VzLCBkaXNhYmxlZDogZGlzYWJsZWQsIG9uQ2hhbmdlOiAoX2UsIG5ld1BhZ2VJbmRleCkgPT4gdGFibGUuc2V0UGFnZUluZGV4KG5ld1BhZ2VJbmRleCAtIDEpLCBwYWdlOiBwYWdlSW5kZXggKyAxLCByZW5kZXJJdGVtOiAoaXRlbSkgPT4gKGpzeChQYWdpbmF0aW9uSXRlbSwgT2JqZWN0LmFzc2lnbih7IHNsb3RzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdDogRmlyc3RQYWdlSWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Q6IExhc3RQYWdlSWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IENoZXZyb25SaWdodEljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogQ2hldnJvbkxlZnRJY29uLFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGl0ZW0pKSksIHNob3dGaXJzdEJ1dHRvbjogc2hvd0ZpcnN0QnV0dG9uLCBzaG93TGFzdEJ1dHRvbjogc2hvd0xhc3RCdXR0b24gfSwgcmVzdFBhZ2luYXRpb25Qcm9wcykpKSA6IHBhZ2luYXRpb25EaXNwbGF5TW9kZSA9PT0gJ2RlZmF1bHQnID8gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goVHlwb2dyYXBoeSwgeyBhbGlnbjogXCJjZW50ZXJcIiwgY29tcG9uZW50OiBcInNwYW5cIiwgc3g6IHsgbTogJzAgNHB4JywgbWluV2lkdGg6ICc4Y2gnIH0sIHZhcmlhbnQ6IFwiYm9keTJcIiwgY2hpbGRyZW46IGAke2xhc3RSb3dJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGZpcnN0Um93SW5kZXggKyAxKS50b0xvY2FsZVN0cmluZyhsb2NhbGl6YXRpb24ubGFuZ3VhZ2UpfS0ke2xhc3RSb3dJbmRleC50b0xvY2FsZVN0cmluZyhsb2NhbGl6YXRpb24ubGFuZ3VhZ2UpfSAke2xvY2FsaXphdGlvbi5vZn0gJHt0b3RhbFJvd0NvdW50LnRvTG9jYWxlU3RyaW5nKGxvY2FsaXphdGlvbi5sYW5ndWFnZSl9YCB9KSwganN4cyhCb3gsIHsgZ2FwOiBcInhzXCIsIGNoaWxkcmVuOiBbc2hvd0ZpcnN0QnV0dG9uICYmIChqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgdG9vbHRpcFByb3BzLCB7IHRpdGxlOiBsb2NhbGl6YXRpb24uZ29Ub0ZpcnN0UGFnZSwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5nb1RvRmlyc3RQYWdlLCBkaXNhYmxlZDogZGlzYWJsZUJhY2ssIG9uQ2xpY2s6ICgpID0+IHRhYmxlLmZpcnN0UGFnZSgpLCBzaXplOiBcInNtYWxsXCIsIGNoaWxkcmVuOiBqc3goRmlyc3RQYWdlSWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgZmxpcEljb25TdHlsZXModGhlbWUpKSkgfSkgfSkgfSkpKSwganN4KFRvb2x0aXAsIE9iamVjdC5hc3NpZ24oe30sIHRvb2x0aXBQcm9wcywgeyB0aXRsZTogbG9jYWxpemF0aW9uLmdvVG9QcmV2aW91c1BhZ2UsIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHsgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCB7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uZ29Ub1ByZXZpb3VzUGFnZSwgZGlzYWJsZWQ6IGRpc2FibGVCYWNrLCBvbkNsaWNrOiAoKSA9PiB0YWJsZS5wcmV2aW91c1BhZ2UoKSwgc2l6ZTogXCJzbWFsbFwiLCBjaGlsZHJlbjoganN4KENoZXZyb25MZWZ0SWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgZmxpcEljb25TdHlsZXModGhlbWUpKSkgfSkgfSkgfSkpLCBqc3goVG9vbHRpcCwgT2JqZWN0LmFzc2lnbih7fSwgdG9vbHRpcFByb3BzLCB7IHRpdGxlOiBsb2NhbGl6YXRpb24uZ29Ub05leHRQYWdlLCBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLmdvVG9OZXh0UGFnZSwgZGlzYWJsZWQ6IGRpc2FibGVOZXh0LCBvbkNsaWNrOiAoKSA9PiB0YWJsZS5uZXh0UGFnZSgpLCBzaXplOiBcInNtYWxsXCIsIGNoaWxkcmVuOiBqc3goQ2hldnJvblJpZ2h0SWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgZmxpcEljb25TdHlsZXModGhlbWUpKSkgfSkgfSkgfSkpLCBzaG93TGFzdEJ1dHRvbiAmJiAoanN4KFRvb2x0aXAsIE9iamVjdC5hc3NpZ24oe30sIHRvb2x0aXBQcm9wcywgeyB0aXRsZTogbG9jYWxpemF0aW9uLmdvVG9MYXN0UGFnZSwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5nb1RvTGFzdFBhZ2UsIGRpc2FibGVkOiBkaXNhYmxlTmV4dCwgb25DbGljazogKCkgPT4gdGFibGUubGFzdFBhZ2UoKSwgc2l6ZTogXCJzbWFsbFwiLCBjaGlsZHJlbjoganN4KExhc3RQYWdlSWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgZmxpcEljb25TdHlsZXModGhlbWUpKSkgfSkgfSkgfSkpKV0gfSldIH0pKSA6IG51bGxdIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub29sYmFyRHJvcFpvbmUgPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlR3JvdXBpbmcsIGxvY2FsaXphdGlvbiB9LCBzZXRIb3ZlcmVkQ29sdW1uLCBzZXRTaG93VG9vbGJhckRyb3Bab25lLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBkcmFnZ2luZ0NvbHVtbiwgZ3JvdXBpbmcsIGhvdmVyZWRDb2x1bW4sIHNob3dUb29sYmFyRHJvcFpvbmUgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKF9ldmVudCkgPT4ge1xuICAgICAgICBzZXRIb3ZlcmVkQ29sdW1uKHsgaWQ6ICdkcm9wLXpvbmUnIH0pO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGFibGUub3B0aW9ucy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3dUb29sYmFyRHJvcFpvbmUpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldFNob3dUb29sYmFyRHJvcFpvbmUoISFlbmFibGVHcm91cGluZyAmJlxuICAgICAgICAgICAgICAgICEhZHJhZ2dpbmdDb2x1bW4gJiZcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ0NvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR3JvdXBpbmcgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgIWdyb3VwaW5nLmluY2x1ZGVzKGRyYWdnaW5nQ29sdW1uLmlkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbZW5hYmxlR3JvdXBpbmcsIGRyYWdnaW5nQ29sdW1uLCBncm91cGluZ10pO1xuICAgIHJldHVybiAoanN4KEZhZGUsIHsgaW46IHNob3dUb29sYmFyRHJvcFpvbmUsIGNoaWxkcmVuOiBqc3goQm94LCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBcIk11aS1Ub29sYmFyRHJvcFpvbmVcIiwgb25EcmFnRW50ZXI6IGhhbmRsZURyYWdFbnRlciwgb25EcmFnT3ZlcjogaGFuZGxlRHJhZ092ZXIgfSwgcmVzdCwgeyBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbih7IGFsaWduSXRlbXM6ICdjZW50ZXInLCBiYWNrZHJvcEZpbHRlcjogJ2JsdXIoNHB4KScsIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5pbmZvLm1haW4sIChob3ZlcmVkQ29sdW1uID09PSBudWxsIHx8IGhvdmVyZWRDb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvdmVyZWRDb2x1bW4uaWQpID09PSAnZHJvcC16b25lJyA/IDAuMiA6IDAuMSksIGJvcmRlcjogYGRhc2hlZCAke3RoZW1lLnBhbGV0dGUuaW5mby5tYWlufSAycHhgLCBib3hTaXppbmc6ICdib3JkZXItYm94JywgZGlzcGxheTogJ2ZsZXgnLCBoZWlnaHQ6ICcxMDAlJywganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgd2lkdGg6ICcxMDAlJywgekluZGV4OiA0IH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhyZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3Quc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjoganN4KFR5cG9ncmFwaHksIHsgZm9udFN0eWxlOiBcIml0YWxpY1wiLCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLmRyb3BUb0dyb3VwQnkucmVwbGFjZSgne2NvbHVtbn0nLCAoX2MgPSAoX2IgPSBkcmFnZ2luZ0NvbHVtbiA9PT0gbnVsbCB8fCBkcmFnZ2luZ0NvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ2dpbmdDb2x1bW4uY29sdW1uRGVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJykgfSkgfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Cb3R0b21Ub29sYmFyID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVQYWdpbmF0aW9uLCBtdWlCb3R0b21Ub29sYmFyUHJvcHMsIHBvc2l0aW9uUGFnaW5hdGlvbiwgcG9zaXRpb25Ub29sYmFyQWxlcnRCYW5uZXIsIHBvc2l0aW9uVG9vbGJhckRyb3Bab25lLCByZW5kZXJCb3R0b21Ub29sYmFyQ3VzdG9tQWN0aW9ucywgfSwgcmVmczogeyBib3R0b21Ub29sYmFyUmVmIH0sIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGlzRnVsbFNjcmVlbiB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc01vYmlsZSA9IHVzZU1lZGlhUXVlcnkoJyhtYXgtd2lkdGg6NzIwcHgpJyk7XG4gICAgY29uc3QgdG9vbGJhclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMobXVpQm90dG9tVG9vbGJhclByb3BzLCB7IHRhYmxlIH0pKSwgcmVzdCk7XG4gICAgY29uc3Qgc3RhY2tBbGVydEJhbm5lciA9IGlzTW9iaWxlIHx8ICEhcmVuZGVyQm90dG9tVG9vbGJhckN1c3RvbUFjdGlvbnM7XG4gICAgcmV0dXJuIChqc3hzKEJveCwgT2JqZWN0LmFzc2lnbih7fSwgdG9vbGJhclByb3BzLCB7IHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tVG9vbGJhclJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJQcm9wcy5yZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzeDogKHRoZW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldENvbW1vblRvb2xiYXJTdHlsZXMoeyB0YWJsZSwgdGhlbWUgfSkpLCB7IGJvdHRvbTogaXNGdWxsU2NyZWVuID8gJzAnIDogdW5kZWZpbmVkLCBib3hTaGFkb3c6IGAwIDFweCAycHggLTFweCAke2FscGhhKHRoZW1lLnBhbGV0dGUuZ3JleVs3MDBdLCAwLjUpfSBpbnNldGAsIGxlZnQ6IDAsIHBvc2l0aW9uOiBpc0Z1bGxTY3JlZW4gPyAnZml4ZWQnIDogJ3JlbGF0aXZlJywgcmlnaHQ6IDAgfSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0b29sYmFyUHJvcHMgPT09IG51bGwgfHwgdG9vbGJhclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b29sYmFyUHJvcHMuc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogW2pzeChNUlRfTGluZWFyUHJvZ3Jlc3NCYXIsIHsgaXNUb3BUb29sYmFyOiBmYWxzZSwgdGFibGU6IHRhYmxlIH0pLCBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciA9PT0gJ2JvdHRvbScgJiYgKGpzeChNUlRfVG9vbGJhckFsZXJ0QmFubmVyLCB7IHN0YWNrQWxlcnRCYW5uZXI6IHN0YWNrQWxlcnRCYW5uZXIsIHRhYmxlOiB0YWJsZSB9KSksIFsnYm90aCcsICdib3R0b20nXS5pbmNsdWRlcyhwb3NpdGlvblRvb2xiYXJEcm9wWm9uZSAhPT0gbnVsbCAmJiBwb3NpdGlvblRvb2xiYXJEcm9wWm9uZSAhPT0gdm9pZCAwID8gcG9zaXRpb25Ub29sYmFyRHJvcFpvbmUgOiAnJykgJiYgKGpzeChNUlRfVG9vbGJhckRyb3Bab25lLCB7IHRhYmxlOiB0YWJsZSB9KSksIGpzeHMoQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgICAgICAgICBwOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW3JlbmRlckJvdHRvbVRvb2xiYXJDdXN0b21BY3Rpb25zID8gKHJlbmRlckJvdHRvbVRvb2xiYXJDdXN0b21BY3Rpb25zKHsgdGFibGUgfSkpIDogKGpzeChcInNwYW5cIiwge30pKSwganN4KEJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhY2tBbGVydEJhbm5lciA/ICdyZWxhdGl2ZScgOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBlbmFibGVQYWdpbmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWydib3RoJywgJ2JvdHRvbSddLmluY2x1ZGVzKHBvc2l0aW9uUGFnaW5hdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvblBhZ2luYXRpb24gIT09IHZvaWQgMCA/IHBvc2l0aW9uUGFnaW5hdGlvbiA6ICcnKSAmJiAoanN4KE1SVF9UYWJsZVBhZ2luYXRpb24sIHsgcG9zaXRpb246IFwiYm90dG9tXCIsIHRhYmxlOiB0YWJsZSB9KSkgfSldIH0pXSB9KSkpO1xufTtcblxuY29uc3QgTVJUX0NvbHVtblBpbm5pbmdCdXR0b25zID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgY29sdW1uLCB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNvbHVtblwiLCBcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWNvbnM6IHsgUHVzaFBpbkljb24gfSwgbG9jYWxpemF0aW9uLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgaGFuZGxlUGluQ29sdW1uID0gKHBpbkRpcmVjdGlvbikgPT4ge1xuICAgICAgICBjb2x1bW4ucGluKHBpbkRpcmVjdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChCb3gsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBtaW5XaWR0aDogJzcwcHgnLCB0ZXh0QWxpZ246ICdjZW50ZXInIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYyhyZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3Quc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogY29sdW1uLmdldElzUGlubmVkKCkgPyAoanN4KFRvb2x0aXAsIHsgdGl0bGU6IGxvY2FsaXphdGlvbi51bnBpbiwgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IGhhbmRsZVBpbkNvbHVtbihmYWxzZSksIHNpemU6IFwic21hbGxcIiwgY2hpbGRyZW46IGpzeChQdXNoUGluSWNvbiwge30pIH0pIH0pKSA6IChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFRvb2x0aXAsIHsgdGl0bGU6IGxvY2FsaXphdGlvbi5waW5Ub0xlZnQsIGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBoYW5kbGVQaW5Db2x1bW4oJ2xlZnQnKSwgc2l6ZTogXCJzbWFsbFwiLCBjaGlsZHJlbjoganN4KFB1c2hQaW5JY29uLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSg5MGRlZyknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkgfSkgfSksIGpzeChUb29sdGlwLCB7IHRpdGxlOiBsb2NhbGl6YXRpb24ucGluVG9SaWdodCwgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IGhhbmRsZVBpbkNvbHVtbigncmlnaHQnKSwgc2l6ZTogXCJzbWFsbFwiLCBjaGlsZHJlbjoganN4KFB1c2hQaW5JY29uLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtOTBkZWcpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pIH0pIH0pXSB9KSkgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9TaG93SGlkZUNvbHVtbnNNZW51SXRlbXMgPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgYWxsQ29sdW1ucywgY29sdW1uLCBob3ZlcmVkQ29sdW1uLCBpc05lc3RlZENvbHVtbnMsIHNldEhvdmVyZWRDb2x1bW4sIHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiYWxsQ29sdW1uc1wiLCBcImNvbHVtblwiLCBcImhvdmVyZWRDb2x1bW5cIiwgXCJpc05lc3RlZENvbHVtbnNcIiwgXCJzZXRIb3ZlcmVkQ29sdW1uXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlQ29sdW1uT3JkZXJpbmcsIGVuYWJsZUNvbHVtblBpbm5pbmcsIGVuYWJsZUhpZGluZywgbG9jYWxpemF0aW9uLCBtcnRUaGVtZTogeyBkcmFnZ2luZ0JvcmRlckNvbG9yIH0sIH0sIHNldENvbHVtbk9yZGVyLCBzZXRDb2x1bW5QaW5uaW5nLCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW5PcmRlciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IGNvbHVtbkRlZiB9ID0gY29sdW1uO1xuICAgIGNvbnN0IHsgY29sdW1uRGVmVHlwZSB9ID0gY29sdW1uRGVmO1xuICAgIGNvbnN0IHN3aXRjaENoZWNrZWQgPSBjb2x1bW4uZ2V0SXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlQ29sdW1uSGlkZGVuID0gKGNvbHVtbikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoY29sdW1uRGVmVHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uLmNvbHVtbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgKGNoaWxkQ29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRDb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSghc3dpdGNoQ2hlY2tlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1lbnVJdGVtUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZSkgPT4ge1xuICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKG1lbnVJdGVtUmVmLmN1cnJlbnQsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKF9lKSA9PiB7XG4gICAgICAgIHNldElzRHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICBzZXRIb3ZlcmVkQ29sdW1uKG51bGwpO1xuICAgICAgICBpZiAoaG92ZXJlZENvbHVtbikge1xuICAgICAgICAgICAgY29uc3QgcmVvcmRlcmVkQ29sdW1ucyA9IHJlb3JkZXJDb2x1bW4oY29sdW1uLCBob3ZlcmVkQ29sdW1uLCBjb2x1bW5PcmRlcik7XG4gICAgICAgICAgICBzZXRDb2x1bW5PcmRlcihyZW9yZGVyZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIHNldENvbHVtblBpbm5pbmcoKHsgbGVmdCA9IFtdLCByaWdodCA9IFtdIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgbGVmdDogcmVvcmRlcmVkQ29sdW1ucy5maWx0ZXIoaGVhZGVyID0+IGxlZnQuaW5jbHVkZXMoaGVhZGVyKSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJlb3JkZXJlZENvbHVtbnMuZmlsdGVyKGhlYWRlciA9PiByaWdodC5pbmNsdWRlcyhoZWFkZXIpKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKF9lKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyAmJiBjb2x1bW5EZWYuZW5hYmxlQ29sdW1uT3JkZXJpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkQ29sdW1uKGNvbHVtbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICghY29sdW1uRGVmLmhlYWRlciB8fCBjb2x1bW5EZWYudmlzaWJsZUluU2hvd0hpZGVNZW51ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KE1lbnVJdGVtLCBPYmplY3QuYXNzaWduKHsgZGlzYWJsZVJpcHBsZTogdHJ1ZSwgb25EcmFnRW50ZXI6IGhhbmRsZURyYWdFbnRlciwgcmVmOiBtZW51SXRlbVJlZiB9LCByZXN0LCB7IHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKHsgYWxpZ25JdGVtczogJ2NlbnRlcicsIGp1c3RpZnlDb250ZW50OiAnZmxleC1zdGFydCcsIG15OiAwLCBvcGFjaXR5OiBpc0RyYWdnaW5nID8gMC41IDogMSwgb3V0bGluZTogaXNEcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBgMnB4IGRhc2hlZCAke3RoZW1lLnBhbGV0dGUuZ3JleVs1MDBdfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGhvdmVyZWRDb2x1bW4gPT09IG51bGwgfHwgaG92ZXJlZENvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJlZENvbHVtbi5pZCkgPT09IGNvbHVtbi5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYDJweCBkYXNoZWQgJHtkcmFnZ2luZ0JvcmRlckNvbG9yfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdub25lJywgb3V0bGluZU9mZnNldDogJy0ycHgnLCBwbDogYCR7KGNvbHVtbi5kZXB0aCArIDAuNSkgKiAyfXJlbWAsIHB5OiAnNnB4JyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMocmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IGpzeHMoQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4V3JhcDogJ25vd3JhcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXA6ICc4cHgnLFxuICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2NvbHVtbkRlZlR5cGUgIT09ICdncm91cCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVDb2x1bW5PcmRlcmluZyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc05lc3RlZENvbHVtbnMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29sdW1uRGVmLmVuYWJsZUNvbHVtbk9yZGVyaW5nICE9PSBmYWxzZSA/IChqc3goTVJUX0dyYWJIYW5kbGVCdXR0b24sIHsgb25EcmFnRW5kOiBoYW5kbGVEcmFnRW5kLCBvbkRyYWdTdGFydDogaGFuZGxlRHJhZ1N0YXJ0LCB0YWJsZTogdGFibGUgfSkpIDogKGpzeChCb3gsIHsgc3g6IHsgd2lkdGg6ICcyOHB4JyB9IH0pKSksIGVuYWJsZUNvbHVtblBpbm5pbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29sdW1uLmdldENhblBpbigpID8gKGpzeChNUlRfQ29sdW1uUGlubmluZ0J1dHRvbnMsIHsgY29sdW1uOiBjb2x1bW4sIHRhYmxlOiB0YWJsZSB9KSkgOiAoanN4KEJveCwgeyBzeDogeyB3aWR0aDogJzcwcHgnIH0gfSkpKSwgZW5hYmxlSGlkaW5nID8gKGpzeChGb3JtQ29udHJvbExhYmVsLCB7IGNoZWNrZWQ6IHN3aXRjaENoZWNrZWQsIGNvbXBvbmVudHNQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBvZ3JhcGh5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGNvbHVtbkRlZlR5cGUgIT09ICdkaXNwbGF5JyA/IDEgOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbnRyb2w6IGpzeChUb29sdGlwLCBPYmplY3QuYXNzaWduKHt9LCBnZXRDb21tb25Ub29sdGlwUHJvcHMoKSwgeyB0aXRsZTogbG9jYWxpemF0aW9uLnRvZ2dsZVZpc2liaWxpdHksIGNoaWxkcmVuOiBqc3goU3dpdGNoLCB7fSkgfSkpLCBkaXNhYmxlZDogIWNvbHVtbi5nZXRDYW5IaWRlKCksIGxhYmVsOiBjb2x1bW5EZWYuaGVhZGVyLCBvbkNoYW5nZTogKCkgPT4gaGFuZGxlVG9nZ2xlQ29sdW1uSGlkZGVuKGNvbHVtbikgfSkpIDogKGpzeChUeXBvZ3JhcGh5LCB7IHN4OiB7IGFsaWduU2VsZjogJ2NlbnRlcicgfSwgY2hpbGRyZW46IGNvbHVtbkRlZi5oZWFkZXIgfSkpXSB9KSB9KSksIChfYiA9IGNvbHVtbi5jb2x1bW5zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChjLCBpKSA9PiAoanN4KE1SVF9TaG93SGlkZUNvbHVtbnNNZW51SXRlbXMsIHsgYWxsQ29sdW1uczogYWxsQ29sdW1ucywgY29sdW1uOiBjLCBob3ZlcmVkQ29sdW1uOiBob3ZlcmVkQ29sdW1uLCBpc05lc3RlZENvbHVtbnM6IGlzTmVzdGVkQ29sdW1ucywgc2V0SG92ZXJlZENvbHVtbjogc2V0SG92ZXJlZENvbHVtbiwgdGFibGU6IHRhYmxlIH0sIGAke2l9LSR7Yy5pZH1gKSkpXSB9KSk7XG59O1xuXG5jb25zdCBNUlRfU2hvd0hpZGVDb2x1bW5zTWVudSA9IChfYSkgPT4ge1xuICAgIHZhciB7IGFuY2hvckVsLCBzZXRBbmNob3JFbCwgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJhbmNob3JFbFwiLCBcInNldEFuY2hvckVsXCIsIFwidGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0QWxsQ29sdW1ucywgZ2V0QWxsTGVhZkNvbHVtbnMsIGdldENlbnRlckxlYWZDb2x1bW5zLCBnZXRJc0FsbENvbHVtbnNWaXNpYmxlLCBnZXRJc1NvbWVDb2x1bW5zUGlubmVkLCBnZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSwgZ2V0TGVmdExlYWZDb2x1bW5zLCBnZXRSaWdodExlYWZDb2x1bW5zLCBnZXRTdGF0ZSwgaW5pdGlhbFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZUNvbHVtbk9yZGVyaW5nLCBlbmFibGVDb2x1bW5QaW5uaW5nLCBlbmFibGVIaWRpbmcsIGxvY2FsaXphdGlvbiwgbXJ0VGhlbWU6IHsgbWVudUJhY2tncm91bmRDb2xvciB9LCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBjb2x1bW5PcmRlciwgY29sdW1uUGlubmluZywgZGVuc2l0eSB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBoYW5kbGVUb2dnbGVBbGxDb2x1bW5zID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGdldEFsbExlYWZDb2x1bW5zKClcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvbCkgPT4gY29sLmNvbHVtbkRlZi5lbmFibGVIaWRpbmcgIT09IGZhbHNlKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbCkgPT4gY29sLnRvZ2dsZVZpc2liaWxpdHkodmFsdWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGFsbENvbHVtbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IGdldEFsbENvbHVtbnMoKTtcbiAgICAgICAgaWYgKGNvbHVtbk9yZGVyLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICFjb2x1bW5zLnNvbWUoKGNvbCkgPT4gY29sLmNvbHVtbkRlZi5jb2x1bW5EZWZUeXBlID09PSAnZ3JvdXAnKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5nZXRMZWZ0TGVhZkNvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKG5ldyBTZXQoY29sdW1uT3JkZXIpKS5tYXAoKGNvbElkKSA9PiBnZXRDZW50ZXJMZWFmQ29sdW1ucygpLmZpbmQoKGNvbCkgPT4gKGNvbCA9PT0gbnVsbCB8fCBjb2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbC5pZCkgPT09IGNvbElkKSksXG4gICAgICAgICAgICAgICAgLi4uZ2V0UmlnaHRMZWFmQ29sdW1ucygpLFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfSwgW1xuICAgICAgICBjb2x1bW5PcmRlcixcbiAgICAgICAgY29sdW1uUGlubmluZyxcbiAgICAgICAgZ2V0QWxsQ29sdW1ucygpLFxuICAgICAgICBnZXRDZW50ZXJMZWFmQ29sdW1ucygpLFxuICAgICAgICBnZXRMZWZ0TGVhZkNvbHVtbnMoKSxcbiAgICAgICAgZ2V0UmlnaHRMZWFmQ29sdW1ucygpLFxuICAgIF0pO1xuICAgIGNvbnN0IGlzTmVzdGVkQ29sdW1ucyA9IGFsbENvbHVtbnMuc29tZSgoY29sKSA9PiBjb2wuY29sdW1uRGVmLmNvbHVtbkRlZlR5cGUgPT09ICdncm91cCcpO1xuICAgIGNvbnN0IGhhc0NvbHVtbk9yZGVyQ2hhbmdlZCA9IHVzZU1lbW8oKCkgPT4gY29sdW1uT3JkZXIubGVuZ3RoICE9PSBpbml0aWFsU3RhdGUuY29sdW1uT3JkZXIubGVuZ3RoIHx8XG4gICAgICAgICFjb2x1bW5PcmRlci5ldmVyeSgoY29sdW1uLCBpbmRleCkgPT4gY29sdW1uID09PSBpbml0aWFsU3RhdGUuY29sdW1uT3JkZXJbaW5kZXhdKSwgW2NvbHVtbk9yZGVyLCBpbml0aWFsU3RhdGUuY29sdW1uT3JkZXJdKTtcbiAgICBjb25zdCBbaG92ZXJlZENvbHVtbiwgc2V0SG92ZXJlZENvbHVtbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICByZXR1cm4gKGpzeHMoTWVudSwgT2JqZWN0LmFzc2lnbih7IE1lbnVMaXN0UHJvcHM6IHtcbiAgICAgICAgICAgIGRlbnNlOiBkZW5zaXR5ID09PSAnY29tcGFjdCcsXG4gICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbWVudUJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFuY2hvckVsOiBhbmNob3JFbCwgZGlzYWJsZVNjcm9sbExvY2s6IHRydWUsIG9uQ2xvc2U6ICgpID0+IHNldEFuY2hvckVsKG51bGwpLCBvcGVuOiAhIWFuY2hvckVsIH0sIHJlc3QsIHsgY2hpbGRyZW46IFtqc3hzKEJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgICAgIHA6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgICAgICBwdDogMCxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2VuYWJsZUhpZGluZyAmJiAoanN4KEJ1dHRvbiwgeyBkaXNhYmxlZDogIWdldElzU29tZUNvbHVtbnNWaXNpYmxlKCksIG9uQ2xpY2s6ICgpID0+IGhhbmRsZVRvZ2dsZUFsbENvbHVtbnMoZmFsc2UpLCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLmhpZGVBbGwgfSkpLCBlbmFibGVDb2x1bW5PcmRlcmluZyAmJiAoanN4KEJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiB0YWJsZS5zZXRDb2x1bW5PcmRlcihnZXREZWZhdWx0Q29sdW1uT3JkZXJJZHModGFibGUub3B0aW9ucywgdHJ1ZSkpLCBkaXNhYmxlZDogIWhhc0NvbHVtbk9yZGVyQ2hhbmdlZCwgY2hpbGRyZW46IGxvY2FsaXphdGlvbi5yZXNldE9yZGVyIH0pKSwgZW5hYmxlQ29sdW1uUGlubmluZyAmJiAoanN4KEJ1dHRvbiwgeyBkaXNhYmxlZDogIWdldElzU29tZUNvbHVtbnNQaW5uZWQoKSwgb25DbGljazogKCkgPT4gdGFibGUucmVzZXRDb2x1bW5QaW5uaW5nKHRydWUpLCBjaGlsZHJlbjogbG9jYWxpemF0aW9uLnVucGluQWxsIH0pKSwgZW5hYmxlSGlkaW5nICYmIChqc3goQnV0dG9uLCB7IGRpc2FibGVkOiBnZXRJc0FsbENvbHVtbnNWaXNpYmxlKCksIG9uQ2xpY2s6ICgpID0+IGhhbmRsZVRvZ2dsZUFsbENvbHVtbnModHJ1ZSksIGNoaWxkcmVuOiBsb2NhbGl6YXRpb24uc2hvd0FsbCB9KSldIH0pLCBqc3goRGl2aWRlciwge30pLCBhbGxDb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gKGpzeChNUlRfU2hvd0hpZGVDb2x1bW5zTWVudUl0ZW1zLCB7IGFsbENvbHVtbnM6IGFsbENvbHVtbnMsIGNvbHVtbjogY29sdW1uLCBob3ZlcmVkQ29sdW1uOiBob3ZlcmVkQ29sdW1uLCBpc05lc3RlZENvbHVtbnM6IGlzTmVzdGVkQ29sdW1ucywgc2V0SG92ZXJlZENvbHVtbjogc2V0SG92ZXJlZENvbHVtbiwgdGFibGU6IHRhYmxlIH0sIGAke2luZGV4fS0ke2NvbHVtbi5pZH1gKSkpXSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1Nob3dIaWRlQ29sdW1uc0J1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciBfYjtcbiAgICB2YXIgeyB0YWJsZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRhYmxlXCJdKTtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgaWNvbnM6IHsgVmlld0NvbHVtbkljb24gfSwgbG9jYWxpemF0aW9uLCB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgW2FuY2hvckVsLCBzZXRBbmNob3JFbF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXRBbmNob3JFbChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChUb29sdGlwLCB7IHRpdGxlOiAoX2IgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxvY2FsaXphdGlvbi5zaG93SGlkZUNvbHVtbnMsIGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uc2hvd0hpZGVDb2x1bW5zLCBvbkNsaWNrOiBoYW5kbGVDbGljayB9LCByZXN0LCB7IHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBqc3goVmlld0NvbHVtbkljb24sIHt9KSB9KSkgfSksIGFuY2hvckVsICYmIChqc3goTVJUX1Nob3dIaWRlQ29sdW1uc01lbnUsIHsgYW5jaG9yRWw6IGFuY2hvckVsLCBzZXRBbmNob3JFbDogc2V0QW5jaG9yRWwsIHRhYmxlOiB0YWJsZSB9KSldIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub2dnbGVEZW5zZVBhZGRpbmdCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBpY29uczogeyBEZW5zaXR5TGFyZ2VJY29uLCBEZW5zaXR5TWVkaXVtSWNvbiwgRGVuc2l0eVNtYWxsSWNvbiB9LCBsb2NhbGl6YXRpb24sIH0sIHNldERlbnNpdHksIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGRlbnNpdHkgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlRGVuc2VQYWRkaW5nID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0RGVuc2l0eSA9IGRlbnNpdHkgPT09ICdjb21mb3J0YWJsZSdcbiAgICAgICAgICAgID8gJ2NvbXBhY3QnXG4gICAgICAgICAgICA6IGRlbnNpdHkgPT09ICdjb21wYWN0J1xuICAgICAgICAgICAgICAgID8gJ3NwYWNpb3VzJ1xuICAgICAgICAgICAgICAgIDogJ2NvbWZvcnRhYmxlJztcbiAgICAgICAgc2V0RGVuc2l0eShuZXh0RGVuc2l0eSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChUb29sdGlwLCB7IHRpdGxlOiAoX2IgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxvY2FsaXphdGlvbi50b2dnbGVEZW5zaXR5LCBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogbG9jYWxpemF0aW9uLnRvZ2dsZURlbnNpdHksIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZURlbnNlUGFkZGluZyB9LCByZXN0LCB7IHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBkZW5zaXR5ID09PSAnY29tcGFjdCcgPyAoanN4KERlbnNpdHlTbWFsbEljb24sIHt9KSkgOiBkZW5zaXR5ID09PSAnY29tZm9ydGFibGUnID8gKGpzeChEZW5zaXR5TWVkaXVtSWNvbiwge30pKSA6IChqc3goRGVuc2l0eUxhcmdlSWNvbiwge30pKSB9KSkgfSkpO1xufTtcblxuY29uc3QgTVJUX1RvZ2dsZUZpbHRlcnNCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBpY29uczogeyBGaWx0ZXJMaXN0SWNvbiwgRmlsdGVyTGlzdE9mZkljb24gfSwgbG9jYWxpemF0aW9uLCB9LCBzZXRTaG93Q29sdW1uRmlsdGVycywgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgc2hvd0NvbHVtbkZpbHRlcnMgfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlVG9nZ2xlU2hvd0ZpbHRlcnMgPSAoKSA9PiB7XG4gICAgICAgIHNldFNob3dDb2x1bW5GaWx0ZXJzKCFzaG93Q29sdW1uRmlsdGVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChUb29sdGlwLCB7IHRpdGxlOiAoX2IgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxvY2FsaXphdGlvbi5zaG93SGlkZUZpbHRlcnMsIGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uc2hvd0hpZGVGaWx0ZXJzLCBvbkNsaWNrOiBoYW5kbGVUb2dnbGVTaG93RmlsdGVycyB9LCByZXN0LCB7IHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBzaG93Q29sdW1uRmlsdGVycyA/IGpzeChGaWx0ZXJMaXN0T2ZmSWNvbiwge30pIDoganN4KEZpbHRlckxpc3RJY29uLCB7fSkgfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub2dnbGVGdWxsU2NyZWVuQnV0dG9uID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgRnVsbHNjcmVlbkV4aXRJY29uLCBGdWxsc2NyZWVuSWNvbiB9LCBsb2NhbGl6YXRpb24sIH0sIHNldElzRnVsbFNjcmVlbiwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgaXNGdWxsU2NyZWVuIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IFt0b29sdGlwT3BlbmVkLCBzZXRUb29sdGlwT3BlbmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBoYW5kbGVUb2dnbGVGdWxsU2NyZWVuID0gKCkgPT4ge1xuICAgICAgICBzZXRUb29sdGlwT3BlbmVkKGZhbHNlKTtcbiAgICAgICAgc2V0SXNGdWxsU2NyZWVuKCFpc0Z1bGxTY3JlZW4pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgeyBvcGVuOiB0b29sdGlwT3BlbmVkLCB0aXRsZTogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24udG9nZ2xlRnVsbFNjcmVlbiwgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi50b2dnbGVGdWxsU2NyZWVuLCBvbkJsdXI6ICgpID0+IHNldFRvb2x0aXBPcGVuZWQoZmFsc2UpLCBvbkNsaWNrOiBoYW5kbGVUb2dnbGVGdWxsU2NyZWVuLCBvbkZvY3VzOiAoKSA9PiBzZXRUb29sdGlwT3BlbmVkKHRydWUpLCBvbk1vdXNlRW50ZXI6ICgpID0+IHNldFRvb2x0aXBPcGVuZWQodHJ1ZSksIG9uTW91c2VMZWF2ZTogKCkgPT4gc2V0VG9vbHRpcE9wZW5lZChmYWxzZSkgfSwgcmVzdCwgeyB0aXRsZTogdW5kZWZpbmVkLCBjaGlsZHJlbjogaXNGdWxsU2NyZWVuID8ganN4KEZ1bGxzY3JlZW5FeGl0SWNvbiwge30pIDoganN4KEZ1bGxzY3JlZW5JY29uLCB7fSkgfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub2dnbGVHbG9iYWxGaWx0ZXJCdXR0b24gPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgaWNvbnM6IHsgU2VhcmNoSWNvbiwgU2VhcmNoT2ZmSWNvbiB9LCBsb2NhbGl6YXRpb24sIH0sIHJlZnM6IHsgc2VhcmNoSW5wdXRSZWYgfSwgc2V0U2hvd0dsb2JhbEZpbHRlciwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyLCBzaG93R2xvYmFsRmlsdGVyIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGhhbmRsZVRvZ2dsZVNlYXJjaCA9ICgpID0+IHtcbiAgICAgICAgc2V0U2hvd0dsb2JhbEZpbHRlcighc2hvd0dsb2JhbEZpbHRlcik7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gc2VhcmNoSW5wdXRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3goVG9vbHRpcCwgeyB0aXRsZTogKF9iID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0LnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsb2NhbGl6YXRpb24uc2hvd0hpZGVTZWFyY2gsIGNoaWxkcmVuOiBqc3goSWNvbkJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1sYWJlbFwiOiAoX2MgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QudGl0bGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGxvY2FsaXphdGlvbi5zaG93SGlkZVNlYXJjaCwgZGlzYWJsZWQ6ICEhZ2xvYmFsRmlsdGVyICYmIHNob3dHbG9iYWxGaWx0ZXIsIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZVNlYXJjaCB9LCByZXN0LCB7IHRpdGxlOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBzaG93R2xvYmFsRmlsdGVyID8ganN4KFNlYXJjaE9mZkljb24sIHt9KSA6IGpzeChTZWFyY2hJY29uLCB7fSkgfSkpIH0pKTtcbn07XG5cbmNvbnN0IE1SVF9Ub29sYmFySW50ZXJuYWxCdXR0b25zID0gKF9hKSA9PiB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBjb2x1bW5GaWx0ZXJEaXNwbGF5TW9kZSwgZW5hYmxlQ29sdW1uRmlsdGVycywgZW5hYmxlQ29sdW1uT3JkZXJpbmcsIGVuYWJsZUNvbHVtblBpbm5pbmcsIGVuYWJsZURlbnNpdHlUb2dnbGUsIGVuYWJsZUZpbHRlcnMsIGVuYWJsZUZ1bGxTY3JlZW5Ub2dnbGUsIGVuYWJsZUdsb2JhbEZpbHRlciwgZW5hYmxlSGlkaW5nLCBpbml0aWFsU3RhdGUsIHJlbmRlclRvb2xiYXJJbnRlcm5hbEFjdGlvbnMsIH0sIH0gPSB0YWJsZTtcbiAgICByZXR1cm4gKGpzeChCb3gsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIHsgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZGlzcGxheTogJ2ZsZXgnLCB6SW5kZXg6IDMgfSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5zeCwgdGhlbWUpKSksIGNoaWxkcmVuOiAoX2IgPSByZW5kZXJUb29sYmFySW50ZXJuYWxBY3Rpb25zID09PSBudWxsIHx8IHJlbmRlclRvb2xiYXJJbnRlcm5hbEFjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlclRvb2xiYXJJbnRlcm5hbEFjdGlvbnMoe1xuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2VuYWJsZUZpbHRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlR2xvYmFsRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICEoaW5pdGlhbFN0YXRlID09PSBudWxsIHx8IGluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFN0YXRlLnNob3dHbG9iYWxGaWx0ZXIpICYmIChqc3goTVJUX1RvZ2dsZUdsb2JhbEZpbHRlckJ1dHRvbiwgeyB0YWJsZTogdGFibGUgfSkpLCBlbmFibGVGaWx0ZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUNvbHVtbkZpbHRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uRmlsdGVyRGlzcGxheU1vZGUgIT09ICdwb3BvdmVyJyAmJiAoanN4KE1SVF9Ub2dnbGVGaWx0ZXJzQnV0dG9uLCB7IHRhYmxlOiB0YWJsZSB9KSksIChlbmFibGVIaWRpbmcgfHwgZW5hYmxlQ29sdW1uT3JkZXJpbmcgfHwgZW5hYmxlQ29sdW1uUGlubmluZykgJiYgKGpzeChNUlRfU2hvd0hpZGVDb2x1bW5zQnV0dG9uLCB7IHRhYmxlOiB0YWJsZSB9KSksIGVuYWJsZURlbnNpdHlUb2dnbGUgJiYgKGpzeChNUlRfVG9nZ2xlRGVuc2VQYWRkaW5nQnV0dG9uLCB7IHRhYmxlOiB0YWJsZSB9KSksIGVuYWJsZUZ1bGxTY3JlZW5Ub2dnbGUgJiYgKGpzeChNUlRfVG9nZ2xlRnVsbFNjcmVlbkJ1dHRvbiwgeyB0YWJsZTogdGFibGUgfSkpXSB9KSkgfSkpKTtcbn07XG5cbmNvbnN0IE1SVF9HbG9iYWxGaWx0ZXJUZXh0RmllbGQgPSAoX2EpID0+IHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHsgdGFibGUgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0YWJsZVwiXSk7XG4gICAgY29uc3QgeyBnZXRTdGF0ZSwgb3B0aW9uczogeyBlbmFibGVHbG9iYWxGaWx0ZXJNb2RlcywgaWNvbnM6IHsgQ2xvc2VJY29uLCBTZWFyY2hJY29uIH0sIGxvY2FsaXphdGlvbiwgbWFudWFsRmlsdGVyaW5nLCBtdWlTZWFyY2hUZXh0RmllbGRQcm9wcywgfSwgcmVmczogeyBzZWFyY2hJbnB1dFJlZiB9LCBzZXRHbG9iYWxGaWx0ZXIsIH0gPSB0YWJsZTtcbiAgICBjb25zdCB7IGdsb2JhbEZpbHRlciwgc2hvd0dsb2JhbEZpbHRlciB9ID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0ZXh0RmllbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVNlYXJjaFRleHRGaWVsZFByb3BzLCB7XG4gICAgICAgIHRhYmxlLFxuICAgIH0pKSwgcmVzdCk7XG4gICAgY29uc3QgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBbYW5jaG9yRWwsIHNldEFuY2hvckVsXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzZWFyY2hWYWx1ZSwgc2V0U2VhcmNoVmFsdWVdID0gdXNlU3RhdGUoZ2xvYmFsRmlsdGVyICE9PSBudWxsICYmIGdsb2JhbEZpbHRlciAhPT0gdm9pZCAwID8gZ2xvYmFsRmlsdGVyIDogJycpO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZURlYm91bmNlZCA9IHVzZUNhbGxiYWNrKGRlYm91bmNlKChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHNldEdsb2JhbEZpbHRlcigoX2EgPSBldmVudC50YXJnZXQudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCk7XG4gICAgfSwgbWFudWFsRmlsdGVyaW5nID8gNTAwIDogMjUwKSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXRTZWFyY2hWYWx1ZShldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICBoYW5kbGVDaGFuZ2VEZWJvdW5jZWQoZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlR2xvYmFsRmlsdGVyTWVudU9wZW4gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0QW5jaG9yRWwoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDbGVhciA9ICgpID0+IHtcbiAgICAgICAgc2V0U2VhcmNoVmFsdWUoJycpO1xuICAgICAgICBzZXRHbG9iYWxGaWx0ZXIodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbEZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFNlYXJjaFZhbHVlKGdsb2JhbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtnbG9iYWxGaWx0ZXJdKTtcbiAgICByZXR1cm4gKGpzeHMoQ29sbGFwc2UsIHsgaW46IHNob3dHbG9iYWxGaWx0ZXIsIG1vdW50T25FbnRlcjogdHJ1ZSwgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLCB1bm1vdW50T25FeGl0OiB0cnVlLCBjaGlsZHJlbjogW2pzeChUZXh0RmllbGQsIE9iamVjdC5hc3NpZ24oeyBpbnB1dFByb3BzOiBPYmplY3QuYXNzaWduKHsgYXV0b0NvbXBsZXRlOiAnb2ZmJyB9LCB0ZXh0RmllbGRQcm9wcy5pbnB1dFByb3BzKSwgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSwgcGxhY2Vob2xkZXI6IGxvY2FsaXphdGlvbi5zZWFyY2gsIHNpemU6IFwic21hbGxcIiwgdmFsdWU6IHNlYXJjaFZhbHVlICE9PSBudWxsICYmIHNlYXJjaFZhbHVlICE9PSB2b2lkIDAgPyBzZWFyY2hWYWx1ZSA6ICcnLCB2YXJpYW50OiBcIm91dGxpbmVkXCIgfSwgdGV4dEZpZWxkUHJvcHMsIHsgSW5wdXRQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZW5kQWRvcm5tZW50OiAoanN4KElucHV0QWRvcm5tZW50LCB7IHBvc2l0aW9uOiBcImVuZFwiLCBjaGlsZHJlbjoganN4KFRvb2x0aXAsIHsgdGl0bGU6IChfYiA9IGxvY2FsaXphdGlvbi5jbGVhclNlYXJjaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHsgY2hpbGRyZW46IGpzeChJY29uQnV0dG9uLCB7IFwiYXJpYS1sYWJlbFwiOiBsb2NhbGl6YXRpb24uY2xlYXJTZWFyY2gsIGRpc2FibGVkOiAhKHNlYXJjaFZhbHVlID09PSBudWxsIHx8IHNlYXJjaFZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hWYWx1ZS5sZW5ndGgpLCBvbkNsaWNrOiBoYW5kbGVDbGVhciwgc2l6ZTogXCJzbWFsbFwiLCBjaGlsZHJlbjoganN4KENsb3NlSWNvbiwge30pIH0pIH0pIH0pIH0pKSwgc3RhcnRBZG9ybm1lbnQ6IGVuYWJsZUdsb2JhbEZpbHRlck1vZGVzID8gKGpzeChJbnB1dEFkb3JubWVudCwgeyBwb3NpdGlvbjogXCJzdGFydFwiLCBjaGlsZHJlbjoganN4KFRvb2x0aXAsIHsgdGl0bGU6IGxvY2FsaXphdGlvbi5jaGFuZ2VTZWFyY2hNb2RlLCBjaGlsZHJlbjoganN4KEljb25CdXR0b24sIHsgXCJhcmlhLWxhYmVsXCI6IGxvY2FsaXphdGlvbi5jaGFuZ2VTZWFyY2hNb2RlLCBvbkNsaWNrOiBoYW5kbGVHbG9iYWxGaWx0ZXJNZW51T3Blbiwgc2l6ZTogXCJzbWFsbFwiLCBzeDogeyBoZWlnaHQ6ICcxLjc1cmVtJywgd2lkdGg6ICcxLjc1cmVtJyB9LCBjaGlsZHJlbjoganN4KFNlYXJjaEljb24sIHt9KSB9KSB9KSB9KSkgOiAoanN4KFNlYXJjaEljb24sIHsgc3R5bGU6IHsgbWFyZ2luUmlnaHQ6ICc0cHgnIH0gfSkpIH0sIHRleHRGaWVsZFByb3BzLklucHV0UHJvcHMpLCB7IHN4OiAodGhlbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbih7IG1iOiAwIH0sIHBhcnNlRnJvbVZhbHVlc09yRnVuYygoX2EgPSB0ZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEZpZWxkUHJvcHMuSW5wdXRQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN4LCB0aGVtZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwgaW5wdXRSZWY6IChpbnB1dFJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dFJlZi5jdXJyZW50ID0gaW5wdXRSZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0RmllbGRQcm9wcyA9PT0gbnVsbCB8fCB0ZXh0RmllbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEZpZWxkUHJvcHMuaW5wdXRSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGaWVsZFByb3BzLmlucHV0UmVmID0gaW5wdXRSZWY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IH0pKSwganN4KE1SVF9GaWx0ZXJPcHRpb25NZW51LCB7IGFuY2hvckVsOiBhbmNob3JFbCwgb25TZWxlY3Q6IGhhbmRsZUNsZWFyLCBzZXRBbmNob3JFbDogc2V0QW5jaG9yRWwsIHRhYmxlOiB0YWJsZSB9KV0gfSkpO1xufTtcblxuY29uc3QgTVJUX1RvcFRvb2xiYXIgPSAoeyB0YWJsZSwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdldFN0YXRlLCBvcHRpb25zOiB7IGVuYWJsZUdsb2JhbEZpbHRlciwgZW5hYmxlUGFnaW5hdGlvbiwgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9ucywgbXVpVG9wVG9vbGJhclByb3BzLCBwb3NpdGlvbkdsb2JhbEZpbHRlciwgcG9zaXRpb25QYWdpbmF0aW9uLCBwb3NpdGlvblRvb2xiYXJBbGVydEJhbm5lciwgcG9zaXRpb25Ub29sYmFyRHJvcFpvbmUsIHJlbmRlclRvcFRvb2xiYXJDdXN0b21BY3Rpb25zLCB9LCByZWZzOiB7IHRvcFRvb2xiYXJSZWYgfSwgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHsgaXNGdWxsU2NyZWVuLCBzaG93R2xvYmFsRmlsdGVyIH0gPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGlzTW9iaWxlID0gdXNlTWVkaWFRdWVyeSgnKG1heC13aWR0aDo3MjBweCknKTtcbiAgICBjb25zdCBpc1RhYmxldCA9IHVzZU1lZGlhUXVlcnkoJyhtYXgtd2lkdGg6MTAyNHB4KScpO1xuICAgIGNvbnN0IHRvb2xiYXJQcm9wcyA9IHBhcnNlRnJvbVZhbHVlc09yRnVuYyhtdWlUb3BUb29sYmFyUHJvcHMsIHsgdGFibGUgfSk7XG4gICAgY29uc3Qgc3RhY2tBbGVydEJhbm5lciA9IGlzTW9iaWxlIHx8XG4gICAgICAgICEhcmVuZGVyVG9wVG9vbGJhckN1c3RvbUFjdGlvbnMgfHxcbiAgICAgICAgKHNob3dHbG9iYWxGaWx0ZXIgJiYgaXNUYWJsZXQpO1xuICAgIGNvbnN0IGdsb2JhbEZpbHRlclByb3BzID0ge1xuICAgICAgICBzeDogIWlzVGFibGV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgdGFibGUsXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeHMoQm94LCBPYmplY3QuYXNzaWduKHt9LCB0b29sYmFyUHJvcHMsIHsgcmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgICB0b3BUb29sYmFyUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICBpZiAodG9vbGJhclByb3BzID09PSBudWxsIHx8IHRvb2xiYXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbGJhclByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB0b29sYmFyUHJvcHMucmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN4OiAodGhlbWUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0Q29tbW9uVG9vbGJhclN0eWxlcyh7IHRhYmxlLCB0aGVtZSB9KSksIHsgcG9zaXRpb246IGlzRnVsbFNjcmVlbiA/ICdzdGlja3knIDogJ3JlbGF0aXZlJywgdG9wOiBpc0Z1bGxTY3JlZW4gPyAnMCcgOiB1bmRlZmluZWQgfSksIHBhcnNlRnJvbVZhbHVlc09yRnVuYyh0b29sYmFyUHJvcHMgPT09IG51bGwgfHwgdG9vbGJhclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b29sYmFyUHJvcHMuc3gsIHRoZW1lKSkpLCBjaGlsZHJlbjogW3Bvc2l0aW9uVG9vbGJhckFsZXJ0QmFubmVyID09PSAndG9wJyAmJiAoanN4KE1SVF9Ub29sYmFyQWxlcnRCYW5uZXIsIHsgc3RhY2tBbGVydEJhbm5lcjogc3RhY2tBbGVydEJhbm5lciwgdGFibGU6IHRhYmxlIH0pKSwgWydib3RoJywgJ3RvcCddLmluY2x1ZGVzKHBvc2l0aW9uVG9vbGJhckRyb3Bab25lICE9PSBudWxsICYmIHBvc2l0aW9uVG9vbGJhckRyb3Bab25lICE9PSB2b2lkIDAgPyBwb3NpdGlvblRvb2xiYXJEcm9wWm9uZSA6ICcnKSAmJiAoanN4KE1SVF9Ub29sYmFyRHJvcFpvbmUsIHsgdGFibGU6IHRhYmxlIH0pKSwganN4cyhCb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICBnYXA6ICcwLjVyZW0nLFxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAgICAgICAgICAgICBwOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YWNrQWxlcnRCYW5uZXIgPyAncmVsYXRpdmUnIDogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2VuYWJsZUdsb2JhbEZpbHRlciAmJiBwb3NpdGlvbkdsb2JhbEZpbHRlciA9PT0gJ2xlZnQnICYmIChqc3goTVJUX0dsb2JhbEZpbHRlclRleHRGaWVsZCwgT2JqZWN0LmFzc2lnbih7fSwgZ2xvYmFsRmlsdGVyUHJvcHMpKSksIChfYSA9IHJlbmRlclRvcFRvb2xiYXJDdXN0b21BY3Rpb25zID09PSBudWxsIHx8IHJlbmRlclRvcFRvb2xiYXJDdXN0b21BY3Rpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJUb3BUb29sYmFyQ3VzdG9tQWN0aW9ucyh7IHRhYmxlIH0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBqc3goXCJzcGFuXCIsIHt9KSwgZW5hYmxlVG9vbGJhckludGVybmFsQWN0aW9ucyA/IChqc3hzKEJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4V3JhcDogJ3dyYXAtcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbZW5hYmxlR2xvYmFsRmlsdGVyICYmIHBvc2l0aW9uR2xvYmFsRmlsdGVyID09PSAncmlnaHQnICYmIChqc3goTVJUX0dsb2JhbEZpbHRlclRleHRGaWVsZCwgT2JqZWN0LmFzc2lnbih7fSwgZ2xvYmFsRmlsdGVyUHJvcHMpKSksIGpzeChNUlRfVG9vbGJhckludGVybmFsQnV0dG9ucywgeyB0YWJsZTogdGFibGUgfSldIH0pKSA6IChlbmFibGVHbG9iYWxGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uR2xvYmFsRmlsdGVyID09PSAncmlnaHQnICYmIChqc3goTVJUX0dsb2JhbEZpbHRlclRleHRGaWVsZCwgT2JqZWN0LmFzc2lnbih7fSwgZ2xvYmFsRmlsdGVyUHJvcHMpKSkpXSB9KSwgZW5hYmxlUGFnaW5hdGlvbiAmJlxuICAgICAgICAgICAgICAgIFsnYm90aCcsICd0b3AnXS5pbmNsdWRlcyhwb3NpdGlvblBhZ2luYXRpb24gIT09IG51bGwgJiYgcG9zaXRpb25QYWdpbmF0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvblBhZ2luYXRpb24gOiAnJykgJiYgKGpzeChNUlRfVGFibGVQYWdpbmF0aW9uLCB7IHBvc2l0aW9uOiBcInRvcFwiLCB0YWJsZTogdGFibGUgfSkpLCBqc3goTVJUX0xpbmVhclByb2dyZXNzQmFyLCB7IGlzVG9wVG9vbGJhcjogdHJ1ZSwgdGFibGU6IHRhYmxlIH0pXSB9KSkpO1xufTtcblxuY29uc3QgTVJUX1RhYmxlUGFwZXIgPSAoX2EpID0+IHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IHRhYmxlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widGFibGVcIl0pO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIG9wdGlvbnM6IHsgZW5hYmxlQm90dG9tVG9vbGJhciwgZW5hYmxlVG9wVG9vbGJhciwgbXJ0VGhlbWU6IHsgYmFzZUJhY2tncm91bmRDb2xvciB9LCBtdWlUYWJsZVBhcGVyUHJvcHMsIHJlbmRlckJvdHRvbVRvb2xiYXIsIHJlbmRlclRvcFRvb2xiYXIsIH0sIHJlZnM6IHsgdGFibGVQYXBlclJlZiB9LCB9ID0gdGFibGU7XG4gICAgY29uc3QgeyBpc0Z1bGxTY3JlZW4gfSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgcGFwZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VGcm9tVmFsdWVzT3JGdW5jKG11aVRhYmxlUGFwZXJQcm9wcywgeyB0YWJsZSB9KSksIHJlc3QpO1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgICByZXR1cm4gKGpzeHMoUGFwZXIsIE9iamVjdC5hc3NpZ24oeyBlbGV2YXRpb246IDIsIG9uS2V5RG93bjogKGUpID0+IGUua2V5ID09PSAnRXNjYXBlJyAmJiB0YWJsZS5zZXRJc0Z1bGxTY3JlZW4oZmFsc2UpIH0sIHBhcGVyUHJvcHMsIHsgcmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgICB0YWJsZVBhcGVyUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICBpZiAocGFwZXJQcm9wcyA9PT0gbnVsbCB8fCBwYXBlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXBlclByb3BzLnJlZikge1xuICAgICAgICAgICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHBhcGVyUHJvcHMucmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChpc0Z1bGxTY3JlZW5cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDBkdmgnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogJzEwMGR2aCcsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDBkdncnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwZHZ3JyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoZW1lLnpJbmRleC5tb2RhbCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pKSwgcGFwZXJQcm9wcyA9PT0gbnVsbCB8fCBwYXBlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXBlclByb3BzLnN0eWxlKSwgc3g6ICh0aGVtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBiYWNrZ3JvdW5kQ29sb3I6IGJhc2VCYWNrZ3JvdW5kQ29sb3IsIGJhY2tncm91bmRJbWFnZTogJ3Vuc2V0Jywgb3ZlcmZsb3c6ICdoaWRkZW4nLCB0cmFuc2l0aW9uOiAnYWxsIDEwMG1zIGVhc2UtaW4tb3V0JyB9LCBwYXJzZUZyb21WYWx1ZXNPckZ1bmMocGFwZXJQcm9wcyA9PT0gbnVsbCB8fCBwYXBlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXBlclByb3BzLnN4LCB0aGVtZSkpKSwgY2hpbGRyZW46IFtlbmFibGVUb3BUb29sYmFyICYmXG4gICAgICAgICAgICAgICAgKChfYiA9IHBhcnNlRnJvbVZhbHVlc09yRnVuYyhyZW5kZXJUb3BUb29sYmFyLCB7IHRhYmxlIH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoanN4KE1SVF9Ub3BUb29sYmFyLCB7IHRhYmxlOiB0YWJsZSB9KSkpLCBqc3goTVJUX1RhYmxlQ29udGFpbmVyLCB7IHRhYmxlOiB0YWJsZSB9KSwgZW5hYmxlQm90dG9tVG9vbGJhciAmJlxuICAgICAgICAgICAgICAgICgoX2MgPSBwYXJzZUZyb21WYWx1ZXNPckZ1bmMocmVuZGVyQm90dG9tVG9vbGJhciwgeyB0YWJsZSB9KSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKGpzeChNUlRfQm90dG9tVG9vbGJhciwgeyB0YWJsZTogdGFibGUgfSkpKV0gfSkpKTtcbn07XG5cbmNvbnN0IGlzVGFibGVJbnN0YW5jZVByb3AgPSAocHJvcHMpID0+IHByb3BzLnRhYmxlICE9PSB1bmRlZmluZWQ7XG5jb25zdCBNYXRlcmlhbFJlYWN0VGFibGUgPSAocHJvcHMpID0+IHtcbiAgICBsZXQgdGFibGU7XG4gICAgaWYgKGlzVGFibGVJbnN0YW5jZVByb3AocHJvcHMpKSB7XG4gICAgICAgIHRhYmxlID0gcHJvcHMudGFibGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YWJsZSA9IHVzZU1hdGVyaWFsUmVhY3RUYWJsZShwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBqc3goTVJUX1RhYmxlUGFwZXIsIHsgdGFibGU6IHRhYmxlIH0pO1xufTtcblxuZXhwb3J0IHsgTVJUX0FjdGlvbk1lbnVJdGVtLCBNUlRfQWdncmVnYXRpb25GbnMsIE1SVF9Cb3R0b21Ub29sYmFyLCBNUlRfQ29sdW1uQWN0aW9uTWVudSwgTVJUX0NvbHVtblBpbm5pbmdCdXR0b25zLCBNUlRfQ29weUJ1dHRvbiwgTVJUX0RlZmF1bHRDb2x1bW4sIE1SVF9EZWZhdWx0RGlzcGxheUNvbHVtbiwgTVJUX0VkaXRBY3Rpb25CdXR0b25zLCBNUlRfRWRpdENlbGxUZXh0RmllbGQsIE1SVF9FZGl0Um93TW9kYWwsIE1SVF9FeHBhbmRBbGxCdXR0b24sIE1SVF9FeHBhbmRCdXR0b24sIE1SVF9GaWx0ZXJDaGVja2JveCwgTVJUX0ZpbHRlckZucywgTVJUX0ZpbHRlck9wdGlvbk1lbnUsIE1SVF9GaWx0ZXJSYW5nZUZpZWxkcywgTVJUX0ZpbHRlclJhbmdlU2xpZGVyLCBNUlRfRmlsdGVyVGV4dEZpZWxkLCBNUlRfR2xvYmFsRmlsdGVyVGV4dEZpZWxkLCBNUlRfR3JhYkhhbmRsZUJ1dHRvbiwgTVJUX0xpbmVhclByb2dyZXNzQmFyLCBNUlRfUm93QWN0aW9uTWVudSwgTVJUX1Jvd1BpbkJ1dHRvbiwgTVJUX1NlbGVjdENoZWNrYm94LCBNUlRfU2hvd0hpZGVDb2x1bW5zQnV0dG9uLCBNUlRfU2hvd0hpZGVDb2x1bW5zTWVudSwgTVJUX1Nob3dIaWRlQ29sdW1uc01lbnVJdGVtcywgTVJUX1NvcnRpbmdGbnMsIE1SVF9UYWJsZSwgTVJUX1RhYmxlQm9keSwgTVJUX1RhYmxlQm9keUNlbGwsIE1SVF9UYWJsZUJvZHlDZWxsVmFsdWUsIE1SVF9UYWJsZUJvZHlSb3csIE1SVF9UYWJsZUJvZHlSb3dHcmFiSGFuZGxlLCBNUlRfVGFibGVCb2R5Um93UGluQnV0dG9uLCBNUlRfVGFibGVDb250YWluZXIsIE1SVF9UYWJsZURldGFpbFBhbmVsLCBNUlRfVGFibGVGb290ZXIsIE1SVF9UYWJsZUZvb3RlckNlbGwsIE1SVF9UYWJsZUZvb3RlclJvdywgTVJUX1RhYmxlSGVhZCwgTVJUX1RhYmxlSGVhZENlbGwsIE1SVF9UYWJsZUhlYWRDZWxsQ29sdW1uQWN0aW9uc0J1dHRvbiwgTVJUX1RhYmxlSGVhZENlbGxGaWx0ZXJDb250YWluZXIsIE1SVF9UYWJsZUhlYWRDZWxsRmlsdGVyTGFiZWwsIE1SVF9UYWJsZUhlYWRDZWxsR3JhYkhhbmRsZSwgTVJUX1RhYmxlSGVhZENlbGxSZXNpemVIYW5kbGUsIE1SVF9UYWJsZUhlYWRDZWxsU29ydExhYmVsLCBNUlRfVGFibGVIZWFkUm93LCBNUlRfVGFibGVMb2FkaW5nT3ZlcmxheSwgTVJUX1RhYmxlUGFnaW5hdGlvbiwgTVJUX1RhYmxlUGFwZXIsIE1SVF9Ub2dnbGVEZW5zZVBhZGRpbmdCdXR0b24sIE1SVF9Ub2dnbGVGaWx0ZXJzQnV0dG9uLCBNUlRfVG9nZ2xlRnVsbFNjcmVlbkJ1dHRvbiwgTVJUX1RvZ2dsZUdsb2JhbEZpbHRlckJ1dHRvbiwgTVJUX1RvZ2dsZVJvd0FjdGlvbk1lbnVCdXR0b24sIE1SVF9Ub29sYmFyQWxlcnRCYW5uZXIsIE1SVF9Ub29sYmFyRHJvcFpvbmUsIE1SVF9Ub29sYmFySW50ZXJuYWxCdXR0b25zLCBNUlRfVG9wVG9vbGJhciwgTWF0ZXJpYWxSZWFjdFRhYmxlLCBNZW1vX01SVF9UYWJsZUJvZHksIE1lbW9fTVJUX1RhYmxlQm9keUNlbGwsIE1lbW9fTVJUX1RhYmxlQm9keVJvdywgY2VsbEtleWJvYXJkU2hvcnRjdXRzLCBjcmVhdGVNUlRDb2x1bW5IZWxwZXIsIGNyZWF0ZVJvdywgZGVmYXVsdERpc3BsYXlDb2x1bW5Qcm9wcywgZmxleFJlbmRlciwgZ2V0QWxsTGVhZkNvbHVtbkRlZnMsIGdldENhblJhbmtSb3dzLCBnZXRDb2x1bW5GaWx0ZXJJbmZvLCBnZXRDb2x1bW5JZCwgZ2V0RGVmYXVsdENvbHVtbkZpbHRlckZuLCBnZXREZWZhdWx0Q29sdW1uT3JkZXJJZHMsIGdldElzUmFua2luZ1Jvd3MsIGdldElzUm93U2VsZWN0ZWQsIGdldExlYWRpbmdEaXNwbGF5Q29sdW1uSWRzLCBnZXRNUlRfUm93U2VsZWN0aW9uSGFuZGxlciwgZ2V0TVJUX1Jvd3MsIGdldE1SVF9TZWxlY3RBbGxIYW5kbGVyLCBnZXRUcmFpbGluZ0Rpc3BsYXlDb2x1bW5JZHMsIGlzQ2VsbEVkaXRhYmxlLCBtcnRGaWx0ZXJPcHRpb25zLCBvcGVuRWRpdGluZ0NlbGwsIHByZXBhcmVDb2x1bW5zLCByYW5rR2xvYmFsRnV6enksIHJlb3JkZXJDb2x1bW4sIHNob3dSb3dBY3Rpb25zQ29sdW1uLCBzaG93Um93RHJhZ0NvbHVtbiwgc2hvd1Jvd0V4cGFuZENvbHVtbiwgc2hvd1Jvd051bWJlcnNDb2x1bW4sIHNob3dSb3dQaW5uaW5nQ29sdW1uLCBzaG93Um93U2VsZWN0aW9uQ29sdW1uLCBzaG93Um93U3BhY2VyQ29sdW1uLCB1c2VEcm9wZG93bk9wdGlvbnMsIHVzZU1SVF9Db2x1bW5WaXJ0dWFsaXplciwgdXNlTVJUX0VmZmVjdHMsIHVzZU1SVF9Sb3dWaXJ0dWFsaXplciwgdXNlTVJUX1Jvd3MsIHVzZU1SVF9UYWJsZUluc3RhbmNlLCB1c2VNUlRfVGFibGVPcHRpb25zLCB1c2VNYXRlcmlhbFJlYWN0VGFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/material-react-table/dist/index.esm.js\n");

/***/ })

};
;